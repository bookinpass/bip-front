import { AfterViewInit, EventEmitter, OnChanges, OnDestroy, OnInit, SimpleChanges } from '@angular/core';
import Swal, { SweetAlertOptions, SweetAlertResult } from 'sweetalert2';
import * as events from './swal-events';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,
 *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't @Inputs but @Outputs: onBeforeOpen, onOpen, onClose, onAfterClose and onDestroy
 *     (but without "on*" prefix to respect community standards).
 *     However, preConfirm and inputValidator are still @Inputs because there are not event handlers, there can't be
 *     multiple listeners and we need the values they can/must return.
 */
import * as ɵngcc0 from '@angular/core';
export declare class SwalComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy {
    private readonly sweetAlert2Loader;
    private readonly moduleLevelFireOnInit;
    private readonly moduleLevelDismissOnDestroy;
    title: SweetAlertOptions['title'];
    titleText: SweetAlertOptions['titleText'];
    text: SweetAlertOptions['text'];
    html: SweetAlertOptions['html'];
    footer: SweetAlertOptions['footer'];
    icon: SweetAlertOptions['icon'];
    iconHtml: SweetAlertOptions['iconHtml'];
    backdrop: SweetAlertOptions['backdrop'];
    toast: SweetAlertOptions['toast'];
    target: SweetAlertOptions['target'];
    input: SweetAlertOptions['input'];
    width: SweetAlertOptions['width'];
    padding: SweetAlertOptions['padding'];
    background: SweetAlertOptions['background'];
    position: SweetAlertOptions['position'];
    grow: SweetAlertOptions['grow'];
    showClass: SweetAlertOptions['showClass'];
    hideClass: SweetAlertOptions['hideClass'];
    customClass: SweetAlertOptions['customClass'];
    timer: SweetAlertOptions['timer'];
    timerProgressBar: SweetAlertOptions['timerProgressBar'];
    /** @deprecated Use showClass and hideClass instead */
    animation: SweetAlertOptions['animation'];
    heightAuto: SweetAlertOptions['heightAuto'];
    allowOutsideClick: SweetAlertOptions['allowOutsideClick'];
    allowEscapeKey: SweetAlertOptions['allowEscapeKey'];
    allowEnterKey: SweetAlertOptions['allowEnterKey'];
    stopKeydownPropagation: SweetAlertOptions['stopKeydownPropagation'];
    keydownListenerCapture: SweetAlertOptions['keydownListenerCapture'];
    showConfirmButton: SweetAlertOptions['showConfirmButton'];
    showCancelButton: SweetAlertOptions['showCancelButton'];
    confirmButtonText: SweetAlertOptions['confirmButtonText'];
    cancelButtonText: SweetAlertOptions['cancelButtonText'];
    confirmButtonColor: SweetAlertOptions['confirmButtonColor'];
    cancelButtonColor: SweetAlertOptions['cancelButtonColor'];
    confirmButtonAriaLabel: SweetAlertOptions['confirmButtonAriaLabel'];
    cancelButtonAriaLabel: SweetAlertOptions['cancelButtonAriaLabel'];
    buttonsStyling: SweetAlertOptions['buttonsStyling'];
    reverseButtons: SweetAlertOptions['reverseButtons'];
    focusConfirm: SweetAlertOptions['focusConfirm'];
    focusCancel: SweetAlertOptions['focusCancel'];
    showCloseButton: SweetAlertOptions['showCloseButton'];
    closeButtonHtml: SweetAlertOptions['closeButtonHtml'];
    closeButtonAriaLabel: SweetAlertOptions['closeButtonAriaLabel'];
    showLoaderOnConfirm: SweetAlertOptions['showLoaderOnConfirm'];
    preConfirm: SweetAlertOptions['preConfirm'];
    imageUrl: SweetAlertOptions['imageUrl'];
    imageWidth: SweetAlertOptions['imageWidth'];
    imageHeight: SweetAlertOptions['imageHeight'];
    imageAlt: SweetAlertOptions['imageAlt'];
    inputPlaceholder: SweetAlertOptions['inputPlaceholder'];
    inputValue: SweetAlertOptions['inputValue'];
    inputOptions: SweetAlertOptions['inputOptions'];
    inputAutoTrim: SweetAlertOptions['inputAutoTrim'];
    inputAttributes: SweetAlertOptions['inputAttributes'];
    inputValidator: SweetAlertOptions['inputValidator'];
    validationMessage: SweetAlertOptions['validationMessage'];
    progressSteps: SweetAlertOptions['progressSteps'];
    currentProgressStep: SweetAlertOptions['currentProgressStep'];
    progressStepsDistance: SweetAlertOptions['progressStepsDistance'];
    scrollbarPadding: SweetAlertOptions['scrollbarPadding'];
    /**
     * An object of SweetAlert2 native options, useful if:
     *  - you don't want to use the @Inputs for practical/philosophical reasons ;
     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
     *
     * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
     *     previous properties you want to erase again.
     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
     *
     * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
     */
    set swalOptions(options: SweetAlertOptions);
    /**
     * Computes the options object that will get passed to SweetAlert2.
     * Only the properties that have been set at least once on this component will be returned.
     * Mostly for internal usage.
     */
    get swalOptions(): SweetAlertOptions;
    /**
     * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.
     * When left undefined (default), the value will be inherited from the module configuration, which is `false`.
     *
     * Example:
     *     <swal *ngIf="error" [title]="error.title" [text]="error.text" icon="error" [swalFireOnInit]="true"></swal>
     */
    swalFireOnInit?: boolean;
    /**
     * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.
     * When left undefined (default), the value will be inherited from the module configuration, which is `true`.
     */
    swalDismissOnDestroy?: boolean;
    set swalVisible(visible: boolean);
    get swalVisible(): boolean;
    /**
     * Emits an event when the modal DOM element has been created.
     * Useful to perform DOM mutations before the modal is shown.
     */
    readonly beforeOpen: EventEmitter<events.BeforeOpenEvent>;
    /**
     * Emits an event when the modal is shown.
     */
    readonly open: EventEmitter<events.OpenEvent>;
    /**
     * Emits an event when the modal DOM is rendered.
     */
    readonly render: EventEmitter<events.RenderEvent>;
    /**
     * Emits an event when the modal will be closed.
     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
     */
    readonly close: EventEmitter<events.CloseEvent>;
    /**
     * Emits an event after the modal had been closed.
     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
     */
    readonly afterClose: EventEmitter<void>;
    /**
     * Emits an event after the modal had been closed.
     * The difference between {@link destroy} and {@link afterClose} is that the latter is called for user interactions
     * only (clicks), whereas {@link destroy} is always called, both for user interactions and popup being closed by
     * another popup.
     */
    readonly destroy: EventEmitter<void>;
    /**
     * Emits when the user clicks "Confirm".
     * Bears a value when using "input", resolved "preConfirm", etc.
     *
     * Example:
     *     <swal (confirm)="handleConfirm($event)"></swal>
     *
     *     public handleConfirm(email: string): void {
     *         // ... save user email
     *     }
     */
    readonly confirm: EventEmitter<any>;
    /**
     * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
     * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
     * The reason is `undefined` when {@link dismiss} is called.
     *
     * Example:
     *     <swal (cancel)="handleCancel($event)"></swal>
     *
     *     public handleCancel(reason: DismissReason | undefined): void {
     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
     *         // ... do something
     *     }
     */
    readonly cancel: EventEmitter<Swal.DismissReason | undefined>;
    /**
     * This Set retains the properties that have been changed from @Inputs, so we can know precisely
     * what options we have to send to {@link Swal.fire}.
     */
    private readonly touchedProps;
    /**
     * A function of signature `(propName: string): void` that adds a given property name to the list of
     * touched properties, ie. {@link touchedProps}.
     */
    private readonly markTouched;
    /**
     * Is the SweetAlert2 modal represented by this component currently opened?
     */
    private isCurrentlyShown;
    constructor(sweetAlert2Loader: SweetAlert2LoaderService, moduleLevelFireOnInit: boolean, moduleLevelDismissOnDestroy: boolean);
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     */
    ngOnInit(): void;
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     */
    ngAfterViewInit(): void;
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     */
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     */
    ngOnDestroy(): void;
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     */
    fire(): Promise<SweetAlertResult>;
    /**
     * Closes the modal, if opened.
     *
     * @param result The value that the modal will resolve with, triggering either (confirm) or (cancel).
     *               If the argument is not passed, (dimiss) will emit `undefined`.
     *               See {@link Swal.close}
     */
    dismiss(result?: SweetAlertResult): Promise<void>;
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param options
     */
    update(options?: SweetAlertOptions): Promise<void>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SwalComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<SwalComponent, "swal", never, { "swalOptions": "swalOptions"; "swalVisible": "swalVisible"; "title": "title"; "titleText": "titleText"; "text": "text"; "html": "html"; "footer": "footer"; "icon": "icon"; "iconHtml": "iconHtml"; "backdrop": "backdrop"; "toast": "toast"; "target": "target"; "input": "input"; "width": "width"; "padding": "padding"; "background": "background"; "position": "position"; "grow": "grow"; "showClass": "showClass"; "hideClass": "hideClass"; "customClass": "customClass"; "timer": "timer"; "timerProgressBar": "timerProgressBar"; "animation": "animation"; "heightAuto": "heightAuto"; "allowOutsideClick": "allowOutsideClick"; "allowEscapeKey": "allowEscapeKey"; "allowEnterKey": "allowEnterKey"; "stopKeydownPropagation": "stopKeydownPropagation"; "keydownListenerCapture": "keydownListenerCapture"; "showConfirmButton": "showConfirmButton"; "showCancelButton": "showCancelButton"; "confirmButtonText": "confirmButtonText"; "cancelButtonText": "cancelButtonText"; "confirmButtonColor": "confirmButtonColor"; "cancelButtonColor": "cancelButtonColor"; "confirmButtonAriaLabel": "confirmButtonAriaLabel"; "cancelButtonAriaLabel": "cancelButtonAriaLabel"; "buttonsStyling": "buttonsStyling"; "reverseButtons": "reverseButtons"; "focusConfirm": "focusConfirm"; "focusCancel": "focusCancel"; "showCloseButton": "showCloseButton"; "closeButtonHtml": "closeButtonHtml"; "closeButtonAriaLabel": "closeButtonAriaLabel"; "showLoaderOnConfirm": "showLoaderOnConfirm"; "preConfirm": "preConfirm"; "imageUrl": "imageUrl"; "imageWidth": "imageWidth"; "imageHeight": "imageHeight"; "imageAlt": "imageAlt"; "inputPlaceholder": "inputPlaceholder"; "inputValue": "inputValue"; "inputOptions": "inputOptions"; "inputAutoTrim": "inputAutoTrim"; "inputAttributes": "inputAttributes"; "inputValidator": "inputValidator"; "validationMessage": "validationMessage"; "progressSteps": "progressSteps"; "currentProgressStep": "currentProgressStep"; "progressStepsDistance": "progressStepsDistance"; "scrollbarPadding": "scrollbarPadding"; "swalFireOnInit": "swalFireOnInit"; "swalDismissOnDestroy": "swalDismissOnDestroy"; }, { "beforeOpen": "beforeOpen"; "open": "open"; "render": "render"; "close": "close"; "afterClose": "afterClose"; "destroy": "destroy"; "confirm": "confirm"; "cancel": "cancel"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsic3dhbC5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBTd2FsLCB7IFN3ZWV0QWxlcnRPcHRpb25zLCBTd2VldEFsZXJ0UmVzdWx0IH0gZnJvbSAnc3dlZXRhbGVydDInO1xuaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJy4vc3dhbC1ldmVudHMnO1xuaW1wb3J0IHsgU3dlZXRBbGVydDJMb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi9zd2VldGFsZXJ0Mi1sb2FkZXIuc2VydmljZSc7XG4vKipcbiAqIDxzd2FsPiBjb21wb25lbnQuIFNlZSB0aGUgUkVBRE1FLm1kIGZvciB1c2FnZS5cbiAqXG4gKiBJdCBjb250YWlucyBhIGJ1bmNoIG9mIEBJbnB1dHMgdGhhdCBoYXZlIGEgcGVyZmVjdCAxOjEgbWFwcGluZyB3aXRoIFN3ZWV0QWxlcnQyIG9wdGlvbnMuXG4gKiBUaGVpciB0eXBlcyBhcmUgZGlyZWN0bHkgY29taW5nIGZyb20gU3dlZXRBbGVydDIgdHlwZXMgZGVmaW50aXRpb25zLCBtZWFuaW5nIHRoYXQgbmd4LXN3ZWV0YWxlcnQyIGlzIHRpZ2h0bHkgY291cGxlZFxuICogdG8gU3dlZXRBbGVydDIsIGJ1dCBhbHNvIGlzIHR5cGUtc2FmZS5cbiAqXG4gKiAoPykgSWYgeW91IHdhbnQgdG8gdXNlIGFuIG9iamVjdCB0aGF0IGRlY2xhcmVzIHRoZSBTd2VldEFsZXJ0MiBvcHRpb25zIGFsbCBhdCBvbmNlIHJhdGhlciB0aGFuIG1hbnkgQElucHV0cyxcbiAqICAgICB0YWtlIGEgbG9vayBhdCBbc3dhbE9wdGlvbnNdLCB0aGF0IGxldHMgeW91IHBhc3MgYSBmdWxsIHtAbGluayBTd2VldEFsZXJ0T3B0aW9uc30gb2JqZWN0LlxuICpcbiAqICg/KSBJZiB5b3UgYXJlIHJlYWRpbmcgdGhlIFR5cGVTY3JpcHQgc291cmNlIG9mIHRoaXMgY29tcG9uZW50LCB5b3UgbWF5IHRoaW5rIHRoYXQgaXQncyBhIGxvdCBvZiBjb2RlLlxuICogICAgIEJlIHN1cmUgdGhhdCBhIGxvdCBvZiB0aGlzIGNvZGUgaXMgdHlwZXMgYW5kIEFuZ3VsYXIgYm9pbGVycGxhdGUuIENvbXBpbGVkIGFuZCBtaW5pZmllZCBjb2RlIGlzIG11Y2ggc21hbGxlci5cbiAqICAgICBJZiB5b3UgYXJlIHJlYWxseSBjb25jZXJuZWQgYWJvdXQgcGVyZm9ybWFuY2UgYW5kL29yIGRvbid0IGNhcmUgYWJvdXQgdGhlIEFQSSBhbmQgaXRzIGNvbnZlbmllbnQgaW50ZWdyYXRpb25cbiAqICAgICB3aXRoIEFuZ3VsYXIgKG5vdGFibHkgY2hhbmdlIGRldGVjdGlvbiBhbmQgdHJhbnNjbHVzaW9uKSwgeW91IG1heSB0b3RhbGx5IHVzZSBTd2VldEFsZXJ0MiBuYXRpdmVseSBhcyB3ZWxsIDspXG4gKlxuICogLyFcXCBTb21lIFN3ZWV0QWxlcnQgb3B0aW9ucyBhcmVuJ3QgQElucHV0cyBidXQgQE91dHB1dHM6IG9uQmVmb3JlT3Blbiwgb25PcGVuLCBvbkNsb3NlLCBvbkFmdGVyQ2xvc2UgYW5kIG9uRGVzdHJveVxuICogICAgIChidXQgd2l0aG91dCBcIm9uKlwiIHByZWZpeCB0byByZXNwZWN0IGNvbW11bml0eSBzdGFuZGFyZHMpLlxuICogICAgIEhvd2V2ZXIsIHByZUNvbmZpcm0gYW5kIGlucHV0VmFsaWRhdG9yIGFyZSBzdGlsbCBASW5wdXRzIGJlY2F1c2UgdGhlcmUgYXJlIG5vdCBldmVudCBoYW5kbGVycywgdGhlcmUgY2FuJ3QgYmVcbiAqICAgICBtdWx0aXBsZSBsaXN0ZW5lcnMgYW5kIHdlIG5lZWQgdGhlIHZhbHVlcyB0aGV5IGNhbi9tdXN0IHJldHVybi5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgU3dhbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc3dlZXRBbGVydDJMb2FkZXI7XG4gICAgcHJpdmF0ZSByZWFkb25seSBtb2R1bGVMZXZlbEZpcmVPbkluaXQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBtb2R1bGVMZXZlbERpc21pc3NPbkRlc3Ryb3k7XG4gICAgdGl0bGU6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZSddO1xuICAgIHRpdGxlVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ3RpdGxlVGV4dCddO1xuICAgIHRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0ZXh0J107XG4gICAgaHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2h0bWwnXTtcbiAgICBmb290ZXI6IFN3ZWV0QWxlcnRPcHRpb25zWydmb290ZXInXTtcbiAgICBpY29uOiBTd2VldEFsZXJ0T3B0aW9uc1snaWNvbiddO1xuICAgIGljb25IdG1sOiBTd2VldEFsZXJ0T3B0aW9uc1snaWNvbkh0bWwnXTtcbiAgICBiYWNrZHJvcDogU3dlZXRBbGVydE9wdGlvbnNbJ2JhY2tkcm9wJ107XG4gICAgdG9hc3Q6IFN3ZWV0QWxlcnRPcHRpb25zWyd0b2FzdCddO1xuICAgIHRhcmdldDogU3dlZXRBbGVydE9wdGlvbnNbJ3RhcmdldCddO1xuICAgIGlucHV0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXQnXTtcbiAgICB3aWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ3dpZHRoJ107XG4gICAgcGFkZGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ3BhZGRpbmcnXTtcbiAgICBiYWNrZ3JvdW5kOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2dyb3VuZCddO1xuICAgIHBvc2l0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXTtcbiAgICBncm93OiBTd2VldEFsZXJ0T3B0aW9uc1snZ3JvdyddO1xuICAgIHNob3dDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDbGFzcyddO1xuICAgIGhpZGVDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2hpZGVDbGFzcyddO1xuICAgIGN1c3RvbUNsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snY3VzdG9tQ2xhc3MnXTtcbiAgICB0aW1lcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyJ107XG4gICAgdGltZXJQcm9ncmVzc0JhcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyUHJvZ3Jlc3NCYXInXTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIHNob3dDbGFzcyBhbmQgaGlkZUNsYXNzIGluc3RlYWQgKi9cbiAgICBhbmltYXRpb246IFN3ZWV0QWxlcnRPcHRpb25zWydhbmltYXRpb24nXTtcbiAgICBoZWlnaHRBdXRvOiBTd2VldEFsZXJ0T3B0aW9uc1snaGVpZ2h0QXV0byddO1xuICAgIGFsbG93T3V0c2lkZUNsaWNrOiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dPdXRzaWRlQ2xpY2snXTtcbiAgICBhbGxvd0VzY2FwZUtleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RXNjYXBlS2V5J107XG4gICAgYWxsb3dFbnRlcktleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RW50ZXJLZXknXTtcbiAgICBzdG9wS2V5ZG93blByb3BhZ2F0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc3RvcEtleWRvd25Qcm9wYWdhdGlvbiddO1xuICAgIGtleWRvd25MaXN0ZW5lckNhcHR1cmU6IFN3ZWV0QWxlcnRPcHRpb25zWydrZXlkb3duTGlzdGVuZXJDYXB0dXJlJ107XG4gICAgc2hvd0NvbmZpcm1CdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q29uZmlybUJ1dHRvbiddO1xuICAgIHNob3dDYW5jZWxCdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q2FuY2VsQnV0dG9uJ107XG4gICAgY29uZmlybUJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uVGV4dCddO1xuICAgIGNhbmNlbEJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25UZXh0J107XG4gICAgY29uZmlybUJ1dHRvbkNvbG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvbkNvbG9yJ107XG4gICAgY2FuY2VsQnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25Db2xvciddO1xuICAgIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgY2FuY2VsQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgYnV0dG9uc1N0eWxpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydidXR0b25zU3R5bGluZyddO1xuICAgIHJldmVyc2VCdXR0b25zOiBTd2VldEFsZXJ0T3B0aW9uc1sncmV2ZXJzZUJ1dHRvbnMnXTtcbiAgICBmb2N1c0NvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydmb2N1c0NvbmZpcm0nXTtcbiAgICBmb2N1c0NhbmNlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzQ2FuY2VsJ107XG4gICAgc2hvd0Nsb3NlQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0Nsb3NlQnV0dG9uJ107XG4gICAgY2xvc2VCdXR0b25IdG1sOiBTd2VldEFsZXJ0T3B0aW9uc1snY2xvc2VCdXR0b25IdG1sJ107XG4gICAgY2xvc2VCdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjbG9zZUJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIHNob3dMb2FkZXJPbkNvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93TG9hZGVyT25Db25maXJtJ107XG4gICAgcHJlQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3ByZUNvbmZpcm0nXTtcbiAgICBpbWFnZVVybDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlVXJsJ107XG4gICAgaW1hZ2VXaWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlV2lkdGgnXTtcbiAgICBpbWFnZUhlaWdodDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlSGVpZ2h0J107XG4gICAgaW1hZ2VBbHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZUFsdCddO1xuICAgIGlucHV0UGxhY2Vob2xkZXI6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFBsYWNlaG9sZGVyJ107XG4gICAgaW5wdXRWYWx1ZTogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsdWUnXTtcbiAgICBpbnB1dE9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dE9wdGlvbnMnXTtcbiAgICBpbnB1dEF1dG9UcmltOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRBdXRvVHJpbSddO1xuICAgIGlucHV0QXR0cmlidXRlczogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXR0cmlidXRlcyddO1xuICAgIGlucHV0VmFsaWRhdG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRWYWxpZGF0b3InXTtcbiAgICB2YWxpZGF0aW9uTWVzc2FnZTogU3dlZXRBbGVydE9wdGlvbnNbJ3ZhbGlkYXRpb25NZXNzYWdlJ107XG4gICAgcHJvZ3Jlc3NTdGVwczogU3dlZXRBbGVydE9wdGlvbnNbJ3Byb2dyZXNzU3RlcHMnXTtcbiAgICBjdXJyZW50UHJvZ3Jlc3NTdGVwOiBTd2VldEFsZXJ0T3B0aW9uc1snY3VycmVudFByb2dyZXNzU3RlcCddO1xuICAgIHByb2dyZXNzU3RlcHNEaXN0YW5jZTogU3dlZXRBbGVydE9wdGlvbnNbJ3Byb2dyZXNzU3RlcHNEaXN0YW5jZSddO1xuICAgIHNjcm9sbGJhclBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydzY3JvbGxiYXJQYWRkaW5nJ107XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IG9mIFN3ZWV0QWxlcnQyIG5hdGl2ZSBvcHRpb25zLCB1c2VmdWwgaWY6XG4gICAgICogIC0geW91IGRvbid0IHdhbnQgdG8gdXNlIHRoZSBASW5wdXRzIGZvciBwcmFjdGljYWwvcGhpbG9zb3BoaWNhbCByZWFzb25zIDtcbiAgICAgKiAgLSB0aGVyZSBhcmUgbWlzc2luZyBASW5wdXRzIGJlY2F1c2Ugbmd4LXN3ZWV0YWxlcnQyIGlzbid0IHVwLXRvLWRhdGUgd2l0aCBTd2VldEFsZXJ0MidzIGxhdGVzdCBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogLyFcXCBQbGVhc2Ugbm90ZSB0aGF0IHNldHRpbmcgdGhpcyBwcm9wZXJ0eSBkb2VzIE5PVCBlcmFzZSB3aGF0IGhhcyBiZWVuIHNldCBiZWZvcmUgdW5sZXNzIHlvdSBzcGVjaWZ5IHRoZVxuICAgICAqICAgICBwcmV2aW91cyBwcm9wZXJ0aWVzIHlvdSB3YW50IHRvIGVyYXNlIGFnYWluLlxuICAgICAqICAgICBJZS4gc2V0dGluZyB7IHRpdGxlOiAnVGl0bGUnIH0gYW5kIHRoZW4geyB0ZXh0OiAnVGV4dCcgfSB3aWxsIGdpdmUgeyB0aXRsZTogJ1RpdGxlJywgdGV4dDogJ1RleHQnIH0uXG4gICAgICpcbiAgICAgKiAvIVxcIEJlIGF3YXJlIHRoYXQgdGhlIG9wdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCB3aWxsIG92ZXJyaWRlIHRoZSBASW5wdXRzIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAgICovXG4gICAgc2V0IHN3YWxPcHRpb25zKG9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgb3B0aW9ucyBvYmplY3QgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gU3dlZXRBbGVydDIuXG4gICAgICogT25seSB0aGUgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiBzZXQgYXQgbGVhc3Qgb25jZSBvbiB0aGlzIGNvbXBvbmVudCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIE1vc3RseSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgICovXG4gICAgZ2V0IHN3YWxPcHRpb25zKCk6IFN3ZWV0QWxlcnRPcHRpb25zO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZmlyZSB0aGUgbW9kYWwgYXMgc29vbiBhcyB0aGUgPHN3YWw+IGNvbXBvbmVudCBpcyBjcmVhdGVkIGFuZCBpbml0aWFsaXplZCBpbiB0aGUgdmlldy5cbiAgICAgKiBXaGVuIGxlZnQgdW5kZWZpbmVkIChkZWZhdWx0KSwgdGhlIHZhbHVlIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gdGhlIG1vZHVsZSBjb25maWd1cmF0aW9uLCB3aGljaCBpcyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKm5nSWY9XCJlcnJvclwiIFt0aXRsZV09XCJlcnJvci50aXRsZVwiIFt0ZXh0XT1cImVycm9yLnRleHRcIiBpY29uPVwiZXJyb3JcIiBbc3dhbEZpcmVPbkluaXRdPVwidHJ1ZVwiPjwvc3dhbD5cbiAgICAgKi9cbiAgICBzd2FsRmlyZU9uSW5pdD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBkaXNtaXNzIHRoZSBtb2RhbCB3aGVuIHRoZSA8c3dhbD4gY29tcG9uZW50IGlzIGRlc3Ryb3llZCBieSBBbmd1bGFyIChmb3IgYW55IHJlYXNvbikgb3Igbm90LlxuICAgICAqIFdoZW4gbGVmdCB1bmRlZmluZWQgKGRlZmF1bHQpLCB0aGUgdmFsdWUgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgbW9kdWxlIGNvbmZpZ3VyYXRpb24sIHdoaWNoIGlzIGB0cnVlYC5cbiAgICAgKi9cbiAgICBzd2FsRGlzbWlzc09uRGVzdHJveT86IGJvb2xlYW47XG4gICAgc2V0IHN3YWxWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pO1xuICAgIGdldCBzd2FsVmlzaWJsZSgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG1vZGFsIERPTSBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogVXNlZnVsIHRvIHBlcmZvcm0gRE9NIG11dGF0aW9ucyBiZWZvcmUgdGhlIG1vZGFsIGlzIHNob3duLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGJlZm9yZU9wZW46IEV2ZW50RW1pdHRlcjxldmVudHMuQmVmb3JlT3BlbkV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBtb2RhbCBpcyBzaG93bi5cbiAgICAgKi9cbiAgICByZWFkb25seSBvcGVuOiBFdmVudEVtaXR0ZXI8ZXZlbnRzLk9wZW5FdmVudD47XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgRE9NIGlzIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHJlbmRlcjogRXZlbnRFbWl0dGVyPGV2ZW50cy5SZW5kZXJFdmVudD47XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgd2lsbCBiZSBjbG9zZWQuXG4gICAgICogSWYgeW91IGp1c3Qgd2FudCB0byBrbm93IHdoZW4gdGhlIHVzZXIgZGlzbWlzc2VkIHRoZSBtb2RhbCwgcHJlZmVyIHRoZSBoaWdoZXItbGV2ZWwgKGNhbmNlbCkgb3V0cHV0LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNsb3NlOiBFdmVudEVtaXR0ZXI8ZXZlbnRzLkNsb3NlRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSBtb2RhbCBoYWQgYmVlbiBjbG9zZWQuXG4gICAgICogSWYgeW91IGp1c3Qgd2FudCB0byBrbm93IHdoZW4gdGhlIHVzZXIgZGlzbWlzc2VkIHRoZSBtb2RhbCwgcHJlZmVyIHRoZSBoaWdoZXItbGV2ZWwgKGNhbmNlbCkgb3V0cHV0LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGFmdGVyQ2xvc2U6IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgbW9kYWwgaGFkIGJlZW4gY2xvc2VkLlxuICAgICAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4ge0BsaW5rIGRlc3Ryb3l9IGFuZCB7QGxpbmsgYWZ0ZXJDbG9zZX0gaXMgdGhhdCB0aGUgbGF0dGVyIGlzIGNhbGxlZCBmb3IgdXNlciBpbnRlcmFjdGlvbnNcbiAgICAgKiBvbmx5IChjbGlja3MpLCB3aGVyZWFzIHtAbGluayBkZXN0cm95fSBpcyBhbHdheXMgY2FsbGVkLCBib3RoIGZvciB1c2VyIGludGVyYWN0aW9ucyBhbmQgcG9wdXAgYmVpbmcgY2xvc2VkIGJ5XG4gICAgICogYW5vdGhlciBwb3B1cC5cbiAgICAgKi9cbiAgICByZWFkb25seSBkZXN0cm95OiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDb25maXJtXCIuXG4gICAgICogQmVhcnMgYSB2YWx1ZSB3aGVuIHVzaW5nIFwiaW5wdXRcIiwgcmVzb2x2ZWQgXCJwcmVDb25maXJtXCIsIGV0Yy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChjb25maXJtKT1cImhhbmRsZUNvbmZpcm0oJGV2ZW50KVwiPjwvc3dhbD5cbiAgICAgKlxuICAgICAqICAgICBwdWJsaWMgaGFuZGxlQ29uZmlybShlbWFpbDogc3RyaW5nKTogdm9pZCB7XG4gICAgICogICAgICAgICAvLyAuLi4gc2F2ZSB1c2VyIGVtYWlsXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICByZWFkb25seSBjb25maXJtOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiLCBvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciBhbGxvd2VkIHdheS5cbiAgICAgKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGVtaXQgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByZWFzb24gZm9yIHdoaWNoIHRoZSBTd2VldEFsZXJ0IGhhcyBiZWVuIGNsb3NlZC5cbiAgICAgKiBUaGUgcmVhc29uIGlzIGB1bmRlZmluZWRgIHdoZW4ge0BsaW5rIGRpc21pc3N9IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChjYW5jZWwpPVwiaGFuZGxlQ2FuY2VsKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNhbmNlbChyZWFzb246IERpc21pc3NSZWFzb24gfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIHJlYXNvbiBjYW4gYmUgJ2NhbmNlbCcsICdvdmVybGF5JywgJ2Nsb3NlJywgJ3RpbWVyJyBvciB1bmRlZmluZWQuXG4gICAgICogICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICByZWFkb25seSBjYW5jZWw6IEV2ZW50RW1pdHRlcjxTd2FsLkRpc21pc3NSZWFzb24gfCB1bmRlZmluZWQ+O1xuICAgIC8qKlxuICAgICAqIFRoaXMgU2V0IHJldGFpbnMgdGhlIHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gY2hhbmdlZCBmcm9tIEBJbnB1dHMsIHNvIHdlIGNhbiBrbm93IHByZWNpc2VseVxuICAgICAqIHdoYXQgb3B0aW9ucyB3ZSBoYXZlIHRvIHNlbmQgdG8ge0BsaW5rIFN3YWwuZmlyZX0uXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSB0b3VjaGVkUHJvcHM7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiBvZiBzaWduYXR1cmUgYChwcm9wTmFtZTogc3RyaW5nKTogdm9pZGAgdGhhdCBhZGRzIGEgZ2l2ZW4gcHJvcGVydHkgbmFtZSB0byB0aGUgbGlzdCBvZlxuICAgICAqIHRvdWNoZWQgcHJvcGVydGllcywgaWUuIHtAbGluayB0b3VjaGVkUHJvcHN9LlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgbWFya1RvdWNoZWQ7XG4gICAgLyoqXG4gICAgICogSXMgdGhlIFN3ZWV0QWxlcnQyIG1vZGFsIHJlcHJlc2VudGVkIGJ5IHRoaXMgY29tcG9uZW50IGN1cnJlbnRseSBvcGVuZWQ/XG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0N1cnJlbnRseVNob3duO1xuICAgIGNvbnN0cnVjdG9yKHN3ZWV0QWxlcnQyTG9hZGVyOiBTd2VldEFsZXJ0MkxvYWRlclNlcnZpY2UsIG1vZHVsZUxldmVsRmlyZU9uSW5pdDogYm9vbGVhbiwgbW9kdWxlTGV2ZWxEaXNtaXNzT25EZXN0cm95OiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIEFza3MgdGhlIFN3ZWV0QWxlcnQyIGxvYWRlciBzZXJ2aWNlIHRvIHByZWxvYWQgdGhlIFN3ZWV0QWxlcnQyIGxpYnJhcnksIHNvIGl0IGJlZ2lucyB0byBiZSBsb2FkZWQgb25seSBpZiB0aGVyZVxuICAgICAqIGlzIGEgPHN3YWw+IGNvbXBvbmVudCBzb21ld2hlcmUsIGFuZCBpcyBwcm9iYWJseSBmdWxseSBsb2FkZWQgd2hlbiB0aGUgbW9kYWwgaGFzIHRvIGJlIGRpc3BsYXllZCxcbiAgICAgKiBjYXVzaW5nIG5vIGRlbGF5LlxuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBGaXJlcyB0aGUgbW9kYWwsIGlmIHRoZSBjb21wb25lbnQgb3IgbW9kdWxlIGlzIGNvbmZpZ3VyZWQgdG8gZG8gc28uXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBVcGRhdGVzIHRoZSBTd2VldEFsZXJ0IG9wdGlvbnMsIGFuZCBpZiB0aGUgbW9kYWwgaXMgb3BlbmVkLCBhc2tzIFN3ZWV0QWxlcnQgdG8gcmVuZGVyIGl0IGFnYWluLlxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogQ2xvc2VzIHRoZSBTd2VldEFsZXJ0IHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgU3dlZXRBbGVydC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIFN3ZWV0QWxlcnQyIHByb21pc2UgZm9yIGNvbnZlbmllbmNlIGFuZCB1c2UgaW4gY29kZSBiZWhpbmQgdGVtcGxhdGVzLlxuICAgICAqIE90aGVyd2lzZSwgKGNvbmZpcm0pPVwibXlIYW5kbGVyKCRldmVudClcIiBhbmQgKGNhbmNlbCk9XCJteUhhbmRsZXIoJGV2ZW50KVwiIGNhbiBiZSB1c2VkIGluIHRlbXBsYXRlcy5cbiAgICAgKi9cbiAgICBmaXJlKCk6IFByb21pc2U8U3dlZXRBbGVydFJlc3VsdD47XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBtb2RhbCwgaWYgb3BlbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3VsdCBUaGUgdmFsdWUgdGhhdCB0aGUgbW9kYWwgd2lsbCByZXNvbHZlIHdpdGgsIHRyaWdnZXJpbmcgZWl0aGVyIChjb25maXJtKSBvciAoY2FuY2VsKS5cbiAgICAgKiAgICAgICAgICAgICAgIElmIHRoZSBhcmd1bWVudCBpcyBub3QgcGFzc2VkLCAoZGltaXNzKSB3aWxsIGVtaXQgYHVuZGVmaW5lZGAuXG4gICAgICogICAgICAgICAgICAgICBTZWUge0BsaW5rIFN3YWwuY2xvc2V9XG4gICAgICovXG4gICAgZGlzbWlzcyhyZXN1bHQ/OiBTd2VldEFsZXJ0UmVzdWx0KTogUHJvbWlzZTx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIFN3ZWV0QWxlcnQyIG9wdGlvbnMgd2hpbGUgdGhlIG1vZGFsIGlzIG9wZW5lZCwgY2F1c2luZyB0aGUgbW9kYWwgdG8gcmUtcmVuZGVyLlxuICAgICAqIElmIHRoZSBtb2RhbCBpcyBub3Qgb3BlbmVkLCB0aGUgY29tcG9uZW50IG9wdGlvbnMgd2lsbCBzaW1wbHkgYmUgdXBkYXRlZCBhbmQgdGhhdCdzIGl0LlxuICAgICAqXG4gICAgICogLyFcXCBQbGVhc2Ugbm90ZSB0aGF0IG5vdCBhbGwgU3dlZXRBbGVydDIgb3B0aW9ucyBhcmUgdXBkYXRhYmxlIHdoaWxlIHRoZSBtb2RhbCBpcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIHVwZGF0ZShvcHRpb25zPzogU3dlZXRBbGVydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xufVxuIl19