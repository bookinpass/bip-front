import { EventEmitter, Injectable, NgModule, Directive, Renderer2, ElementRef, ChangeDetectorRef, HostBinding, Input, Component, Output, forwardRef, ReflectiveInjector, ApplicationRef, ComponentFactoryResolver, Injector, ViewChild, ViewContainerRef, HostListener, ContentChildren, ViewChildren, Host, ContentChild, TemplateRef } from '@angular/core';
import * as $extend from 'extend';
import $extend__default, {  } from 'extend';
import { CommonModule } from '@angular/common';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import Popper from 'popper.js';
import { format, parse } from 'date-fns';
import * as defaultLocale from 'date-fns/locale/en';
import 'element-closest';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/forms';

function FuiMessage_i_2_Template(rf, ctx) { if (rf & 1) {
    const _r310 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "i", 5);
    ɵngcc0.ɵɵlistener("click", function FuiMessage_i_2_Template_i_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r310); const ctx_r309 = ɵngcc0.ɵɵnextContext(); return ctx_r309.onDismissClicked($event); });
    ɵngcc0.ɵɵelementEnd();
} }
function FuiMessage_ng_container_4_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r311 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r311.header);
} }
function FuiMessage_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FuiMessage_ng_container_4_div_1_Template, 2, 1, "div", 6);
    ɵngcc0.ɵɵelementStart(2, "p");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r307 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r307.header);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r307.text);
} }
function FuiMessage_fui_progress_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "fui-progress", 8);
} if (rf & 2) {
    const ctx_r308 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", ctx_r308.timeoutProgress)("autoSuccess", false)("transitionDuration", ctx_r308.currentTimeout)("canCompletelyEmpty", true);
} }
const _c0 = ["*"];
const _c1 = ["containerSibling"];
function FuiProgress_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r313 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r313.percentage, "%");
} }
function FuiPagination_a_0_Template(rf, ctx) { if (rf & 1) {
    const _r322 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 3);
    ɵngcc0.ɵɵlistener("click", function FuiPagination_a_0_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r322); const ctx_r321 = ɵngcc0.ɵɵnextContext(); return ctx_r321.setPage(1); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵelement(2, "i", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r314 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("disabled", ctx_r314.page === 1);
} }
function FuiPagination_a_1_Template(rf, ctx) { if (rf & 1) {
    const _r324 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 3);
    ɵngcc0.ɵɵlistener("click", function FuiPagination_a_1_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r324); const ctx_r323 = ɵngcc0.ɵɵnextContext(); return ctx_r323.setPage(ctx_r323.page - 1); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵelement(2, "i", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r315 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("disabled", !ctx_r315.hasPrevious());
} }
function FuiPagination_ng_container_2_a_1_Template(rf, ctx) { if (rf & 1) {
    const _r328 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 3);
    ɵngcc0.ɵɵlistener("click", function FuiPagination_ng_container_2_a_1_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r328); const ctx_r327 = ɵngcc0.ɵɵnextContext(2); return ctx_r327.setPage(1); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2, "1");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function FuiPagination_ng_container_2_a_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵtext(1, "...");
    ɵngcc0.ɵɵelementEnd();
} }
function FuiPagination_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FuiPagination_ng_container_2_a_1_Template, 3, 0, "a", 6);
    ɵngcc0.ɵɵtemplate(2, FuiPagination_ng_container_2_a_2_Template, 2, 0, "a", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r316 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r316.pages[0] !== 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r316.pages[0] > 2);
} }
function FuiPagination_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r331 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 3);
    ɵngcc0.ɵɵlistener("click", function FuiPagination_a_3_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r331); const p_r329 = ctx.$implicit; const ctx_r330 = ɵngcc0.ɵɵnextContext(); return ctx_r330.setPage(p_r329); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const p_r329 = ctx.$implicit;
    const ctx_r317 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", p_r329 === ctx_r317.page);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", p_r329, "\n");
} }
function FuiPagination_ng_container_4_a_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵtext(1, "...");
    ɵngcc0.ɵɵelementEnd();
} }
function FuiPagination_ng_container_4_a_2_Template(rf, ctx) { if (rf & 1) {
    const _r335 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 3);
    ɵngcc0.ɵɵlistener("click", function FuiPagination_ng_container_4_a_2_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r335); const ctx_r334 = ɵngcc0.ɵɵnextContext(2); return ctx_r334.setPage(ctx_r334.pageCount); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r333 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r333.pageCount);
} }
function FuiPagination_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FuiPagination_ng_container_4_a_1_Template, 2, 0, "a", 7);
    ɵngcc0.ɵɵtemplate(2, FuiPagination_ng_container_4_a_2_Template, 3, 1, "a", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r318 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r318.pages[ctx_r318.pages.length - 1] < ctx_r318.pageCount - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r318.pages[ctx_r318.pages.length - 1] !== ctx_r318.pageCount);
} }
function FuiPagination_a_5_Template(rf, ctx) { if (rf & 1) {
    const _r337 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 3);
    ɵngcc0.ɵɵlistener("click", function FuiPagination_a_5_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r337); const ctx_r336 = ɵngcc0.ɵɵnextContext(); return ctx_r336.setPage(ctx_r336.page + 1); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵelement(2, "i", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r319 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("disabled", !ctx_r319.hasNext());
} }
function FuiPagination_a_6_Template(rf, ctx) { if (rf & 1) {
    const _r339 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 3);
    ɵngcc0.ɵɵlistener("click", function FuiPagination_a_6_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r339); const ctx_r338 = ɵngcc0.ɵɵnextContext(); return ctx_r338.setPage(ctx_r338.pageCount); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵelement(2, "i", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r320 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("disabled", ctx_r320.page === ctx_r320.pageCount);
} }
const _c2 = [[["", "title", ""]], [["", "content", ""]]];
const _c3 = ["[title]", "[content]"];
const _c4 = ["checkbox"];
const _c5 = ["radio"];
function FuiDatepicker_fui_calendar_year_view_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "fui-calendar-year-view", 2);
} if (rf & 2) {
    const ctx_r342 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("service", ctx_r342.service);
} }
function FuiDatepicker_fui_calendar_month_view_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "fui-calendar-month-view", 2);
} if (rf & 2) {
    const ctx_r343 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("service", ctx_r343.service);
} }
function FuiDatepicker_fui_calendar_date_view_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "fui-calendar-date-view", 2);
} if (rf & 2) {
    const ctx_r344 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("service", ctx_r344.service);
} }
function FuiDatepicker_fui_calendar_hour_view_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "fui-calendar-hour-view", 2);
} if (rf & 2) {
    const ctx_r345 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("service", ctx_r345.service);
} }
function FuiDatepicker_fui_calendar_minute_view_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "fui-calendar-minute-view", 2);
} if (rf & 2) {
    const ctx_r346 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("service", ctx_r346.service);
} }
const _c6 = ["templateSibling"];
const _c7 = ["container"];
function FuiPopup_ng_container_2_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r351 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r351.config.header);
} }
function FuiPopup_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FuiPopup_ng_container_2_div_1_Template, 2, 1, "div", 5);
    ɵngcc0.ɵɵelementStart(2, "div", 6);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r348 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r348.config.header);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r348.config.text);
} }
function FuiPopup_fui_popup_arrow_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "fui-popup-arrow", 8);
} if (rf & 2) {
    const ctx_r350 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("placement", ctx_r350.config.placement)("inverted", ctx_r350.config.isInverted);
} }
function FuiPopupArrow_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 2);
} if (rf & 2) {
    const ctx_r352 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("direction", ctx_r352.direction);
} }
function FuiPopupArrow_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 3);
} if (rf & 2) {
    const ctx_r353 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("direction", ctx_r353.direction)("alignment", ctx_r353.alignment);
} }
function FuiCalendarDateView_th_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const day_r356 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(day_r356);
} }
function FuiCalendarDateView_tr_9_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r361 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 5);
    ɵngcc0.ɵɵlistener("click", function FuiCalendarDateView_tr_9_td_1_Template_td_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r361); const item_r359 = ctx.$implicit; const ctx_r360 = ɵngcc0.ɵɵnextContext(2); return ctx_r360.setDate(item_r359); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r359 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("calendarItem", item_r359);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", item_r359.humanReadable, " ");
} }
function FuiCalendarDateView_tr_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, FuiCalendarDateView_tr_9_td_1_Template, 2, 2, "td", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const group_r357 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", group_r357);
} }
function FuiCalendarHourView_thead_1_Template(rf, ctx) { if (rf & 1) {
    const _r365 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "thead");
    ɵngcc0.ɵɵelementStart(1, "tr");
    ɵngcc0.ɵɵelementStart(2, "th", 3);
    ɵngcc0.ɵɵelementStart(3, "fui-calendar-view-title", 4);
    ɵngcc0.ɵɵlistener("zoomOut", function FuiCalendarHourView_thead_1_Template_fui_calendar_view_title_zoomOut_3_listener() { ɵngcc0.ɵɵrestoreView(_r365); const ctx_r364 = ɵngcc0.ɵɵnextContext(); return ctx_r364.zoomOut(); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r362 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ranges", ctx_r362.ranges);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r362.date, " ");
} }
function FuiCalendarHourView_tr_3_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r370 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 6);
    ɵngcc0.ɵɵlistener("click", function FuiCalendarHourView_tr_3_td_1_Template_td_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r370); const item_r368 = ctx.$implicit; const ctx_r369 = ɵngcc0.ɵɵnextContext(2); return ctx_r369.setDate(item_r368); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r368 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("calendarItem", item_r368);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", item_r368.humanReadable, " ");
} }
function FuiCalendarHourView_tr_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, FuiCalendarHourView_tr_3_td_1_Template, 2, 2, "td", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const group_r366 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", group_r366);
} }
function FuiCalendarMinuteView_tr_7_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r376 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 5);
    ɵngcc0.ɵɵlistener("click", function FuiCalendarMinuteView_tr_7_td_1_Template_td_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r376); const item_r374 = ctx.$implicit; const ctx_r375 = ɵngcc0.ɵɵnextContext(2); return ctx_r375.setDate(item_r374); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r374 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("calendarItem", item_r374);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", item_r374.humanReadable, " ");
} }
function FuiCalendarMinuteView_tr_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, FuiCalendarMinuteView_tr_7_td_1_Template, 2, 2, "td", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const group_r372 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", group_r372);
} }
function FuiCalendarMonthView_tr_7_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r382 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 5);
    ɵngcc0.ɵɵlistener("click", function FuiCalendarMonthView_tr_7_td_1_Template_td_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r382); const item_r380 = ctx.$implicit; const ctx_r381 = ɵngcc0.ɵɵnextContext(2); return ctx_r381.setDate(item_r380); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r380 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("calendarItem", item_r380);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", item_r380.humanReadable, " ");
} }
function FuiCalendarMonthView_tr_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, FuiCalendarMonthView_tr_7_td_1_Template, 2, 2, "td", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const group_r378 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", group_r378);
} }
function FuiCalendarYearView_tr_7_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r388 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 5);
    ɵngcc0.ɵɵlistener("click", function FuiCalendarYearView_tr_7_td_1_Template_td_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r388); const item_r386 = ctx.$implicit; const ctx_r387 = ɵngcc0.ɵɵnextContext(2); return ctx_r387.setDate(item_r386); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r386 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("calendarItem", item_r386);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", item_r386.humanReadable, " ");
} }
function FuiCalendarYearView_tr_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, FuiCalendarYearView_tr_7_td_1_Template, 2, 2, "td", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const group_r384 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", group_r384);
} }
const _c8 = ["modal"];
function FuiModal_i_3_Template(rf, ctx) { if (rf & 1) {
    const _r393 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "i", 5);
    ɵngcc0.ɵɵlistener("click", function FuiModal_i_3_Template_i_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r393); const ctx_r392 = ɵngcc0.ɵɵnextContext(); return ctx_r392.close(); });
    ɵngcc0.ɵɵelementEnd();
} }
const _c9 = function (a0) { return { "top aligned": a0 }; };
function FuiRating_i_0_Template(rf, ctx) { if (rf & 1) {
    const _r398 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "i", 1);
    ɵngcc0.ɵɵlistener("mouseover", function FuiRating_i_0_Template_i_mouseover_0_listener() { ɵngcc0.ɵɵrestoreView(_r398); const i_r396 = ctx.index; const ctx_r397 = ɵngcc0.ɵɵnextContext(); return ctx_r397.onMouseover(i_r396); })("click", function FuiRating_i_0_Template_i_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r398); const i_r396 = ctx.index; const ctx_r399 = ɵngcc0.ɵɵnextContext(); return ctx_r399.onClick(i_r396); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const i_r396 = ctx.index;
    const ctx_r394 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1("icon ", ctx_r394.type, "");
    ɵngcc0.ɵɵclassProp("selected", ctx_r394.hoveredIndex >= i_r396 && !ctx_r394.isReadonly)("active", ctx_r394.value > i_r396);
} }
function FuiSearchResult_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 2);
} if (rf & 2) {
    const ctx_r401 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r401.formatter(ctx_r401.value, ctx_r401.query), ɵngcc0.ɵɵsanitizeHtml);
} }
function FuiSearch_i_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "i", 6);
} }
function FuiSearch_fui_search_result_4_Template(rf, ctx) { if (rf & 1) {
    const _r407 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "fui-search-result", 7);
    ɵngcc0.ɵɵlistener("click", function FuiSearch_fui_search_result_4_Template_fui_search_result_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r407); const r_r405 = ctx.$implicit; const ctx_r406 = ɵngcc0.ɵɵnextContext(); return ctx_r406.select(r_r405); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const r_r405 = ctx.$implicit;
    const ctx_r403 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", r_r405)("query", ctx_r403.query)("formatter", ctx_r403.resultFormatter)("template", ctx_r403.resultTemplate);
} }
function FuiSearch_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵelementStart(1, "div", 9);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 10);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r404 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r404.localeValues.noResults.header);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r404.localeValues.noResults.message);
} }
function FuiMultiSelectLabel_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 3);
} if (rf & 2) {
    const ctx_r410 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r410.formatter(ctx_r410.value), ɵngcc0.ɵɵsanitizeHtml);
} }
function FuiMultiSelect_ng_container_1_fui_multi_select_label_1_Template(rf, ctx) { if (rf & 1) {
    const _r419 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "fui-multi-select-label", 8);
    ɵngcc0.ɵɵlistener("deselected", function FuiMultiSelect_ng_container_1_fui_multi_select_label_1_Template_fui_multi_select_label_deselected_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r419); const ctx_r418 = ɵngcc0.ɵɵnextContext(2); return ctx_r418.deselectOption($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const selected_r417 = ctx.$implicit;
    const ctx_r416 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", selected_r417)("query", ctx_r416.query)("formatter", ctx_r416.configuredFormatter)("template", ctx_r416.optionTemplate);
} }
function FuiMultiSelect_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FuiMultiSelect_ng_container_1_fui_multi_select_label_1_Template, 1, 4, "fui-multi-select-label", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r411 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r411.selectedOptions);
} }
function FuiMultiSelect_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r412 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r412.placeholder);
} }
function FuiMultiSelect_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r414 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r414.selectedMessage, "");
} }
function FuiMultiSelect_ng_container_9_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r420 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r420.localeValues.noResultsMessage);
} }
function FuiMultiSelect_ng_container_9_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r421 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r421.maxSelectedMessage);
} }
function FuiMultiSelect_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FuiMultiSelect_ng_container_9_div_1_Template, 2, 1, "div", 9);
    ɵngcc0.ɵɵtemplate(2, FuiMultiSelect_ng_container_9_div_2_Template, 2, 1, "div", 9);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r415 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r415.maxSelectedReached);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r415.maxSelectedReached);
} }
const _c10 = ["optionTemplateSibling"];
function FuiSelect_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r422 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("filtered", ctx_r422.query);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r422.placeholder);
} }
function FuiSelect_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} if (rf & 2) {
    const ctx_r424 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r424.configuredFormatter(ctx_r424.selectedOption), ɵngcc0.ɵɵsanitizeHtml);
} }
function FuiSelect_i_6_Template(rf, ctx) { if (rf & 1) {
    const _r429 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "i", 11);
    ɵngcc0.ɵɵlistener("click", function FuiSelect_i_6_Template_i_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r429); const ctx_r428 = ɵngcc0.ɵɵnextContext(); return ctx_r428.onRemoveClick($event); });
    ɵngcc0.ɵɵelementEnd();
} }
function FuiSelect_i_7_Template(rf, ctx) { if (rf & 1) {
    const _r431 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "i", 12);
    ɵngcc0.ɵɵlistener("click", function FuiSelect_i_7_Template_i_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r431); const ctx_r430 = ɵngcc0.ɵɵnextContext(); return ctx_r430.onCaretClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r426 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1("", ctx_r426.icon, " icon");
} }
function FuiSelect_div_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r427 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r427.localeValues.noResultsMessage, " ");
} }
const _c11 = function (a0, a1) { return { "transition": a0, "width": a1 }; };
function FuiToast_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelement(1, "div", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r432 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate2("ui attached active progress ", ctx_r432.class, " ", ctx_r432.showProgress, "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction2(5, _c11, "width " + ctx_r432.displayTime / 1000 + "s", ctx_r432.progress + "%"));
} }
function FuiToast_i_3_Template(rf, ctx) { if (rf & 1) {
    const _r441 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "i", 9);
    ɵngcc0.ɵɵlistener("click", function FuiToast_i_3_Template_i_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r441); const ctx_r440 = ɵngcc0.ɵɵnextContext(); return ctx_r440.close(); });
    ɵngcc0.ɵɵelementEnd();
} }
function FuiToast_i_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "i");
} if (rf & 2) {
    const ctx_r434 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1("", ctx_r434.showIcon, " icon");
} }
function FuiToast_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 10);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r435 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r435.title);
} }
function FuiToast_div_7_ng_template_1_Template(rf, ctx) { }
function FuiToast_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtemplate(1, FuiToast_div_7_ng_template_1_Template, 0, 0, "ng-template", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r436 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r436.titleTpl.templateRef);
} }
function FuiToast_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 12);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r437 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r437.message);
} }
function FuiToast_div_9_ng_template_1_Template(rf, ctx) { }
function FuiToast_div_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtemplate(1, FuiToast_div_9_ng_template_1_Template, 0, 0, "ng-template", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r438 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r438.messageTpl.templateRef);
} }
function FuiToast_div_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelement(1, "div", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r439 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate2("ui attached active progress ", ctx_r439.class, " ", ctx_r439.showProgress, "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction2(5, _c11, "width " + ctx_r439.displayTime / 1000 + "s", ctx_r439.progress + "%"));
} }
const _c12 = function (a0) { return { "icon": a0 }; };
function FuiToastContainer_fui_toast_0_Template(rf, ctx) { if (rf & 1) {
    const _r447 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "fui-toast", 1);
    ɵngcc0.ɵɵlistener("close", function FuiToastContainer_fui_toast_0_Template_fui_toast_close_0_listener() { ɵngcc0.ɵɵrestoreView(_r447); const toast_r445 = ctx.$implicit; const ctx_r446 = ɵngcc0.ɵɵnextContext(); return ctx_r446.closeToast(toast_r445.id); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const toast_r445 = ctx.$implicit;
    ɵngcc0.ɵɵclassMap(toast_r445.class);
    ɵngcc0.ɵɵproperty("id", toast_r445.id)("title", toast_r445.title)("message", toast_r445.message)("showProgress", toast_r445.showProgress)("displayTime", toast_r445.displayTime)("showIcon", toast_r445.showIcon)("closeIcon", toast_r445.closeIcon)("progressUp", toast_r445.progressUp)("className", toast_r445.className);
} }
const enGB = {
    datepicker: {
        months: [
            'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
        ],
        monthsShort: [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
        ],
        weekdays: [
            'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
        ],
        weekdaysShort: [
            'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
        ],
        weekdaysNarrow: [
            'S', 'M', 'T', 'W', 'T', 'F', 'S'
        ],
        timesOfDay: [
            'a.m.', 'p.m.'
        ],
        timesOfDayUppercase: [
            'AM', 'PM'
        ],
        timesOfDayLowercase: [
            'am', 'pm'
        ],
        formats: {
            time: 'h:mm A',
            datetime: 'D MMMM YYYY h:mm A',
            date: 'D MMMM YYYY',
            month: 'MMMM YYYY',
            year: 'YYYY'
        },
        firstDayOfWeek: 1
    },
    search: {
        placeholder: 'Search...',
        noResults: {
            header: 'No Results',
            message: 'Your search returned no results.'
        }
    },
    select: {
        noResultsMessage: 'No results',
        single: {
            placeholder: 'Select one'
        },
        multi: {
            placeholder: 'Select...',
            maxSelectedMessage: 'Max #{max} selections',
            selectedMessage: '#{count} selections'
        }
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} obj
 * @return {?}
 */
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 * @template T, U
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
function deepExtend(target, source) {
    // Rollup...
    /** @type {?} */
    const extend = $extend__default || $extend;
    return extend(true, target, source);
}
/**
 * @param {?} language
 * @return {?}
 */
function lang(language) {
    return language.toLowerCase().replace('-', '');
}
class FuiLocalizationService {
    constructor() {
        this.onLanguageUpdate = new EventEmitter();
        this._fallbackValues = enGB;
        this._values = {};
        this._language = 'en-GB';
        this.load('en-GB', enGB);
    }
    /**
     * @return {?}
     */
    get language() {
        return this._language;
    }
    /**
     * @param {?} language
     * @return {?}
     */
    setLanguage(language) {
        if (lang(this._language) !== lang(language)) {
            this._language = language;
            this.onLanguageUpdate.emit();
        }
    }
    /**
     * @param {?=} language
     * @return {?}
     */
    get(language = this.language) {
        /** @type {?} */
        const values = deepClone(this._fallbackValues);
        if (!this._values[lang(language)]) {
            throw new Error(`Locale ${language} is not loaded`);
        }
        deepExtend(values, this._values[lang(language)]);
        return deepClone(values);
    }
    /**
     * @template T
     * @param {?} values
     * @param {?} overrides
     * @return {?}
     */
    override(values, overrides) {
        return deepExtend(deepClone(values), overrides);
    }
    /**
     * @param {?} language
     * @param {?} values
     * @return {?}
     */
    load(language, values) {
        this._values[lang(language)] = deepClone(values);
        this.onLanguageUpdate.emit();
    }
    /**
     * @param {?} language
     * @param {?} values
     * @return {?}
     */
    patch(language, values) {
        deepExtend(this._values[lang(language)], values);
    }
    /**
     * @param {?} value
     * @param {?} variables
     * @return {?}
     */
    interpolate(value, variables) {
        return variables.reduce((/**
         * @param {?} s
         * @param {?} __1
         * @return {?}
         */
        (s, [k, v]) => s.replace(new RegExp(`#{${k}}`, 'g'), v)), value);
    }
}
FuiLocalizationService.ɵfac = function FuiLocalizationService_Factory(t) { return new (t || FuiLocalizationService)(); };
FuiLocalizationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FuiLocalizationService, factory: FuiLocalizationService.ɵfac });
/** @nocollapse */
FuiLocalizationService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiLocalizationService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiLocalizationModule {
}
FuiLocalizationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiLocalizationModule });
FuiLocalizationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiLocalizationModule_Factory(t) { return new (t || FuiLocalizationModule)(); }, providers: [FuiLocalizationService], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiLocalizationModule, { imports: function () { return [CommonModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiLocalizationModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                providers: [FuiLocalizationService]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FuiActiveMessage {
}
class ActiveMessage {
    /**
     * @param {?} config
     * @param {?} componentRef
     */
    constructor(config, componentRef) {
        this.config = config;
        this.componentRef = componentRef;
        this.component.onDismiss.subscribe((/**
         * @return {?}
         */
        () => this.componentRef.destroy()));
    }
    /**
     * @return {?}
     */
    get component() {
        return this.componentRef.instance;
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    onClick(callback) {
        this.config.onClick.subscribe((/**
         * @return {?}
         */
        () => callback()));
        return this;
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    onDismiss(callback) {
        this.config.onDismiss.subscribe((/**
         * @return {?}
         */
        () => callback()));
        return this;
    }
    /**
     * @return {?}
     */
    dismiss() {
        this.component.dismiss();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MessageState = {
    Default: (/** @type {?} */ ('')),
    Info: (/** @type {?} */ ('info')),
    Success: (/** @type {?} */ ('success')),
    Warning: (/** @type {?} */ ('warning')),
    Error: (/** @type {?} */ ('error'))
};
class MessageConfig {
    /**
     * @param {?} text
     * @param {?=} state
     * @param {?=} header
     */
    constructor(text, state = MessageState.Default, header) {
        this.text = text;
        this.state = state;
        this.header = header;
        this.timeout = 5000;
        this.extendedTimeout = 1000;
        this.hasDismissButton = true;
        this.hasProgress = false;
        this.transition = 'fade';
        this.transitionInDuration = 400;
        this.transitionOutDuration = 1000;
        this.onClick = new EventEmitter();
        this.onDismiss = new EventEmitter();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MessageController {
    constructor() {
        this.maxShown = 7;
        this.isNewestOnTop = true;
    }
    /**
     * @param {?} container
     * @return {?}
     */
    registerContainer(container) {
        this._container = container;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    show(config) {
        this.throwContainerError();
        return this._container.show(config, this.maxShown, this.isNewestOnTop);
    }
    /**
     * @return {?}
     */
    dismissAll() {
        this.throwContainerError();
        return this._container.dismissAll();
    }
    /**
     * @private
     * @return {?}
     */
    throwContainerError() {
        if (!this._container) {
            throw new Error('You must pass this controller to a message container.');
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const TransitionDirection = {
    In: 0,
    Out: 1,
    Either: 2,
    Static: 3,
};
TransitionDirection[TransitionDirection.In] = 'In';
TransitionDirection[TransitionDirection.Out] = 'Out';
TransitionDirection[TransitionDirection.Either] = 'Either';
TransitionDirection[TransitionDirection.Static] = 'Static';
class Transition {
    /**
     * @param {?} name
     * @param {?=} duration
     * @param {?=} direction
     * @param {?=} onComplete
     */
    constructor(name, duration = 250, direction = TransitionDirection.Either, onComplete = (/**
     * @return {?}
     */
    () => {
    })) {
        this.type = name;
        // We set a minimum duration of 1ms, to give the appearance of an immediate transition
        // whilst allowing positioning calculations to happen without a visible flicker.
        this.duration = Math.max(duration, 1);
        this.direction = direction;
        this.classes = this.type.split(' ');
        this.onComplete = onComplete;
    }
    // Converts TransitionDirection to class name.
    /**
     * @return {?}
     */
    get directionClass() {
        switch (this.direction) {
            case TransitionDirection.In:
                return 'in';
            case TransitionDirection.Out:
                return 'out';
        }
        return '';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TransitionController {
    /**
     * @param {?=} isInitiallyVisible
     * @param {?=} display
     */
    constructor(isInitiallyVisible = true, display = 'block') {
        // isInitiallyVisible sets whether the element starts out visible.
        this._isVisible = isInitiallyVisible;
        this._isHidden = !this._isVisible;
        this._display = display;
        this._queue = [];
        this._isAnimating = false;
    }
    /**
     * @return {?}
     */
    get isAnimating() {
        return this._isAnimating;
    }
    /**
     * @return {?}
     */
    get isVisible() {
        return this._isVisible;
    }
    /**
     * @return {?}
     */
    get isHidden() {
        return this._isHidden;
    }
    // Used to delay animations until we have an element to animate.
    /**
     * @private
     * @return {?}
     */
    get _isReady() {
        return this._renderer != undefined && this._element != undefined && this._changeDetector != undefined;
    }
    // Gets the first transition in the queue.
    /**
     * @private
     * @return {?}
     */
    get _queueFirst() {
        return this._queue[0];
    }
    // Gets the last transition in the queue.
    /**
     * @private
     * @return {?}
     */
    get _queueLast() {
        return this._queue[this._queue.length - 1];
    }
    // Sets the renderer to be used for animating.
    /**
     * @param {?} renderer
     * @return {?}
     */
    registerRenderer(renderer) {
        this._renderer = renderer;
        this.performTransition();
    }
    // Sets the element to perform the animations on.
    /**
     * @param {?} element
     * @return {?}
     */
    registerElement(element) {
        this._element = element;
        this.performTransition();
    }
    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.
    /**
     * @param {?} changeDetector
     * @return {?}
     */
    registerChangeDetector(changeDetector) {
        this._changeDetector = changeDetector;
        this.performTransition();
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    animate(transition) {
        // Test if transition is one of the list that doesn't change the visible state.
        // Should these eventually become classes?
        /** @type {?} */
        const isDirectionless = ['jiggle', 'flash', 'shake', 'pulse', 'tada', 'bounce'].indexOf(transition.type) !== -1;
        if (isDirectionless) {
            transition.direction = TransitionDirection.Static;
        }
        else if (transition.direction == undefined || transition.direction === TransitionDirection.Either) {
            // Set the direction to the opposite of the current visible state automatically if not set, or set to either direction.
            transition.direction = this._isVisible ? TransitionDirection.Out : TransitionDirection.In;
            if (this._queueLast) {
                // If there is an transition in the queue already, set the direction to the opposite of the direction of that transition.
                if (this._queueLast.direction === TransitionDirection.In) {
                    transition.direction = TransitionDirection.Out;
                }
                else if (this._queueLast.direction === TransitionDirection.Out) {
                    transition.direction = TransitionDirection.In;
                }
            }
        }
        // Store the transition in the queue before attempting to perform it.
        this._queue.push(transition);
        this.performTransition();
    }
    // Stops the current transition, leaves the rest of the queue intact.
    /**
     * @param {?=} transition
     * @return {?}
     */
    stop(transition = this._queueFirst) {
        if (!transition || !this._isAnimating) {
            return;
        }
        this.finalizeTransition(transition);
    }
    // Cancels the current transition, leaves the rest of the queue intact.
    /**
     * @param {?=} transition
     * @return {?}
     */
    cancel(transition = this._queueFirst) {
        if (!transition || !this._isAnimating) {
            return;
        }
        this.completeTransition(transition);
        if (transition.direction === TransitionDirection.In) {
            // Return hidden class if we were originally transitioning in.
            this._isHidden = true;
        }
    }
    // Stops the current transition, and empties the queue.
    /**
     * @return {?}
     */
    stopAll() {
        this.clearQueue();
        this.stop();
    }
    /**
     * @return {?}
     */
    cancelAll() {
        this.clearQueue();
        this.cancel();
    }
    // Empties the transition queue but carries on with the current transition.
    /**
     * @return {?}
     */
    clearQueue() {
        if (this.isAnimating) {
            this._queue = [this._queueFirst];
            return;
        }
        this._queue = [];
    }
    /**
     * @private
     * @return {?}
     */
    performTransition() {
        if (!this._isReady || this._isAnimating || !this._queueFirst) {
            // Don't transition until we are ready, or if we are animating, or if there aren't any transitions in the queue.
            return;
        }
        this._isAnimating = true;
        /** @type {?} */
        const transition = this._queueFirst;
        // Set the Fomantic UI classes for transitioning.
        transition.classes.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this._renderer.addClass(this._element, c)));
        this._renderer.addClass(this._element, `animating`);
        this._renderer.addClass(this._element, transition.directionClass);
        // Set the Fomantic UI styles for transitioning.
        this._renderer.setStyle(this._element, `animationDuration`, `${transition.duration}ms`);
        this._renderer.setStyle(this._element, `display`, this._display);
        if (transition.direction === TransitionDirection.In) {
            // Unset hidden if we are transitioning in.
            this._isHidden = false;
        }
        // Wait the length of the animation before calling the complete callback.
        this._animationTimeout = window.setTimeout((/**
         * @return {?}
         */
        () => this.finalizeTransition(transition)), transition.duration);
    }
    /**
     * @private
     * @param {?} transition
     * @return {?}
     */
    completeTransition(transition) {
        transition.classes.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this._renderer.removeClass(this._element, c)));
        this._renderer.removeClass(this._element, `animating`);
        this._renderer.removeClass(this._element, transition.directionClass);
        this._renderer.removeStyle(this._element, `animationDuration`);
        this._renderer.removeStyle(this._element, `display`);
        // Delete the transition from the queue.
        this._queue.shift();
        this._isAnimating = false;
        this._changeDetector.markForCheck();
        clearTimeout(this._animationTimeout);
    }
    // Called when a transition has completed.
    /**
     * @private
     * @param {?} transition
     * @return {?}
     */
    finalizeTransition(transition) {
        this.completeTransition(transition);
        if (transition.direction === TransitionDirection.In) {
            // If we have just animated in, we are now visible.
            this._isVisible = true;
        }
        else if (transition.direction === TransitionDirection.Out) {
            // If we have transitioned out, we should be invisible and hidden.
            this._isVisible = false;
            this._isHidden = true;
        }
        if (transition.onComplete) {
            // Call the user-defined transition callback.
            transition.onComplete();
        }
        // Immediately attempt to perform another transition.
        this.performTransition();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTransition {
    /**
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} _changeDetector
     */
    constructor(_renderer, _element, _changeDetector) {
        this._renderer = _renderer;
        this._element = _element;
        this._changeDetector = _changeDetector;
        this.transitionClass = true;
    }
    /**
     * @param {?} tC
     * @return {?}
     */
    set fuiTransition(tC) {
        // Set the transition controller (e.g. '<div [fuiTransition]="transitionController"></div>').
        this.setTransitionController(tC);
    }
    /**
     * @return {?}
     */
    get isVisible() {
        if (this._controller) {
            return this._controller.isVisible;
        }
        return false;
    }
    /**
     * @return {?}
     */
    get isHidden() {
        if (this._controller) {
            return this._controller.isHidden;
        }
        return false;
    }
    // Initialises the controller with the injected renderer and elementRef.
    /**
     * @param {?} transitionController
     * @return {?}
     */
    setTransitionController(transitionController) {
        this._controller = transitionController;
        this._controller.registerRenderer(this._renderer);
        this._controller.registerElement(this._element.nativeElement);
        this._controller.registerChangeDetector(this._changeDetector);
    }
}
FuiTransition.ɵfac = function FuiTransition_Factory(t) { return new (t || FuiTransition)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
FuiTransition.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiTransition, selectors: [["", "fuiTransition", ""]], hostVars: 6, hostBindings: function FuiTransition_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("transition", ctx.transitionClass)("visible", ctx.isVisible)("hidden", ctx.isHidden);
    } }, inputs: { fuiTransition: "fuiTransition" }, exportAs: ["transition"] });
/** @nocollapse */
FuiTransition.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiTransition.propDecorators = {
    transitionClass: [{ type: HostBinding, args: ['class.transition',] }],
    fuiTransition: [{ type: Input }],
    isVisible: [{ type: HostBinding, args: ['class.visible',] }],
    isHidden: [{ type: HostBinding, args: ['class.hidden',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiTransition, [{
        type: Directive,
        args: [{
                selector: '[fuiTransition]',
                exportAs: 'transition'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { transitionClass: [{
            type: HostBinding,
            args: ['class.transition']
        }], fuiTransition: [{
            type: Input
        }], isVisible: [{
            type: HostBinding,
            args: ['class.visible']
        }], isHidden: [{
            type: HostBinding,
            args: ['class.hidden']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTransitionModule {
}
FuiTransitionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiTransitionModule });
FuiTransitionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiTransitionModule_Factory(t) { return new (t || FuiTransitionModule)(); }, providers: [], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiTransitionModule, { declarations: function () { return [FuiTransition]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FuiTransition]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiTransitionModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [
                    FuiTransition
                ],
                exports: [
                    FuiTransition
                ],
                providers: []
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiMessage {
    constructor() {
        /** @type {?} */
        const config = new MessageConfig('');
        this.loadConfig(config);
        this.isDynamic = false;
        this.transitionOutDuration = 300;
        this.timeoutProgress = 100;
        this.transitionController = new TransitionController(false);
        this.show();
    }
    /**
     * @return {?}
     */
    get dynamicClasses() {
        /** @type {?} */
        const classes = {};
        classes[this.state] = true;
        if (this.isDynamic && this.hasProgress) {
            classes.attached = true;
        }
        (this.classes || '')
            .split(' ')
            .forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => classes[c] = true));
        return classes;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    loadConfig(config) {
        this.isDynamic = true;
        this.text = config.text;
        this.header = config.header;
        this.state = config.state;
        this.timeout = config.timeout;
        this.extendedTimeout = config.extendedTimeout;
        this.hasDismissButton = config.hasDismissButton;
        this.hasProgress = config.hasProgress;
        this.transition = config.transition;
        this.transitionInDuration = config.transitionInDuration;
        this.transitionOutDuration = config.transitionOutDuration;
        this.onClick = config.onClick;
        this.onDismiss = config.onDismiss;
    }
    /**
     * @return {?}
     */
    show() {
        this.transitionController.stopAll();
        this.transitionController.animate(new Transition(this.transition, this.isDynamic ? this.transitionInDuration : 0, TransitionDirection.In, (/**
         * @return {?}
         */
        () => {
            if (this.isDynamic) {
                this.beginTimer(this.timeout);
            }
        })));
    }
    /**
     * @return {?}
     */
    dismiss() {
        this.isDismissing = true;
        this.transitionOutDuration = this.transitionInDuration;
        this.hide();
    }
    /**
     * @return {?}
     */
    hide() {
        this.isClosing = true;
        this.transitionController.stopAll();
        this.transitionController.animate(new Transition(this.transition, this.transitionOutDuration, TransitionDirection.Out, (/**
         * @return {?}
         */
        () => {
            this.isClosing = false;
            this.onDismiss.emit();
        })));
    }
    /**
     * @param {?} timeout
     * @return {?}
     */
    beginTimer(timeout) {
        if (this.isDynamic && !this.isDismissing) {
            this.timeoutProgress = 0;
            this.currentTimeout = timeout;
            this._displayTimeout = window.setTimeout((/**
             * @return {?}
             */
            () => this.onTimedOut()), timeout);
        }
    }
    /**
     * @return {?}
     */
    cancelTimer() {
        if (this.isDynamic && !this.isDismissing) {
            this.timeoutProgress = 100;
            this.currentTimeout = 0;
            clearTimeout(this._displayTimeout);
            if (this.isClosing) {
                this.isClosing = false;
                this.transitionController.cancel();
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClicked(e) {
        if (!e.eventHandled) {
            this.cancelTimer();
            this.onClick.emit();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onDismissClicked(e) {
        e.eventHandled = true;
        this.dismiss();
    }
    /**
     * @private
     * @return {?}
     */
    onTimedOut() {
        this.hide();
    }
}
FuiMessage.ɵfac = function FuiMessage_Factory(t) { return new (t || FuiMessage)(); };
FuiMessage.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiMessage, selectors: [["fui-message"]], inputs: { transitionOutDuration: ["transitionDuration", "transitionOutDuration"], hasDismissButton: "hasDismissButton", transition: "transition", classes: ["class", "classes"] }, outputs: { onClick: "click", onDismiss: "dismiss" }, ngContentSelectors: _c0, decls: 6, vars: 5, consts: [[3, "fuiTransition"], [1, "ui", "message", 3, "ngClass", "mousemove", "mouseleave", "click"], ["class", "close icon", 3, "click", 4, "ngIf"], [4, "ngIf"], ["class", "bottom attached", "transition", "linear", 3, "value", "autoSuccess", "transitionDuration", "canCompletelyEmpty", 4, "ngIf"], [1, "close", "icon", 3, "click"], ["class", "header", 4, "ngIf"], [1, "header"], ["transition", "linear", 1, "bottom", "attached", 3, "value", "autoSuccess", "transitionDuration", "canCompletelyEmpty"]], template: function FuiMessage_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵlistener("mousemove", function FuiMessage_Template_div_mousemove_1_listener() { return ctx.cancelTimer(); })("mouseleave", function FuiMessage_Template_div_mouseleave_1_listener() { return ctx.beginTimer(ctx.extendedTimeout); })("click", function FuiMessage_Template_div_click_1_listener($event) { return ctx.onClicked($event); });
        ɵngcc0.ɵɵtemplate(2, FuiMessage_i_2_Template, 1, 0, "i", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵtemplate(4, FuiMessage_ng_container_4_Template, 4, 2, "ng-container", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, FuiMessage_fui_progress_5_Template, 1, 4, "fui-progress", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("fuiTransition", ctx.transitionController);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.dynamicClasses);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasDismissButton);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDynamic);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDynamic && ctx.hasProgress);
    } }, directives: function () { return [FuiTransition, ɵngcc1.NgClass, ɵngcc1.NgIf, FuiProgress]; }, encapsulation: 2 });
/** @nocollapse */
FuiMessage.ctorParameters = () => [];
FuiMessage.propDecorators = {
    hasDismissButton: [{ type: Input }],
    transition: [{ type: Input }],
    transitionOutDuration: [{ type: Input, args: ['transitionDuration',] }],
    onClick: [{ type: Output, args: ['click',] }],
    onDismiss: [{ type: Output, args: ['dismiss',] }],
    classes: [{ type: Input, args: ['class',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiMessage, [{
        type: Component,
        args: [{
                selector: 'fui-message',
                template: `
<div [fuiTransition]="transitionController">
    <div class="ui message"
         [ngClass]="dynamicClasses"
         (mousemove)="cancelTimer()"
         (mouseleave)="beginTimer(extendedTimeout)"
         (click)="onClicked($event)">
        <i class="close icon" *ngIf="hasDismissButton" (click)="onDismissClicked($event)"></i>
        <ng-content></ng-content>
        <ng-container *ngIf="isDynamic">
            <div class="header" *ngIf="header">{{ header }}</div>
            <p>{{ text }}</p>
        </ng-container>
    </div>
    <fui-progress *ngIf="isDynamic && hasProgress"
                  class="bottom attached"
                  [value]="timeoutProgress"
                  [autoSuccess]="false"
                  transition="linear"
                  [transitionDuration]="currentTimeout"
                  [canCompletelyEmpty]="true"></fui-progress>
</div>
`
            }]
    }], function () { return []; }, { transitionOutDuration: [{
            type: Input,
            args: ['transitionDuration']
        }], hasDismissButton: [{
            type: Input
        }], transition: [{
            type: Input
        }], onClick: [{
            type: Output,
            args: ['click']
        }], onDismiss: [{
            type: Output,
            args: ['dismiss']
        }], classes: [{
            type: Input,
            args: ['class']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class CustomValidator {
    /**
     * @param {?} _host
     */
    constructor(_host) {
        this._host = _host;
        this.onValidatorChange = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this._host.validate(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
}
/**
 * @param {?} type
 * @return {?}
 */
function customValidatorFactory(type) {
    return {
        provide: NG_VALIDATORS,
        useExisting: forwardRef((/**
         * @return {?}
         */
        () => type)),
        multi: true
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template U, T
 */
class CustomValueAccessor {
    /**
     * @param {?} _host
     */
    constructor(_host) {
        this._host = _host;
        this.onChange = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
        });
        this.onTouched = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._host.writeValue(value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
/**
 * @param {?} type
 * @return {?}
 */
function customValueAccessorFactory(type) {
    return {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef((/**
         * @return {?}
         */
        () => type)),
        multi: true
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const KeyCode = {
    Left: 37,
    Up: 38,
    Right: 39,
    Down: 40,
    Escape: 27,
    Enter: 13,
    Space: 32,
    Backspace: 8,
};
KeyCode[KeyCode.Left] = 'Left';
KeyCode[KeyCode.Up] = 'Up';
KeyCode[KeyCode.Right] = 'Right';
KeyCode[KeyCode.Down] = 'Down';
KeyCode[KeyCode.Escape] = 'Escape';
KeyCode[KeyCode.Enter] = 'Enter';
KeyCode[KeyCode.Space] = 'Space';
KeyCode[KeyCode.Backspace] = 'Backspace';
/** @type {?} */
const Util = {
    Array: {
        /**
         * @param {?} n
         * @param {?=} offset
         * @return {?}
         */
        range(n, offset = 0) {
            return Array(n).fill(0).map((/**
             * @param {?} z
             * @param {?} i
             * @return {?}
             */
            (z, i) => i + offset));
        },
        /**
         * @template T
         * @param {?} items
         * @param {?} groupLength
         * @return {?}
         */
        group(items, groupLength) {
            /** @type {?} */
            const mutable = items.slice(0);
            /** @type {?} */
            const groups = [];
            while (mutable.length > 0) {
                groups.push(mutable.splice(0, groupLength));
            }
            return groups;
        },
        /**
         * @template T
         * @param {?} items
         * @param {?} field
         * @return {?}
         */
        groupBy(items, field) {
            return items.reduce((/**
             * @param {?} groups
             * @param {?} i
             * @return {?}
             */
            (groups, i) => {
                /** @type {?} */
                const fieldValue = i[field].toString();
                groups[fieldValue] = groups[fieldValue] || [];
                groups[fieldValue].push(i);
                return groups;
            }), Object());
        },
        /**
         * @template T
         * @param {?} items
         * @return {?}
         */
        flatten(items) {
            return items.reduce((/**
             * @param {?} is
             * @param {?} i
             * @return {?}
             */
            (is, i) => is.concat(i)), []);
        }
    },
    String: {
        /**
         * @param {?} str
         * @param {?} length
         * @param {?} padding
         * @return {?}
         */
        padLeft(str, length, padding) {
            /** @type {?} */
            let s = str;
            while (s.length < length) {
                s = padding + s;
            }
            return s;
        }
    },
    DOM: {
        /**
         * @param {?} attributeValue
         * @return {?}
         */
        parseBooleanAttribute(attributeValue) {
            /** @type {?} */
            let value = attributeValue;
            if (typeof attributeValue === 'string') {
                value = true;
            }
            return value;
        },
        /**
         * @return {?}
         */
        getDocumentFontSize() {
            return parseFloat(window
                .getComputedStyle(document.documentElement, undefined)
                .getPropertyValue('font-size'));
        }
    },
    Object: {
        /**
         * @template T, U
         * @param {?} object
         * @param {?=} path
         * @return {?}
         */
        readValue(object, path) {
            if (!path) {
                return (/** @type {?} */ ((/** @type {?} */ (object))));
            }
            /** @type {?} */
            let recursed = (/** @type {?} */ ((/** @type {?} */ (object))));
            for (let i = 0, p = path.split('.'), len = p.length; i < len; i++) {
                recursed = ((/** @type {?} */ ((/** @type {?} */ (recursed)))))[p[i]];
            }
            return (/** @type {?} */ ((/** @type {?} */ (recursed))));
        }
    },
    Math: {
        /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        round(r, n) {
            return Math.round(r / n) * n;
        },
        /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        roundUp(r, n) {
            return Math.ceil(r / n) * n;
        },
        /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        roundDown(r, n) {
            return Math.floor(r / n) * n;
        },
        /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        mod(r, n) {
            /** @type {?} */
            const rem = r % n;
            if (rem < 0) {
                return rem + n;
            }
            return rem;
        }
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const DatePrecision = {
    Decade: 0,
    Year: 1,
    Month: 2,
    Date: 3,
    Hour: 4,
    Minute: 5,
};
DatePrecision[DatePrecision.Decade] = 'Decade';
DatePrecision[DatePrecision.Year] = 'Year';
DatePrecision[DatePrecision.Month] = 'Month';
DatePrecision[DatePrecision.Date] = 'Date';
DatePrecision[DatePrecision.Hour] = 'Hour';
DatePrecision[DatePrecision.Minute] = 'Minute';
/** @type {?} */
const DateUtil = {
    /**
     * @param {?} precision
     * @param {?} date
     * @param {?=} resetAll
     * @return {?}
     */
    startOf(precision, date, resetAll = false) {
        switch (precision) {
            case DatePrecision.Decade:
                /** @type {?} */
                const start = Math.floor(date.getFullYear() / 10) * 10 + 1;
                date.setFullYear(start);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Year:
                date.setMonth(0);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Month:
                date.setDate(1);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Date:
                date.setHours(0);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Hour:
                date.setMinutes(0);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Minute:
                date.setSeconds(0, 0);
        }
        return date;
    },
    /**
     * @param {?} precision
     * @param {?} date
     * @return {?}
     */
    endOf(precision, date) {
        switch (precision) {
            case DatePrecision.Year:
                date.setMonth(12, 0);
            // falls through
            case DatePrecision.Month:
                date.setMonth(date.getMonth() + 1, 0);
            // falls through
            case DatePrecision.Date:
                date.setHours(23, 59, 59, 999);
                break;
            case DatePrecision.Hour:
                date.setMinutes(59, 59, 999);
                break;
            case DatePrecision.Minute:
                date.setSeconds(59, 999);
                break;
        }
        return date;
    },
    /**
     * @param {?} precision
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    equal(precision, a, b) {
        /** @type {?} */
        let equal = true;
        switch (precision) {
            case DatePrecision.Minute:
                equal = equal && a.getMinutes() === b.getMinutes();
            // falls through
            case DatePrecision.Hour:
                equal = equal && a.getHours() === b.getHours();
            // falls through
            case DatePrecision.Date:
                equal = equal && a.getDate() === b.getDate();
            // falls through
            case DatePrecision.Month:
                equal = equal && a.getMonth() === b.getMonth();
            // falls through
            case DatePrecision.Year:
                equal = equal && a.getFullYear() === b.getFullYear();
        }
        return equal;
    },
    /**
     * @param {?} precision
     * @param {?} date
     * @return {?}
     */
    next(precision, date) {
        return DateUtil.add(precision, date, 1);
    },
    /**
     * @param {?} precision
     * @param {?} date
     * @param {?} i
     * @return {?}
     */
    add(precision, date, i) {
        /** @type {?} */
        const year = date.getFullYear();
        /** @type {?} */
        const month = date.getMonth();
        /** @type {?} */
        const day = date.getDate();
        switch (precision) {
            case DatePrecision.Decade:
                date.setFullYear(year + i * 10);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Year:
                date.setFullYear(year + i);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Month:
                date.setMonth(month + i);
                if (date.getMonth() !== Util.Math.mod(month + i, 12)) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Date:
                date.setDate(day + i);
                break;
            case DatePrecision.Hour:
                date.setHours(date.getHours() + i);
                break;
            case DatePrecision.Minute:
                date.setMinutes(date.getMinutes() + i);
                break;
        }
        return date;
    },
    /**
     * @param {?} precision
     * @param {?} date
     * @return {?}
     */
    previous(precision, date) {
        /** @type {?} */
        const year = date.getFullYear();
        /** @type {?} */
        const month = date.getMonth();
        /** @type {?} */
        const day = date.getDate();
        switch (precision) {
            case DatePrecision.Decade:
                date.setFullYear(year - 10);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Year:
                date.setFullYear(year - 1);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Month:
                date.setMonth(month - 1);
                if (date.getMonth() !== Util.Math.mod(month - 1, 12)) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Date:
                date.setDate(day - 1);
                break;
            case DatePrecision.Hour:
                /** @type {?} */
                const hours = date.getHours();
                date.setHours(hours - 1);
                if (date.getHours() !== Util.Math.mod(hours - 1, 24)) {
                    date.setHours(hours - 2);
                }
                break;
            case DatePrecision.Minute:
                /** @type {?} */
                const minutes = date.getMinutes();
                date.setMinutes(minutes - 1);
        }
        return date;
    },
    /**
     * @param {?} date
     * @return {?}
     */
    clone(date) {
        return new Date(date.getTime());
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiComponentFactory {
    /**
     * @param {?} _applicationRef
     * @param {?} _componentFactoryResolver
     * @param {?} _injector
     */
    constructor(_applicationRef, _componentFactoryResolver, _injector) {
        this._applicationRef = _applicationRef;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._injector = _injector;
    }
    /**
     * @template T
     * @param {?} type
     * @param {?=} providers
     * @return {?}
     */
    createComponent(type, providers = []) {
        // Resolve a factory for creating components of type `type`.
        /** @type {?} */
        const factory = this._componentFactoryResolver.resolveComponentFactory((/** @type {?} */ (type)));
        // Resolve and create an injector with the specified providers.
        /** @type {?} */
        const injector = ReflectiveInjector.resolveAndCreate(providers, this._injector);
        // Create a component using the previously resolved factory & injector.
        /** @type {?} */
        const componentRef = factory.create(injector);
        return componentRef;
    }
    /**
     * @template T, U
     * @param {?} viewContainer
     * @param {?} template
     * @param {?} context
     * @return {?}
     */
    createView(viewContainer, template, context) {
        viewContainer.createEmbeddedView(template, context);
    }
    // Inserts the component into the specified view container.
    /**
     * @template T
     * @param {?} componentRef
     * @param {?} viewContainer
     * @return {?}
     */
    attachToView(componentRef, viewContainer) {
        viewContainer.insert(componentRef.hostView, 0);
    }
    // Inserts the component in the root application node.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    attachToApplication(componentRef) {
        this._applicationRef.attachView(componentRef.hostView);
    }
    // Detaches the component from the root application node.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    detachFromApplication(componentRef) {
        this._applicationRef.detachView(componentRef.hostView);
    }
    // Moves the component to the specified DOM element.
    /**
     * @template T
     * @param {?} componentRef
     * @param {?} element
     * @return {?}
     */
    moveToElement(componentRef, element) {
        element.appendChild(componentRef.location.nativeElement);
    }
    // Moves the component to the document body.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    moveToDocumentBody(componentRef) {
        this.moveToElement(componentRef, (/** @type {?} */ (document.querySelector('body'))));
    }
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    detachFromDocument(componentRef) {
        /** @type {?} */
        const element = (/** @type {?} */ (componentRef.location.nativeElement));
        // We can't use `element.remove()` due to lack of IE11 support.
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
    }
}
FuiComponentFactory.ɵfac = function FuiComponentFactory_Factory(t) { return new (t || FuiComponentFactory)(ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
FuiComponentFactory.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FuiComponentFactory, factory: FuiComponentFactory.ɵfac });
/** @nocollapse */
FuiComponentFactory.ctorParameters = () => [
    { type: ApplicationRef },
    { type: ComponentFactoryResolver },
    { type: Injector }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiComponentFactory, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Injector }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PositioningPlacement = {
    Auto: (/** @type {?} */ ('auto')),
    TopLeft: (/** @type {?} */ ('top left')),
    Top: (/** @type {?} */ ('top')),
    TopRight: (/** @type {?} */ ('top right')),
    LeftTop: (/** @type {?} */ ('left top')),
    Left: (/** @type {?} */ ('left')),
    LeftBottom: (/** @type {?} */ ('left bottom')),
    BottomLeft: (/** @type {?} */ ('bottom left')),
    Bottom: (/** @type {?} */ ('bottom')),
    BottomRight: (/** @type {?} */ ('bottom right')),
    RightTop: (/** @type {?} */ ('right top')),
    Right: (/** @type {?} */ ('right')),
    RightBottom: (/** @type {?} */ ('right bottom'))
};
/**
 * @param {?} placement
 * @return {?}
 */
function placementToPopper(placement) {
    if (!placement || placement === PositioningPlacement.Auto) {
        return 'auto';
    }
    // All placements of the format: `direction alignment`, e.g. `top left`.
    const [direction, alignment] = placement.split(' ');
    // Direction alone covers case of just `top`, `left`, `bottom`, `right`.
    /** @type {?} */
    const chosenPlacement = [direction];
    // Add `start` / `end` to placement, depending on alignment direction.
    switch (alignment) {
        case 'top':
        case 'left':
            chosenPlacement.push('start');
            break;
        case 'bottom':
        case 'right':
            chosenPlacement.push('end');
            break;
    }
    // Join with hyphen to create Popper compatible placement.
    return (/** @type {?} */ (chosenPlacement.join('-')));
}
/**
 * @param {?} popper
 * @return {?}
 */
function popperToPlacement(popper) {
    if (!popper || popper === 'auto') {
        return 'auto';
    }
    const [direction, alignment] = popper.split('-');
    /** @type {?} */
    const chosenPlacement = [direction];
    switch (direction) {
        case 'top':
        case 'bottom':
            switch (alignment) {
                case 'start':
                    chosenPlacement.push('left');
                    break;
                case 'end':
                    chosenPlacement.push('right');
                    break;
            }
            break;
        case 'left':
        case 'right':
            switch (alignment) {
                case 'start':
                    chosenPlacement.push('top');
                    break;
                case 'end':
                    chosenPlacement.push('bottom');
                    break;
            }
            break;
    }
    return (/** @type {?} */ (chosenPlacement.join(' ')));
}
class PositioningService {
    /**
     * @param {?} anchor
     * @param {?} subject
     * @param {?} placement
     * @param {?=} arrowSelector
     */
    constructor(anchor, subject, placement, arrowSelector) {
        this.anchor = anchor;
        this.subject = subject;
        this._placement = placement;
        this._arrowSelector = arrowSelector;
        this.init();
    }
    /**
     * @return {?}
     */
    get actualPlacement() {
        if (!this._popperState) {
            return PositioningPlacement.Auto;
        }
        return popperToPlacement(this._popperState.placement);
    }
    /**
     * @return {?}
     */
    get state() {
        return this._popperState;
    }
    /**
     * @return {?}
     */
    get placement() {
        return this._placement;
    }
    /**
     * @param {?} placement
     * @return {?}
     */
    set placement(placement) {
        this._placement = placement;
        if (this._popper) {
            this._popper.options.placement = placementToPopper(placement);
        }
    }
    /**
     * @param {?} hasArrow
     * @return {?}
     */
    set hasArrow(hasArrow) {
        this._hasArrow = hasArrow;
    }
    /**
     * @return {?}
     */
    init() {
        /** @type {?} */
        const modifiers = {
            computeStyle: {
                gpuAcceleration: false
            },
            preventOverflow: {
                escapeWithReference: true,
                boundariesElement: document.body
            },
            arrow: {
                element: this._arrowSelector
            },
            offset: {
                fn: (/**
                 * @param {?} data
                 * @return {?}
                 */
                (data) => {
                    if (this._hasArrow) {
                        /** @type {?} */
                        const offsets = this.calculateOffsets();
                        data.offsets.popper.left += offsets.left;
                        data.offsets.popper.top += offsets.top;
                    }
                    return data;
                })
            }
        };
        if (!this._arrowSelector) {
            delete modifiers.arrow;
        }
        this._popper = (/** @type {?} */ (new Popper(this.anchor.nativeElement, this.subject.nativeElement, {
            placement: placementToPopper(this._placement),
            modifiers,
            onCreate: (/**
             * @param {?} initial
             * @return {?}
             */
            initial => this._popperState = initial),
            onUpdate: (/**
             * @param {?} update
             * @return {?}
             */
            update => this._popperState = update)
        })));
    }
    /**
     * @return {?}
     */
    update() {
        this._popper.update();
    }
    /**
     * @return {?}
     */
    destroy() {
        this._popper.destroy();
    }
    /**
     * @private
     * @return {?}
     */
    calculateOffsets() {
        /** @type {?} */
        let left = 0;
        /** @type {?} */
        let top = 0;
        // To support correct positioning for all popup sizes we should calculate offset using em
        /** @type {?} */
        const fontSize = parseFloat(window.getComputedStyle(this.subject.nativeElement).getPropertyValue('font-size'));
        // The Fomantic UI popup arrow width and height are 0.71428571em and the margin from the popup edge is 1em
        /** @type {?} */
        const arrowCenter = (0.71428571 / 2 + 1) * fontSize;
        if (this.anchor.nativeElement.offsetWidth <= arrowCenter * 2) {
            /** @type {?} */
            const anchorCenterWidth = this.anchor.nativeElement.offsetWidth / 2;
            if (this._placement === PositioningPlacement.TopLeft || this._placement === PositioningPlacement.BottomLeft) {
                left = anchorCenterWidth - arrowCenter;
            }
            if (this._placement === PositioningPlacement.TopRight || this._placement === PositioningPlacement.BottomRight) {
                left = arrowCenter - anchorCenterWidth;
            }
        }
        if (this.anchor.nativeElement.offsetHeight <= arrowCenter * 2) {
            /** @type {?} */
            const anchorCenterHeight = this.anchor.nativeElement.offsetHeight / 2;
            if (this._placement === PositioningPlacement.LeftTop || this._placement === PositioningPlacement.RightTop) {
                top = anchorCenterHeight - arrowCenter;
            }
            if (this._placement === PositioningPlacement.LeftBottom || this._placement === PositioningPlacement.RightBottom) {
                top = arrowCenter - anchorCenterHeight;
            }
        }
        return { top, left, width: 0, height: 0 };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiUtilityModule {
}
FuiUtilityModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiUtilityModule });
FuiUtilityModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiUtilityModule_Factory(t) { return new (t || FuiUtilityModule)(); }, providers: [
        FuiComponentFactory
    ], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiUtilityModule, { imports: function () { return [CommonModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiUtilityModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                providers: [
                    FuiComponentFactory
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiMessageContainer {
    /**
     * @param {?} _componentFactory
     * @param {?} _element
     */
    constructor(_componentFactory, _element) {
        this._componentFactory = _componentFactory;
        this._element = _element;
        this._messages = [];
        this._queue = [];
    }
    /**
     * @param {?} controller
     * @return {?}
     */
    set controller(controller) {
        controller.registerContainer(this);
    }
    /**
     * @param {?} config
     * @param {?} maxShown
     * @param {?} showNewestFirst
     * @return {?}
     */
    show(config, maxShown, showNewestFirst) {
        /** @type {?} */
        const componentRef = this._componentFactory.createComponent(FuiMessage);
        componentRef.instance.loadConfig(config);
        /** @type {?} */
        const active = new ActiveMessage(config, componentRef)
            .onDismiss((/**
         * @return {?}
         */
        () => this.onMessageClose(active, showNewestFirst)));
        if (this._messages.length < maxShown) {
            this.open(active, showNewestFirst);
        }
        else {
            this.queue(active);
        }
        return active;
    }
    /**
     * @return {?}
     */
    dismissAll() {
        this._queue = [];
        this._messages.forEach((/**
         * @param {?} m
         * @return {?}
         */
        m => m.dismiss()));
    }
    /**
     * @private
     * @param {?} message
     * @param {?} showNewestFirst
     * @return {?}
     */
    open(message, showNewestFirst) {
        this._messages.push(message);
        this._componentFactory.attachToView(message.componentRef, this.containerSibling);
        if (!showNewestFirst) {
            this._componentFactory.moveToElement(message.componentRef, this._element.nativeElement);
        }
        message.component.show();
    }
    /**
     * @private
     * @param {?} message
     * @return {?}
     */
    queue(message) {
        this._queue.push(message);
    }
    /**
     * @private
     * @param {?} message
     * @param {?} showNewestFirst
     * @return {?}
     */
    onMessageClose(message, showNewestFirst) {
        this._messages = this._messages.filter((/**
         * @param {?} m
         * @return {?}
         */
        m => m !== message));
        if (this._queue.length > 0) {
            const [queued] = this._queue.slice(0, 1);
            this.open(queued, showNewestFirst);
        }
    }
}
FuiMessageContainer.ɵfac = function FuiMessageContainer_Factory(t) { return new (t || FuiMessageContainer)(ɵngcc0.ɵɵdirectiveInject(FuiComponentFactory), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FuiMessageContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiMessageContainer, selectors: [["fui-message-container"]], viewQuery: function FuiMessageContainer_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.containerSibling = _t.first);
    } }, inputs: { controller: "controller" }, decls: 2, vars: 0, consts: [["containerSibling", ""]], template: function FuiMessageContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", null, 0);
    } }, styles: ["[_nghost-%COMP%] {\n    display: block;\n}\n[_nghost-%COMP%]     fui-message {\n    display: block;\n    margin-bottom: 1rem;\n}\n[_nghost-%COMP%]     fui-message:last-of-type {\n    margin-bottom: 0;\n}\n[_nghost-%COMP%]     fui-message {\n    cursor: pointer;\n}"] });
/** @nocollapse */
FuiMessageContainer.ctorParameters = () => [
    { type: FuiComponentFactory },
    { type: ElementRef }
];
FuiMessageContainer.propDecorators = {
    containerSibling: [{ type: ViewChild, args: ['containerSibling', { read: ViewContainerRef, static: false },] }],
    controller: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiMessageContainer, [{
        type: Component,
        args: [{
                selector: 'fui-message-container',
                template: `
<div #containerSibling></div>
`,
                styles: [`
:host {
    display: block;
}
:host >>> fui-message {
    display: block;
    margin-bottom: 1rem;
}
:host >>> fui-message:last-of-type {
    margin-bottom: 0;
}
:host >>> fui-message {
    cursor: pointer;
}
`]
            }]
    }], function () { return [{ type: FuiComponentFactory }, { type: ɵngcc0.ElementRef }]; }, { controller: [{
            type: Input
        }], containerSibling: [{
            type: ViewChild,
            args: ['containerSibling', { read: ViewContainerRef, static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MessagePosition = {
    Top: (/** @type {?} */ ('top')),
    TopLeft: (/** @type {?} */ ('top-left')),
    TopRight: (/** @type {?} */ ('top-right')),
    Bottom: (/** @type {?} */ ('bottom')),
    BottomLeft: (/** @type {?} */ ('bottom-left')),
    BottomRight: (/** @type {?} */ ('bottom-right'))
};
class FuiMessageGlobalContainer {
    /**
     * @return {?}
     */
    get dynamicClasses() {
        /** @type {?} */
        const classes = {};
        this.position
            .split('-')
            .forEach((/**
         * @param {?} p
         * @return {?}
         */
        p => classes[p] = true));
        return classes;
    }
    /**
     * @return {?}
     */
    get dynamicWidth() {
        /** @type {?} */
        const margin = Util.DOM.getDocumentFontSize();
        /** @type {?} */
        let width = this.width;
        if (this.position === MessagePosition.Top ||
            this.position === MessagePosition.Bottom ||
            window.innerWidth < width + margin * 2) {
            width = window.innerWidth - margin * 2;
        }
        return width;
    }
    /**
     * @return {?}
     */
    onDocumentResize() {
    }
}
FuiMessageGlobalContainer.ɵfac = function FuiMessageGlobalContainer_Factory(t) { return new (t || FuiMessageGlobalContainer)(); };
FuiMessageGlobalContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiMessageGlobalContainer, selectors: [["fui-message-global-container"]], hostBindings: function FuiMessageGlobalContainer_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("resize", function FuiMessageGlobalContainer_resize_HostBindingHandler() { return ctx.onDocumentResize(); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, decls: 2, vars: 4, consts: [[1, "global", "container", 3, "ngClass"], [3, "controller"]], template: function FuiMessageGlobalContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "fui-message-container", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.dynamicWidth, "px");
        ɵngcc0.ɵɵproperty("ngClass", ctx.dynamicClasses);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("controller", ctx.controller);
    } }, directives: [ɵngcc1.NgClass, FuiMessageContainer], styles: [".global.container[_ngcontent-%COMP%] {\n    display: block;\n    position: fixed;\n}\n.global.container.top[_ngcontent-%COMP%] {\n    top: 1rem;\n}\n.global.container.bottom[_ngcontent-%COMP%] {\n    bottom: 1rem;\n}\n.global.container.left[_ngcontent-%COMP%] {\n    left: 1rem;\n}\n.global.container.right[_ngcontent-%COMP%] {\n    right: 1rem;\n}\n.global.container[_ngcontent-%COMP%]:not(.left):not(.right) {\n    left: 1rem;\n}"] });
FuiMessageGlobalContainer.propDecorators = {
    onDocumentResize: [{ type: HostListener, args: ['window:resize',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiMessageGlobalContainer, [{
        type: Component,
        args: [{
                selector: 'fui-message-global-container',
                template: `
<div class="global container" [ngClass]="dynamicClasses" [style.width.px]="dynamicWidth">
    <fui-message-container [controller]="controller"></fui-message-container>
</div>
`,
                styles: [`
.global.container {
    display: block;
    position: fixed;
}
.global.container.top {
    top: 1rem;
}
.global.container.bottom {
    bottom: 1rem;
}
.global.container.left {
    left: 1rem;
}
.global.container.right {
    right: 1rem;
}
.global.container:not(.left):not(.right) {
    left: 1rem;
}
`]
            }]
    }], null, { onDocumentResize: [{
            type: HostListener,
            args: ['window:resize']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiMessageService {
    /**
     * @param {?} _componentFactory
     */
    constructor(_componentFactory) {
        this._componentFactory = _componentFactory;
        this._controller = new MessageController();
        this._containerRef = this._componentFactory.createComponent(FuiMessageGlobalContainer);
        this._container.controller = this._controller;
        this._componentFactory.attachToApplication(this._containerRef);
        this._componentFactory.moveToDocumentBody(this._containerRef);
        this.position = MessagePosition.TopRight;
        this.width = 480;
    }
    /**
     * @return {?}
     */
    get position() {
        return this._container.position;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    set position(position) {
        this._container.position = position;
    }
    /**
     * @return {?}
     */
    get width() {
        return this._container.width;
    }
    /**
     * @param {?} width
     * @return {?}
     */
    set width(width) {
        this._container.width = width;
    }
    /**
     * @return {?}
     */
    get maxShown() {
        return this._controller.maxShown;
    }
    /**
     * @param {?} max
     * @return {?}
     */
    set maxShown(max) {
        this._controller.maxShown = max;
    }
    /**
     * @return {?}
     */
    get isNewestOnTop() {
        return this._controller.isNewestOnTop;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isNewestOnTop(value) {
        this._controller.isNewestOnTop = value;
    }
    /**
     * @private
     * @return {?}
     */
    get _container() {
        return this._containerRef.instance;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    show(config) {
        return this._controller.show(config);
    }
    /**
     * @return {?}
     */
    dismissAll() {
        return this._controller.dismissAll();
    }
}
FuiMessageService.ɵfac = function FuiMessageService_Factory(t) { return new (t || FuiMessageService)(ɵngcc0.ɵɵinject(FuiComponentFactory)); };
FuiMessageService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FuiMessageService, factory: FuiMessageService.ɵfac });
/** @nocollapse */
FuiMessageService.ctorParameters = () => [
    { type: FuiComponentFactory }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiMessageService, [{
        type: Injectable
    }], function () { return [{ type: FuiComponentFactory }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiProgress {
    constructor() {
        this.value = 0;
        this.maximum = 100;
        this.precision = 0;
        this._overrideSuccess = false;
        this.autoSuccess = true;
        this.showProgress = true;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get reachedMaximum() {
        return this._overrideSuccess || ((this.value >= this.maximum) && this.autoSuccess);
    }
    /**
     * @return {?}
     */
    get percentage() {
        /** @type {?} */
        const boundedValue = Math.min(Math.max(this.value, 0), this.maximum);
        /** @type {?} */
        const percentage = (boundedValue / this.maximum) * 100;
        return percentage.toFixed(this.precision);
    }
    /**
     * @param {?} classes
     * @return {?}
     */
    set classValue(classes) {
        if (classes.includes('attached') || classes.includes('tiny')) {
            this.showProgress = false;
        }
        if (classes.includes('success')) {
            this._overrideSuccess = true;
        }
        this.transition = 'ease';
        this.transitionDuration = 350;
        this.canCompletelyEmpty = false;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        // Convert value from string to number where necessary.
        /** @type {?} */
        const converted = +value;
        if (Number.isNaN(converted)) {
            return;
        }
        this._value = converted;
    }
    /**
     * @return {?}
     */
    get maximum() {
        return this._maximum;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maximum(value) {
        // Convert value from string to number where necessary.
        /** @type {?} */
        const converted = +value;
        if (Number.isNaN(converted)) {
            return;
        }
        this._maximum = converted;
    }
    /**
     * @return {?}
     */
    get precision() {
        return this._precision;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set precision(value) {
        // Convert value from string to number where necessary.
        /** @type {?} */
        const converted = +value;
        if (Number.isNaN(converted)) {
            return;
        }
        this._precision = Math.min(Math.max(converted, 0), 20);
    }
}
FuiProgress.ɵfac = function FuiProgress_Factory(t) { return new (t || FuiProgress)(); };
FuiProgress.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiProgress, selectors: [["fui-progress"]], hostVars: 7, hostBindings: function FuiProgress_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-percent", ctx.percentage);
        ɵngcc0.ɵɵclassProp("ui", ctx.hasClasses)("progress", ctx.hasClasses)("success", ctx.reachedMaximum);
    } }, inputs: { value: "value", maximum: "maximum", precision: "precision", autoSuccess: "autoSuccess", showProgress: "showProgress", classValue: ["class", "classValue"], transition: "transition", transitionDuration: "transitionDuration", canCompletelyEmpty: "canCompletelyEmpty" }, ngContentSelectors: _c0, decls: 4, vars: 9, consts: [[1, "bar"], ["class", "progress", 4, "ngIf"], [1, "label"], [1, "progress"]], template: function FuiProgress_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, FuiProgress_div_1_Template, 2, 1, "div", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.percentage, "%")("min-width", ctx.canCompletelyEmpty ? 0 : null)("transition-timing-function", ctx.transition)("transition-duration", ctx.transitionDuration, "ms");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showProgress);
    } }, directives: [ɵngcc1.NgIf], styles: [".bar[_ngcontent-%COMP%] {\n    transition-duration: 300ms !important;\n    z-index: 1;\n}"] });
/** @nocollapse */
FuiProgress.ctorParameters = () => [];
FuiProgress.propDecorators = {
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    canCompletelyEmpty: [{ type: Input }],
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.progress',] }],
    autoSuccess: [{ type: Input }],
    showProgress: [{ type: Input }],
    reachedMaximum: [{ type: HostBinding, args: ['class.success',] }],
    percentage: [{ type: HostBinding, args: ['attr.data-percent',] }],
    classValue: [{ type: Input, args: ['class',] }],
    value: [{ type: Input }],
    maximum: [{ type: Input }],
    precision: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiProgress, [{
        type: Component,
        args: [{
                selector: 'fui-progress',
                template: `
<div class="bar"
    [style.width.%]="percentage"
    [style.minWidth]="canCompletelyEmpty ? 0 : null"
    [style.transitionTimingFunction]="transition"
    [style.transitionDuration.ms]="transitionDuration">
    <div class="progress" *ngIf="showProgress">{{ percentage }}%</div>
</div>
<div class="label">
    <ng-content></ng-content>
</div>
`,
                styles: [`
.bar {
    transition-duration: 300ms !important;
    z-index: 1;
}
`]
            }]
    }], function () { return []; }, { value: [{
            type: Input
        }], maximum: [{
            type: Input
        }], precision: [{
            type: Input
        }], autoSuccess: [{
            type: Input
        }], showProgress: [{
            type: Input
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.progress']
        }], reachedMaximum: [{
            type: HostBinding,
            args: ['class.success']
        }], percentage: [{
            type: HostBinding,
            args: ['attr.data-percent']
        }], classValue: [{
            type: Input,
            args: ['class']
        }], transition: [{
            type: Input
        }], transitionDuration: [{
            type: Input
        }], canCompletelyEmpty: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiProgressModule {
}
FuiProgressModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiProgressModule });
FuiProgressModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiProgressModule_Factory(t) { return new (t || FuiProgressModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiProgressModule, { declarations: function () { return [FuiProgress]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FuiProgress]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiProgressModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiProgress
                ],
                exports: [
                    FuiProgress
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiMessageModule {
}
FuiMessageModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiMessageModule });
FuiMessageModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiMessageModule_Factory(t) { return new (t || FuiMessageModule)(); }, providers: [
        FuiMessageService
    ], imports: [[
            CommonModule,
            FuiTransitionModule,
            FuiProgressModule,
            FuiUtilityModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiMessageModule, { declarations: function () { return [FuiMessage,
        FuiMessageContainer,
        FuiMessageGlobalContainer]; }, imports: function () { return [CommonModule,
        FuiTransitionModule,
        FuiProgressModule,
        FuiUtilityModule]; }, exports: function () { return [FuiMessage,
        FuiMessageContainer]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiMessageModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FuiTransitionModule,
                    FuiProgressModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiMessage,
                    FuiMessageContainer,
                    FuiMessageGlobalContainer
                ],
                exports: [
                    FuiMessage,
                    FuiMessageContainer
                ],
                providers: [
                    FuiMessageService
                ],
                entryComponents: [
                    FuiMessage,
                    FuiMessageGlobalContainer
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPagination {
    constructor() {
        this.hasClasses = true;
        this.pageChange = new EventEmitter();
        this.pageSize = 10;
        this._page = 1;
        this._pages = [];
        this.pageCount = 1;
        this.hasNavigationLinks = true;
        this.hasBoundaryLinks = false;
        this.canRotate = false;
        this.hasEllipses = true;
    }
    /**
     * @return {?}
     */
    get maxSize() {
        return this._maxSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxSize(value) {
        this._maxSize = (value != undefined) ? Math.max(value, 1) : undefined;
    }
    /**
     * @return {?}
     */
    get collectionSize() {
        return this._collectionSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set collectionSize(value) {
        this._collectionSize = Math.max(value, 0);
        this.pageCount = Math.max(1, Math.ceil(this._collectionSize / this.pageSize));
    }
    /**
     * @return {?}
     */
    get page() {
        return this._page;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        this.setPage(value);
    }
    /**
     * @return {?}
     */
    get pages() {
        return this._pages;
    }
    /**
     * @return {?}
     */
    get hasNavigationLinks() {
        /** @type {?} */
        const maxSize = this._maxSize || this.pageCount;
        return this._hasNavigationLinks || maxSize < this.pageCount;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set hasNavigationLinks(value) {
        this._hasNavigationLinks = value;
    }
    // Public methods
    /**
     * @return {?}
     */
    hasPrevious() {
        return this.page > 1;
    }
    /**
     * @return {?}
     */
    hasNext() {
        return this.page < this.pageCount;
    }
    /**
     * @param {?} newPage
     * @return {?}
     */
    setPage(newPage) {
        /** @type {?} */
        const value = (Number.isInteger(newPage)) ? Math.min(Math.max(newPage, 1), this.pageCount) : 1;
        if (value !== this._page) {
            this._page = value;
            this.pageChange.emit(this._page);
        }
    }
    // Lifecycle hooks
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.updatePages();
    }
    // Private methods
    /**
     * @private
     * @return {?}
     */
    updatePages() {
        this.pageCount = Math.max(1, Math.ceil(this._collectionSize / this.pageSize));
        const [start, end] = this.applyPagination();
        this._pages = Array(end - start)
            .fill(start + 1)
            .map((/**
         * @param {?} s
         * @param {?} i
         * @return {?}
         */
        (s, i) => s + i));
    }
    /**
     * @private
     * @return {?}
     */
    applyPagination() {
        /** @type {?} */
        const maxSize = (this.maxSize != undefined) ? Math.min(this.maxSize, this.pageCount) : this.pageCount;
        /** @type {?} */
        const page = Math.ceil(this.page / maxSize) - 1;
        /** @type {?} */
        let start = 0;
        /** @type {?} */
        let end = this.pageCount;
        if (this.canRotate) {
            /** @type {?} */
            const leftOffset = Math.floor(maxSize / 2);
            /** @type {?} */
            const rightOffset = maxSize % 2 === 0 ? leftOffset - 1 : leftOffset;
            if (this.page <= leftOffset) {
                end = maxSize;
            }
            else if (this.pageCount - this.page < leftOffset) {
                start = this.pageCount - maxSize;
            }
            else {
                start = this.page - leftOffset - 1;
                end = this.page + rightOffset;
            }
        }
        else {
            start = page * maxSize;
            end = start + maxSize;
        }
        return [start, Math.min(end, this.pageCount)];
    }
}
FuiPagination.ɵfac = function FuiPagination_Factory(t) { return new (t || FuiPagination)(); };
FuiPagination.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiPagination, selectors: [["fui-pagination"]], hostVars: 6, hostBindings: function FuiPagination_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ui", ctx.hasClasses)("pagination", ctx.hasClasses)("menu", ctx.hasClasses);
    } }, inputs: { pageSize: "pageSize", hasNavigationLinks: "hasNavigationLinks", hasBoundaryLinks: "hasBoundaryLinks", canRotate: "canRotate", hasEllipses: "hasEllipses", maxSize: "maxSize", collectionSize: "collectionSize", page: "page" }, outputs: { pageChange: "pageChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 7, consts: [["class", "item", 3, "disabled", "click", 4, "ngIf"], [4, "ngIf"], ["class", "item", 3, "active", "click", 4, "ngFor", "ngForOf"], [1, "item", 3, "click"], [1, "angle", "double", "left", "icon"], [1, "angle", "left", "icon"], ["class", "item", 3, "click", 4, "ngIf"], ["class", "disabled item", 4, "ngIf"], [1, "disabled", "item"], [1, "angle", "right", "icon"], [1, "angle", "double", "right", "icon"]], template: function FuiPagination_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FuiPagination_a_0_Template, 3, 2, "a", 0);
        ɵngcc0.ɵɵtemplate(1, FuiPagination_a_1_Template, 3, 2, "a", 0);
        ɵngcc0.ɵɵtemplate(2, FuiPagination_ng_container_2_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(3, FuiPagination_a_3_Template, 2, 3, "a", 2);
        ɵngcc0.ɵɵtemplate(4, FuiPagination_ng_container_4_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(5, FuiPagination_a_5_Template, 3, 2, "a", 0);
        ɵngcc0.ɵɵtemplate(6, FuiPagination_a_6_Template, 3, 2, "a", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasBoundaryLinks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasNavigationLinks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasEllipses);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.pages);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasEllipses);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasNavigationLinks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasBoundaryLinks);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf], styles: ["[_nghost-%COMP%]   .item[_ngcontent-%COMP%] {\n    transition: none;\n}"] });
/** @nocollapse */
FuiPagination.ctorParameters = () => [];
FuiPagination.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.pagination',] }, { type: HostBinding, args: ['class.menu',] }],
    pageChange: [{ type: Output }],
    pageSize: [{ type: Input }],
    hasBoundaryLinks: [{ type: Input }],
    canRotate: [{ type: Input }],
    hasEllipses: [{ type: Input }],
    maxSize: [{ type: Input }],
    collectionSize: [{ type: Input }],
    page: [{ type: Input }],
    hasNavigationLinks: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiPagination, [{
        type: Component,
        args: [{
                selector: 'fui-pagination',
                template: `
<a *ngIf="hasBoundaryLinks" class="item"  (click)="setPage(1)" [class.disabled]="page===1">
    <span><i class="angle double left icon"></i></span>
</a>
<a *ngIf="hasNavigationLinks" class="item" (click)="setPage(page-1)" [class.disabled]="!hasPrevious()">
    <span><i class="angle left icon"></i></span>
</a>
<ng-container *ngIf="hasEllipses">
    <a class="item" (click)="setPage(1)" *ngIf="pages[0] !== 1">
        <span>1</span>
    </a>
    <a class="disabled item" *ngIf="pages[0] > 2">...</a>
</ng-container>
<a *ngFor="let p of pages" class="item" [class.active]="p===page" (click)="setPage(p)">
    {{ p }}
</a>
<ng-container *ngIf="hasEllipses">
    <a class="disabled item" *ngIf="pages[pages.length - 1] < pageCount - 1">...</a>
    <a class="item" (click)="setPage(pageCount)" *ngIf="pages[pages.length - 1] !== pageCount">
        <span>{{ pageCount }}</span>
    </a>
</ng-container>
<a *ngIf="hasNavigationLinks" class="item" (click)="setPage(page+1)" [class.disabled]="!hasNext()">
    <span><i class="angle right icon"></i></span>
</a>
<a *ngIf="hasBoundaryLinks" class="item"  (click)="setPage(pageCount)" [class.disabled]="page===pageCount">
    <span><i class="angle double right icon"></i></span>
</a>
`,
                styles: [`
:host .item {
    transition: none;
}
`]
            }]
    }], function () { return []; }, { hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.pagination']
        }, {
            type: HostBinding,
            args: ['class.menu']
        }], pageChange: [{
            type: Output
        }], pageSize: [{
            type: Input
        }], hasNavigationLinks: [{
            type: Input
        }], hasBoundaryLinks: [{
            type: Input
        }], canRotate: [{
            type: Input
        }], hasEllipses: [{
            type: Input
        }], maxSize: [{
            type: Input
        }], collectionSize: [{
            type: Input
        }], page: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPaginationModule {
}
FuiPaginationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiPaginationModule });
FuiPaginationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiPaginationModule_Factory(t) { return new (t || FuiPaginationModule)(); }, providers: [], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiPaginationModule, { declarations: function () { return [FuiPagination]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FuiPagination]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiPaginationModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                exports: [FuiPagination],
                declarations: [FuiPagination],
                providers: []
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiAccordionPanel {
    /**
     * @param {?} _changeDetector
     */
    constructor(_changeDetector) {
        this._changeDetector = _changeDetector;
        this.transitionController = new TransitionController(false);
        this._isOpen = false;
        this.isOpenChange = new EventEmitter(false);
    }
    /**
     * @return {?}
     */
    get transition() {
        if (this._service) {
            return this._service.transition;
        }
        return 'fade';
    }
    /**
     * @return {?}
     */
    get transitionDuration() {
        if (this._service) {
            // Return the service defined transition duration.
            return this._service.transitionDuration;
        }
        // Revert to instantaneous if the service is not yet loaded.
        return 0;
    }
    /**
     * @param {?} service
     * @return {?}
     */
    set service(service) {
        this._service = service;
        this._changeDetector.detectChanges();
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        // Convert to boolean (fixes false != undefined)
        /** @type {?} */
        const isOpen = !!value;
        if (isOpen !== this.isOpen) {
            // Only update if the value has changed.
            this._isOpen = isOpen;
            if (isOpen && this._service) {
                // If we are opening this panel, we must close the other ones.
                this._service.closeOtherPanels(this);
            }
            this.isOpenChange.emit(this.isOpen);
            // Cancel all current animations, and fade the contents. The direction is automatic.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.transition, this.transitionDuration));
        }
    }
    /**
     * @return {?}
     */
    toggle() {
        if (!this.isDisabled) {
            this.isOpen = !this.isOpen;
        }
    }
}
FuiAccordionPanel.ɵfac = function FuiAccordionPanel_Factory(t) { return new (t || FuiAccordionPanel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
FuiAccordionPanel.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiAccordionPanel, selectors: [["fui-accordion-panel"]], inputs: { isOpen: "isOpen", isDisabled: "isDisabled" }, outputs: { isOpenChange: "isOpenChange" }, exportAs: ["fuiAccordionPanel"], ngContentSelectors: _c3, decls: 5, vars: 7, consts: [[1, "title", 3, "click"], [3, "fuiCollapse", "collapseDuration"], [1, "content", 3, "fuiTransition"]], template: function FuiAccordionPanel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function FuiAccordionPanel_Template_div_click_0_listener() { return ctx.toggle(); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isOpen);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("fuiCollapse", !ctx.isOpen)("collapseDuration", ctx.transitionDuration);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isOpen);
        ɵngcc0.ɵɵproperty("fuiTransition", ctx.transitionController);
    } }, directives: function () { return [FuiCollapse,
        FuiTransition]; }, styles: [".content[_ngcontent-%COMP%] {\n    padding: .5em 0 1em;\n}\n\n\n[_nghost-%COMP%]:first-child   .title[_ngcontent-%COMP%] {\n    border-top: none;\n}"] });
/** @nocollapse */
FuiAccordionPanel.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FuiAccordionPanel.propDecorators = {
    isDisabled: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    isOpen: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiAccordionPanel, [{
        type: Component,
        args: [{
                selector: 'fui-accordion-panel',
                exportAs: 'fuiAccordionPanel',
                template: `
<!-- Title -->
<div class="title" [class.active]="isOpen" (click)="toggle()" >
    <ng-content select="[title]"></ng-content>
</div>
<!-- Content -->
<div [fuiCollapse]="!isOpen" [collapseDuration]="transitionDuration">
    <div class="content" [class.active]="isOpen" [fuiTransition]="transitionController">
        <ng-content select="[content]"></ng-content>
    </div>
</div>
`,
                styles: [`
/* Manual style as Fomantic UI relies on > selector */
.content {
    padding: .5em 0 1em;
}

/* Another > selector fix */
:host:first-child .title {
    border-top: none;
}
`]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { isOpenChange: [{
            type: Output
        }], isOpen: [{
            type: Input
        }], isDisabled: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiAccordionService {
    constructor() {
        this.closeOthers = true;
        this.transition = 'fade';
        this.transitionDuration = 350;
        this.panels = [];
    }
    /**
     * @param {?} panel
     * @return {?}
     */
    addPanel(panel) {
        panel.service = this;
        this.panels.push(panel);
    }
    /**
     * @param {?} panel
     * @return {?}
     */
    closeOtherPanels(panel) {
        if (!this.closeOthers) {
            return;
        }
        this.panels.forEach((/**
         * @param {?} p
         * @return {?}
         */
        p => {
            if (p !== panel) {
                p.isOpen = false;
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiAccordion {
    constructor() {
        // Accordion service is unique to each set of panels.
        this._service = new FuiAccordionService();
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get closeOthers() {
        return this._service.closeOthers;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set closeOthers(value) {
        this._service.closeOthers = value;
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    set transition(transition) {
        this._service.transition = transition;
    }
    /**
     * @param {?} duration
     * @return {?}
     */
    set transitionDuration(duration) {
        this._service.transitionDuration = duration;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updatePanels();
        // Reconnect panels after they have updated.
        this._panels.changes.subscribe((/**
         * @return {?}
         */
        () => this.updatePanels()));
    }
    /**
     * @return {?}
     */
    updatePanels() {
        this._panels.forEach((/**
         * @param {?} p
         * @return {?}
         */
        p => this._service.addPanel(p)));
    }
}
FuiAccordion.ɵfac = function FuiAccordion_Factory(t) { return new (t || FuiAccordion)(); };
FuiAccordion.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiAccordion, selectors: [["fui-accordion"]], contentQueries: function FuiAccordion_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiAccordionPanel, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._panels = _t);
    } }, hostVars: 4, hostBindings: function FuiAccordion_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ui", ctx.hasClasses)("accordion", ctx.hasClasses);
    } }, inputs: { closeOthers: "closeOthers", transition: "transition", transitionDuration: "transitionDuration" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FuiAccordion_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] {\n    display: block;\n}\n\n\n.styled[_nghost-%COMP%]   fui-accordion-panel[_ngcontent-%COMP%]:first-child   .title[_ngcontent-%COMP%] {\n    border-top: none\n}"] });
/** @nocollapse */
FuiAccordion.ctorParameters = () => [];
FuiAccordion.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.accordion',] }],
    _panels: [{ type: ContentChildren, args: [FuiAccordionPanel,] }],
    closeOthers: [{ type: Input }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiAccordion, [{
        type: Component,
        args: [{
                selector: 'fui-accordion',
                template: `
<ng-content></ng-content>
`,
                styles: [`
/* Fix for general styling issues */
:host {
    display: block;
}

/* Fix for styled border issue */
:host.styled fui-accordion-panel:first-child .title {
    border-top: none
}
`]
            }]
    }], function () { return []; }, { hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.accordion']
        }], closeOthers: [{
            type: Input
        }], transition: [{
            type: Input
        }], transitionDuration: [{
            type: Input
        }], _panels: [{
            type: ContentChildren,
            args: [FuiAccordionPanel]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCollapse {
    /**
     * @param {?} _element
     * @param {?} _renderer
     */
    constructor(_element, _renderer) {
        this._element = _element;
        this._renderer = _renderer;
        this._pristine = true;
        // Collapse animation duration is 350ms by default.
        this.collapseDuration = 350;
        this._isExpanded = false;
        this._isCollapsing = false;
    }
    // Set when the collapse is closed, and not animating.
    /**
     * @return {?}
     */
    get isCollapsed() {
        return !this.isExpanded && !this.isCollapsing;
    }
    /**
     * @return {?}
     */
    get fuiCollapse() {
        return this._isExpanded;
    }
    // Sets the state of the collapse, `true` is collapsed.
    /**
     * @param {?} value
     * @return {?}
     */
    set fuiCollapse(value) {
        if (value) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    // Set when the collapse is open, and not animating.
    /**
     * @return {?}
     */
    get isExpanded() {
        return this._isExpanded;
    }
    // Set when the collapse is animating.
    /**
     * @return {?}
     */
    get isCollapsing() {
        return this._isCollapsing;
    }
    /**
     * @private
     * @return {?}
     */
    get _animationDuration() {
        return this._pristine ? 0 : this.collapseDuration;
    }
    /**
     * @return {?}
     */
    hide() {
        this._isCollapsing = true;
        this._isExpanded = false;
        // Forcibly hide the overflow so that content is not visible past the boundaries of its container.
        this._renderer.setStyle(this._element.nativeElement, 'overflow', 'hidden');
        // Animate the host element from its scroll height to 0.
        this.animate(this._element.nativeElement.scrollHeight, 0, false, (/**
         * @return {?}
         */
        () => {
            this._isCollapsing = false;
        }));
    }
    /**
     * @return {?}
     */
    show() {
        this._isCollapsing = true;
        // Animate the host element from its offset height to its scroll height.
        this.animate(this._element.nativeElement.offsetHeight, this._element.nativeElement.scrollHeight, true, (/**
         * @return {?}
         */
        () => {
            // Remove the overflow override to enable user styling once again.
            this._renderer.removeStyle(this._element.nativeElement, 'overflow');
            this._isCollapsing = false;
            this._isExpanded = true;
        }));
    }
    /**
     * @private
     * @param {?} startHeight
     * @param {?} endHeight
     * @param {?=} removeOnComplete
     * @param {?=} callback
     * @return {?}
     */
    animate(startHeight, endHeight, removeOnComplete = false, callback = (/**
     * @return {?}
     */
    () => {
    })) {
        /** @type {?} */
        const heightFrames = [
            {
                offset: 0,
                height: `${startHeight}px`
            },
            {
                offset: 1,
                height: `${endHeight}px`
            }
        ];
        if (removeOnComplete) {
            heightFrames.push({
                offset: 1,
                height: `auto`
            });
        }
        // Animate the collapse using the web animations API.
        // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
        this._element.nativeElement.animate(heightFrames, {
            delay: 0,
            // Disable animation on 1st collapse / expansion.
            duration: this._animationDuration,
            iterations: 1,
            easing: 'ease',
            fill: 'both'
        });
        if (this._pristine) {
            // Remove pristine flag when first hit.
            this._pristine = false;
        }
        setTimeout((/**
         * @return {?}
         */
        () => callback()), this.collapseDuration);
    }
}
FuiCollapse.ɵfac = function FuiCollapse_Factory(t) { return new (t || FuiCollapse)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FuiCollapse.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiCollapse, selectors: [["", "fuiCollapse", ""]], hostVars: 6, hostBindings: function FuiCollapse_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("collapsed", ctx.isCollapsed)("expanded", ctx.isExpanded)("collapsing", ctx.isCollapsing);
    } }, inputs: { collapseDuration: "collapseDuration", fuiCollapse: "fuiCollapse" } });
/** @nocollapse */
FuiCollapse.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
FuiCollapse.propDecorators = {
    collapseDuration: [{ type: Input }],
    isCollapsed: [{ type: HostBinding, args: ['class.collapsed',] }],
    fuiCollapse: [{ type: Input }],
    isExpanded: [{ type: HostBinding, args: ['class.expanded',] }],
    isCollapsing: [{ type: HostBinding, args: ['class.collapsing',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCollapse, [{
        type: Directive,
        args: [{
                selector: '[fuiCollapse]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { collapseDuration: [{
            type: Input
        }], isCollapsed: [{
            type: HostBinding,
            args: ['class.collapsed']
        }], fuiCollapse: [{
            type: Input
        }], isExpanded: [{
            type: HostBinding,
            args: ['class.expanded']
        }], isCollapsing: [{
            type: HostBinding,
            args: ['class.collapsing']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCollapseModule {
}
FuiCollapseModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiCollapseModule });
FuiCollapseModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiCollapseModule_Factory(t) { return new (t || FuiCollapseModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiCollapseModule, { declarations: function () { return [FuiCollapse]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FuiCollapse]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCollapseModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiCollapse
                ],
                exports: [
                    FuiCollapse
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiAccordionModule {
}
FuiAccordionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiAccordionModule });
FuiAccordionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiAccordionModule_Factory(t) { return new (t || FuiAccordionModule)(); }, providers: [], imports: [[
            CommonModule,
            FuiCollapseModule,
            FuiTransitionModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiAccordionModule, { declarations: function () { return [FuiAccordion,
        FuiAccordionPanel]; }, imports: function () { return [CommonModule,
        FuiCollapseModule,
        FuiTransitionModule]; }, exports: function () { return [FuiAccordion,
        FuiAccordionPanel]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiAccordionModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FuiCollapseModule,
                    FuiTransitionModule
                ],
                declarations: [
                    FuiAccordion,
                    FuiAccordionPanel
                ],
                exports: [
                    FuiAccordion,
                    FuiAccordionPanel
                ],
                providers: []
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCheckbox {
    constructor() {
        this.isChecked = false;
        this.onCheckChange = new EventEmitter();
        this.onTouched = new EventEmitter();
        this.isDisabled = false;
        this.isReadonly = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get checkedAttribute() {
        return this.isChecked ? '' : undefined;
    }
    /**
     * @return {?}
     */
    get isDisabledAttribute() {
        return this.isDisabled ? 'disabled' : undefined;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseDown(e) {
        e.preventDefault();
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.isDisabled && !this.isReadonly) {
            this.toggle();
            this.focusCheckbox();
        }
    }
    /**
     * @return {?}
     */
    onFocusOut() {
        this.onTouched.emit();
    }
    /**
     * @return {?}
     */
    toggle() {
        this.isChecked = !this.isChecked;
        this.onCheckChange.emit(this.isChecked);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.isChecked = value;
    }
    /**
     * @private
     * @return {?}
     */
    focusCheckbox() {
        this._checkboxElement.nativeElement.focus();
    }
}
FuiCheckbox.ɵfac = function FuiCheckbox_Factory(t) { return new (t || FuiCheckbox)(); };
FuiCheckbox.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiCheckbox, selectors: [["fui-checkbox"]], viewQuery: function FuiCheckbox_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._checkboxElement = _t.first);
    } }, hostVars: 8, hostBindings: function FuiCheckbox_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function FuiCheckbox_mousedown_HostBindingHandler($event) { return ctx.onMouseDown($event); })("click", function FuiCheckbox_click_HostBindingHandler() { return ctx.onClick(); })("focusout", function FuiCheckbox_focusout_HostBindingHandler() { return ctx.onFocusOut(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("checked", ctx.isChecked)("read-only", ctx.isReadonly)("ui", ctx.hasClasses)("checkbox", ctx.hasClasses);
    } }, inputs: { isDisabled: "isDisabled", isReadonly: "isReadonly", name: "name" }, outputs: { onCheckChange: "checkChange", onTouched: "touched" }, exportAs: ["fuiCheckbox"], ngContentSelectors: _c0, decls: 4, vars: 4, consts: [["type", "checkbox", 1, "hidden", 3, "ngModel", "ngModelChange"], ["checkbox", ""]], template: function FuiCheckbox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("ngModelChange", function FuiCheckbox_Template_input_ngModelChange_0_listener($event) { return ctx.isChecked = $event; });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "label");
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngModel", ctx.isChecked);
        ɵngcc0.ɵɵattribute("name", ctx.name)("checked", ctx.checkedAttribute)("disabled", ctx.isDisabledAttribute);
    } }, directives: [ɵngcc2.CheckboxControlValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel], encapsulation: 2 });
/** @nocollapse */
FuiCheckbox.ctorParameters = () => [];
FuiCheckbox.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.checkbox',] }],
    name: [{ type: Input }],
    isChecked: [{ type: HostBinding, args: ['class.checked',] }],
    onCheckChange: [{ type: Output, args: ['checkChange',] }],
    onTouched: [{ type: Output, args: ['touched',] }],
    isDisabled: [{ type: Input }],
    isReadonly: [{ type: HostBinding, args: ['class.read-only',] }, { type: Input }],
    _checkboxElement: [{ type: ViewChild, args: ['checkbox', { static: false },] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCheckbox, [{
        type: Component,
        args: [{
                selector: 'fui-checkbox',
                exportAs: 'fuiCheckbox',
                template: `
<input class="hidden"
       type="checkbox"
       [attr.name]="name"
       [attr.checked]="checkedAttribute"
       [attr.disabled]="isDisabledAttribute"
       [(ngModel)]="isChecked"
       #checkbox>
<label>
    <ng-content></ng-content>
</label>
`
            }]
    }], function () { return []; }, { isChecked: [{
            type: HostBinding,
            args: ['class.checked']
        }], onCheckChange: [{
            type: Output,
            args: ['checkChange']
        }], onTouched: [{
            type: Output,
            args: ['touched']
        }], isDisabled: [{
            type: Input
        }], isReadonly: [{
            type: HostBinding,
            args: ['class.read-only']
        }, {
            type: Input
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.checkbox']
        }], onMouseDown: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], onFocusOut: [{
            type: HostListener,
            args: ['focusout']
        }], name: [{
            type: Input
        }], _checkboxElement: [{
            type: ViewChild,
            args: ['checkbox', { static: false }]
        }] }); })();
class FuiCheckboxValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiCheckboxValueAccessor.ɵfac = function FuiCheckboxValueAccessor_Factory(t) { return new (t || FuiCheckboxValueAccessor)(ɵngcc0.ɵɵdirectiveInject(FuiCheckbox)); };
FuiCheckboxValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiCheckboxValueAccessor, selectors: [["fui-checkbox"]], hostBindings: function FuiCheckboxValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("checkChange", function FuiCheckboxValueAccessor_checkChange_HostBindingHandler($event) { return ctx.onChange($event); })("touched", function FuiCheckboxValueAccessor_touched_HostBindingHandler() { return ctx.onTouched(); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([customValueAccessorFactory(FuiCheckboxValueAccessor)]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FuiCheckboxValueAccessor.ctorParameters = () => [
    { type: FuiCheckbox }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCheckboxValueAccessor, [{
        type: Directive,
        args: [{
                selector: 'fui-checkbox',
                host: {
                    '(checkChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiCheckboxValueAccessor)]
            }]
    }], function () { return [{ type: FuiCheckbox }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiRadio {
    constructor() {
        this.isChecked = false;
        this.onCurrentValueChange = new EventEmitter();
        this.onTouched = new EventEmitter();
        this.isDisabled = false;
        this.isReadonly = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get checkedAttribute() {
        return this.isChecked ? '' : undefined;
    }
    /**
     * @return {?}
     */
    get isDisabledAttribute() {
        return this.isDisabled ? 'disabled' : undefined;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseDown(e) {
        e.preventDefault();
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.isDisabled && !this.isReadonly) {
            this.currentValue = this.value;
            this.onCurrentValueChange.emit(this.currentValue);
            this.update();
            this.focusRadio();
        }
    }
    /**
     * @return {?}
     */
    onFocusOut() {
        this.onTouched.emit();
    }
    /**
     * @return {?}
     */
    update() {
        this.isChecked = this.currentValue === this.value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.currentValue = value;
        this.update();
    }
    /**
     * @private
     * @return {?}
     */
    focusRadio() {
        this._radioElement.nativeElement.focus();
    }
}
FuiRadio.ɵfac = function FuiRadio_Factory(t) { return new (t || FuiRadio)(); };
FuiRadio.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiRadio, selectors: [["fui-radio-button"]], viewQuery: function FuiRadio_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c5, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._radioElement = _t.first);
    } }, hostVars: 10, hostBindings: function FuiRadio_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function FuiRadio_mousedown_HostBindingHandler($event) { return ctx.onMouseDown($event); })("click", function FuiRadio_click_HostBindingHandler() { return ctx.onClick(); })("focusout", function FuiRadio_focusout_HostBindingHandler() { return ctx.onFocusOut(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("checked", ctx.isChecked)("read-only", ctx.isReadonly)("ui", ctx.hasClasses)("radio", ctx.hasClasses)("checkbox", ctx.hasClasses);
    } }, inputs: { isDisabled: "isDisabled", isReadonly: "isReadonly", name: "name", value: "value" }, outputs: { onCurrentValueChange: "currentValueChange", onTouched: "touched" }, ngContentSelectors: _c0, decls: 4, vars: 4, consts: [["type", "checkbox", 1, "hidden", 3, "ngModel"], ["radio", ""]], template: function FuiRadio_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("ngModel", function FuiRadio_Template_input_ngModel_0_listener() { return ctx.currentValue = ctx.value; });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "label");
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngModel", ctx.isChecked);
        ɵngcc0.ɵɵattribute("name", ctx.name)("checked", ctx.checkedAttribute)("disabled", ctx.isDisabledAttribute);
    } }, directives: [ɵngcc2.CheckboxControlValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel], encapsulation: 2 });
/** @nocollapse */
FuiRadio.ctorParameters = () => [];
FuiRadio.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.radio',] }, { type: HostBinding, args: ['class.checkbox',] }],
    name: [{ type: Input }],
    value: [{ type: Input }],
    isChecked: [{ type: HostBinding, args: ['class.checked',] }],
    onCurrentValueChange: [{ type: Output, args: ['currentValueChange',] }],
    onTouched: [{ type: Output, args: ['touched',] }],
    isDisabled: [{ type: Input }],
    isReadonly: [{ type: HostBinding, args: ['class.read-only',] }, { type: Input }],
    _radioElement: [{ type: ViewChild, args: ['radio', { static: false },] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiRadio, [{
        type: Component,
        args: [{
                selector: 'fui-radio-button',
                template: `
<input class="hidden"
       type="checkbox"
       [attr.name]="name"
       [attr.checked]="checkedAttribute"
       [attr.disabled]="isDisabledAttribute"
       [ngModel]="isChecked"
       (ngModel)="currentValue = value"
       #radio>
<label>
    <ng-content></ng-content>
</label>
`
            }]
    }], function () { return []; }, { isChecked: [{
            type: HostBinding,
            args: ['class.checked']
        }], onCurrentValueChange: [{
            type: Output,
            args: ['currentValueChange']
        }], onTouched: [{
            type: Output,
            args: ['touched']
        }], isDisabled: [{
            type: Input
        }], isReadonly: [{
            type: HostBinding,
            args: ['class.read-only']
        }, {
            type: Input
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.radio']
        }, {
            type: HostBinding,
            args: ['class.checkbox']
        }], onMouseDown: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], onFocusOut: [{
            type: HostListener,
            args: ['focusout']
        }], name: [{
            type: Input
        }], value: [{
            type: Input
        }], _radioElement: [{
            type: ViewChild,
            args: ['radio', { static: false }]
        }] }); })();
/**
 * @template T
 */
class FuiRadioValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiRadioValueAccessor.ɵfac = function FuiRadioValueAccessor_Factory(t) { return new (t || FuiRadioValueAccessor)(ɵngcc0.ɵɵdirectiveInject(FuiRadio)); };
FuiRadioValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiRadioValueAccessor, selectors: [["fui-radio-button"]], hostBindings: function FuiRadioValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("currentValueChange", function FuiRadioValueAccessor_currentValueChange_HostBindingHandler($event) { return ctx.onChange($event); })("touched", function FuiRadioValueAccessor_touched_HostBindingHandler() { return ctx.onTouched(); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([customValueAccessorFactory(FuiRadioValueAccessor)]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FuiRadioValueAccessor.ctorParameters = () => [
    { type: FuiRadio }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiRadioValueAccessor, [{
        type: Directive,
        args: [{
                selector: 'fui-radio-button',
                host: {
                    '(currentValueChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiRadioValueAccessor)]
            }]
    }], function () { return [{ type: FuiRadio }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiRadioManager {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.isNested = false;
        this._radioSubs = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateNesting();
        this._subManagers.changes.subscribe((/**
         * @return {?}
         */
        () => this.updateNesting()));
        this.updateRadios();
        this._renderedRadios.changes.subscribe((/**
         * @return {?}
         */
        () => this.updateRadios()));
    }
    /**
     * @private
     * @return {?}
     */
    updateNesting() {
        this._subManagers
            .filter((/**
         * @param {?} m
         * @return {?}
         */
        m => m !== this))
            .forEach((/**
         * @param {?} m
         * @return {?}
         */
        m => m.isNested = true));
    }
    /**
     * @private
     * @return {?}
     */
    updateRadios() {
        this._radioSubs.forEach((/**
         * @param {?} s
         * @return {?}
         */
        s => s.unsubscribe()));
        this._radioSubs = [];
        /** @type {?} */
        const groups = Util.Array.groupBy(this._renderedRadios.toArray(), 'name');
        Object
            .keys(groups)
            .map((/**
         * @param {?} k
         * @return {?}
         */
        k => groups[k]))
            .forEach((/**
         * @param {?} g
         * @return {?}
         */
        g => g
            .forEach((/**
         * @param {?} r
         * @return {?}
         */
        r => this._radioSubs
            .push(r.onCurrentValueChange
            .subscribe((/**
         * @param {?} v
         * @return {?}
         */
        (v) => {
            if (!this.isNested) {
                g.forEach((/**
                 * @param {?} radio
                 * @return {?}
                 */
                radio => radio.writeValue(v)));
            }
        })))))));
    }
}
FuiRadioManager.ɵfac = function FuiRadioManager_Factory(t) { return new (t || FuiRadioManager)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FuiRadioManager.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiRadioManager, selectors: [["form", 3, "ngForm", "", 3, "ngForm", ""], ["ngForm"], ["", "ngForm", ""]], contentQueries: function FuiRadioManager_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiRadioManager, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiRadio, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._subManagers = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._renderedRadios = _t);
    } } });
/** @nocollapse */
FuiRadioManager.ctorParameters = () => [
    { type: ElementRef }
];
FuiRadioManager.propDecorators = {
    _subManagers: [{ type: ContentChildren, args: [FuiRadioManager, { descendants: true },] }],
    _renderedRadios: [{ type: ContentChildren, args: [FuiRadio, { descendants: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiRadioManager, [{
        type: Directive,
        args: [{
                selector: 'form:not([ngForm]):not([[ngForm]]),ngForm,[ngForm]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { _subManagers: [{
            type: ContentChildren,
            args: [FuiRadioManager, { descendants: true }]
        }], _renderedRadios: [{
            type: ContentChildren,
            args: [FuiRadio, { descendants: true }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCheckboxModule {
}
FuiCheckboxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiCheckboxModule });
FuiCheckboxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiCheckboxModule_Factory(t) { return new (t || FuiCheckboxModule)(); }, imports: [[
            CommonModule,
            FormsModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiCheckboxModule, { declarations: function () { return [FuiCheckbox,
        FuiCheckboxValueAccessor,
        FuiRadio,
        FuiRadioValueAccessor,
        FuiRadioManager]; }, imports: function () { return [CommonModule,
        FormsModule]; }, exports: function () { return [FuiCheckbox,
        FuiCheckboxValueAccessor,
        FuiRadio,
        FuiRadioValueAccessor,
        FuiRadioManager]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCheckboxModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule
                ],
                declarations: [
                    FuiCheckbox,
                    FuiCheckboxValueAccessor,
                    FuiRadio,
                    FuiRadioValueAccessor,
                    FuiRadioManager
                ],
                exports: [
                    FuiCheckbox,
                    FuiCheckboxValueAccessor,
                    FuiRadio,
                    FuiRadioValueAccessor,
                    FuiRadioManager
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const CalendarMode = {
    DateOnly: 0,
    TimeOnly: 1,
    Both: 2,
};
CalendarMode[CalendarMode.DateOnly] = 'DateOnly';
CalendarMode[CalendarMode.TimeOnly] = 'TimeOnly';
CalendarMode[CalendarMode.Both] = 'Both';
class CalendarService {
    /**
     * @param {?} config
     * @param {?} localeValues
     */
    constructor(config, localeValues) {
        this.localeValues = localeValues;
        this.onManualUpdate = (/**
         * @return {?}
         */
        () => {
        });
        this.config = config;
        this.currentDate = new Date();
        this.firstDayOfWeek = this.localeValues.firstDayOfWeek;
        this.onDateChange = new EventEmitter();
        this.reset();
    }
    /**
     * @return {?}
     */
    get inFinalView() {
        return this.currentView === this.config.mappings.finalView;
    }
    /**
     * @return {?}
     */
    get config() {
        return this._config;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    set config(config) {
        this._config = config;
        config.updateBounds(this._selectedDate || this.currentDate);
    }
    /**
     * @return {?}
     */
    get selectedDate() {
        return this._selectedDate;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    set selectedDate(date) {
        if (date) {
            this._selectedDate = DateUtil.clone(date);
            this.currentDate = DateUtil.clone(date);
        }
        else {
            this._selectedDate = undefined;
        }
        this.config.updateBounds(this._selectedDate || this.currentDate);
        this.onManualUpdate();
    }
    /**
     * @return {?}
     */
    get minDate() {
        if (this._minDate && this.config.dateMinBound) {
            return this._minDate > this.config.dateMinBound ? this._minDate : this.config.dateMinBound;
        }
        return this._minDate || this.config.dateMinBound;
    }
    /**
     * @param {?} min
     * @return {?}
     */
    set minDate(min) {
        this._minDate = min;
    }
    /**
     * @return {?}
     */
    get maxDate() {
        if (this._maxDate && this.config.dateMaxBound) {
            return this._maxDate < this.config.dateMaxBound ? this._maxDate : this.config.dateMaxBound;
        }
        return this._maxDate || this.config.dateMaxBound;
    }
    /**
     * @param {?} max
     * @return {?}
     */
    set maxDate(max) {
        this._maxDate = max;
    }
    /**
     * @return {?}
     */
    get firstDayOfWeek() {
        return this._firstDayOfWeek;
    }
    /**
     * @param {?} firstDayOfWeek
     * @return {?}
     */
    set firstDayOfWeek(firstDayOfWeek) {
        if (firstDayOfWeek != undefined) {
            this._firstDayOfWeek = Math.max(0, Math.min(6, firstDayOfWeek));
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.currentView = this.config.mappings.finalView;
        if (!this._selectedDate) {
            /** @type {?} */
            let current = this.currentDate.getTime();
            if (this._minDate) {
                current = Math.max(current, this._minDate.getTime());
            }
            if (this._maxDate) {
                current = Math.min(current, this._maxDate.getTime());
            }
            this.currentDate = new Date(current);
            this.config.updateBounds(this.currentDate);
            this.currentView = this.config.mappings.initialView;
        }
    }
    /**
     * @param {?} date
     * @param {?} fromView
     * @return {?}
     */
    changeDate(date, fromView) {
        this.currentDate = date;
        if (fromView === this.config.mappings.finalView) {
            this.selectedDate = date;
            return this.onDateChange.emit(date);
        }
        this.updateView(this.config.mappings.changed, fromView);
    }
    /**
     * @param {?} fromView
     * @return {?}
     */
    zoomOut(fromView) {
        this.updateView(this.config.mappings.zoom, fromView);
    }
    /**
     * @private
     * @param {?} mappings
     * @param {?} fromView
     * @return {?}
     */
    updateView(mappings, fromView) {
        /** @type {?} */
        const mapping = mappings.get(fromView);
        if (mapping == undefined) {
            throw new Error('Unknown view type.');
        }
        this.currentView = mapping;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarItem {
    /**
     * @param {?} date
     */
    constructor(date) {
        this.date = date;
    }
}
class FuiCalendarItem {
    /**
     * @param {?} changeDetector
     */
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.hasFocus = false;
        this.onFocussed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get isSelectable() {
        return this.item.isSelectable;
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this.item.isActive;
    }
    /**
     * @return {?}
     */
    get isToday() {
        return this.item.isToday;
    }
    /**
     * @return {?}
     */
    onMouseMove() {
        if (!this.hasFocus) {
            this.hasFocus = true;
            this.onFocussed.emit(this.hasFocus);
        }
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        this.hasFocus = false;
        this.onFocussed.emit(this.hasFocus);
    }
}
FuiCalendarItem.ɵfac = function FuiCalendarItem_Factory(t) { return new (t || FuiCalendarItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
FuiCalendarItem.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiCalendarItem, selectors: [["", "calendarItem", ""]], hostVars: 8, hostBindings: function FuiCalendarItem_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousemove", function FuiCalendarItem_mousemove_HostBindingHandler() { return ctx.onMouseMove(); })("mouseleave", function FuiCalendarItem_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("focus", ctx.hasFocus)("disabled", ctx.isSelectable)("active", ctx.isActive)("today", ctx.isToday);
    } }, inputs: { item: ["calendarItem", "item"] } });
/** @nocollapse */
FuiCalendarItem.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FuiCalendarItem.propDecorators = {
    item: [{ type: Input, args: ['calendarItem',] }],
    hasFocus: [{ type: HostBinding, args: ['class.focus',] }],
    isSelectable: [{ type: HostBinding, args: ['class.disabled',] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    isToday: [{ type: HostBinding, args: ['class.today',] }],
    onMouseMove: [{ type: HostListener, args: ['mousemove',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCalendarItem, [{
        type: Directive,
        args: [{
                selector: '[calendarItem]'
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hasFocus: [{
            type: HostBinding,
            args: ['class.focus']
        }], isSelectable: [{
            type: HostBinding,
            args: ['class.disabled']
        }], isActive: [{
            type: HostBinding,
            args: ['class.active']
        }], isToday: [{
            type: HostBinding,
            args: ['class.today']
        }], onMouseMove: [{
            type: HostListener,
            args: ['mousemove']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], item: [{
            type: Input,
            args: ['calendarItem']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const CalendarViewType = {
    Year: 0,
    Month: 1,
    Date: 2,
    Hour: 3,
    Minute: 4,
};
CalendarViewType[CalendarViewType.Year] = 'Year';
CalendarViewType[CalendarViewType.Month] = 'Month';
CalendarViewType[CalendarViewType.Date] = 'Date';
CalendarViewType[CalendarViewType.Hour] = 'Hour';
CalendarViewType[CalendarViewType.Minute] = 'Minute';
/**
 * @abstract
 */
class CalendarView {
    /**
     * @param {?} renderer
     * @param {?} viewType
     * @param {?} ranges
     */
    constructor(renderer, viewType, ranges) {
        this._type = viewType;
        this.ranges = ranges;
        this._documentKeyDownListener = renderer.listen('document', 'keydown', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.onDocumentKeyDown(e)));
    }
    /**
     * @return {?}
     */
    get currentDate() {
        return this.service.currentDate;
    }
    /**
     * @return {?}
     */
    get selectedDate() {
        return this.service.selectedDate;
    }
    /**
     * @return {?}
     */
    get service() {
        return this._service;
    }
    /**
     * @param {?} service
     * @return {?}
     */
    set service(service) {
        this._service = service;
        this.ranges.loadService(service);
        this.service.onManualUpdate = (/**
         * @return {?}
         */
        () => {
            this.ranges.refresh();
            delete this._highlightedItem;
            this.autoHighlight();
        });
    }
    // Template Methods
    /**
     * @param {?} item
     * @return {?}
     */
    setDate(item) {
        this.service.changeDate(item.date, this._type);
    }
    /**
     * @return {?}
     */
    zoomOut() {
        this.service.zoomOut(this._type);
    }
    // Keyboard Control
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._renderedItems.changes.subscribe((/**
         * @return {?}
         */
        () => this.onRenderedItemsChanged()));
        this.onRenderedItemsChanged();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._documentKeyDownListener();
    }
    /**
     * @private
     * @return {?}
     */
    onRenderedItemsChanged() {
        this._renderedItems.forEach((/**
         * @param {?} i
         * @return {?}
         */
        i => i.onFocussed.subscribe((/**
         * @param {?} hasFocus
         * @return {?}
         */
        (hasFocus) => {
            if (hasFocus) {
                this.highlightItem(i.item);
            }
        }))));
        this.autoHighlight();
        this.highlightItem(this._highlightedItem);
    }
    /**
     * @private
     * @return {?}
     */
    autoHighlight() {
        /** @type {?} */
        let date = this.selectedDate && this.ranges.current.containsDate(this.selectedDate) ? this.selectedDate : this.currentDate;
        if (this._highlightedItem && this.ranges.current.containsDate(this._highlightedItem.date)) {
            date = this._highlightedItem.date;
        }
        /** @type {?} */
        const initiallyHighlighted = this.ranges.current.items.find((/**
         * @param {?} i
         * @return {?}
         */
        i => this.ranges.dateComparer.equal(i.date, date)));
        if (initiallyHighlighted && !initiallyHighlighted.isDisabled) {
            this._highlightedItem = initiallyHighlighted;
        }
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    highlightItem(item) {
        if (item) {
            this._renderedItems.forEach((/**
             * @param {?} i
             * @return {?}
             */
            i => i.hasFocus = false));
            /** @type {?} */
            const rendered = this._renderedItems.find((/**
             * @param {?} ri
             * @return {?}
             */
            ri => ri.item === item));
            if (rendered && !rendered.hasFocus) {
                rendered.hasFocus = true;
                rendered.changeDetector.detectChanges();
            }
            this._highlightedItem = item;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    onDocumentKeyDown(e) {
        if (this._highlightedItem && e.keyCode === KeyCode.Enter) {
            this.setDate(this._highlightedItem);
            return;
        }
        if (!this._highlightedItem) {
            this.autoHighlight();
        }
        /** @type {?} */
        const index = this.ranges.current.findIndex(this._highlightedItem);
        /** @type {?} */
        let isMovingForward = true;
        /** @type {?} */
        let delta = 0;
        switch (e.keyCode) {
            case KeyCode.Right:
                delta += 1;
                break;
            case KeyCode.Left:
                delta -= 1;
                isMovingForward = false;
                break;
            case KeyCode.Down:
                delta += this.ranges.columns;
                break;
            case KeyCode.Up:
                delta -= this.ranges.columns;
                isMovingForward = false;
                break;
            default:
                return;
        }
        // Stop these keypresses being captured elsewhere.
        e.preventDefault();
        /** @type {?} */
        let nextItem = this.ranges.current.items[index + delta];
        if (nextItem && nextItem.isDisabled) {
            return;
        }
        if (nextItem && !nextItem.isOutsideRange) {
            return this.highlightItem(nextItem);
        }
        if (nextItem && nextItem.isOutsideRange) {
            if (index + delta >= this.ranges.current.inRange.length) {
                isMovingForward = true;
            }
        }
        if (!nextItem) {
            /** @type {?} */
            let adjustedIndex = this.ranges.current.findIndex(this._highlightedItem);
            /** @type {?} */
            const nextItems = this.ranges.calc(isMovingForward).inRange;
            if (isMovingForward) {
                adjustedIndex -= this.ranges.current.inRange.length;
            }
            else {
                adjustedIndex += nextItems.length;
            }
            nextItem = nextItems[adjustedIndex + delta];
            if (nextItem.isDisabled) {
                return;
            }
        }
        this.ranges.move(isMovingForward);
        this._highlightedItem = this.ranges.current.find(nextItem);
    }
}
CalendarView.ɵfac = function CalendarView_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CalendarView.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CalendarView, viewQuery: function CalendarView_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(FuiCalendarItem, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._renderedItems = _t);
    } }, inputs: { service: "service" } });
CalendarView.propDecorators = {
    _renderedItems: [{ type: ViewChildren, args: [FuiCalendarItem,] }],
    service: [{ type: Input }]
};


/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CalendarMappings {
}
class DateMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Date;
        this.finalView = CalendarViewType.Date;
        this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Date],
            [CalendarViewType.Date, CalendarViewType.Date]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Date],
            [CalendarViewType.Month, CalendarViewType.Year],
            [CalendarViewType.Date, CalendarViewType.Month]
        ]);
    }
}
class TimeMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Hour;
        this.finalView = CalendarViewType.Minute;
        this.changed = new Map([
            [CalendarViewType.Hour, CalendarViewType.Minute],
            [CalendarViewType.Minute, CalendarViewType.Minute]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Hour, CalendarViewType.Minute],
            [CalendarViewType.Minute, CalendarViewType.Hour]
        ]);
    }
}
class DatetimeMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Date;
        this.finalView = CalendarViewType.Minute;
        this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Date],
            [CalendarViewType.Date, CalendarViewType.Hour],
            [CalendarViewType.Hour, CalendarViewType.Minute],
            [CalendarViewType.Minute, CalendarViewType.Minute]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Date],
            [CalendarViewType.Month, CalendarViewType.Year],
            [CalendarViewType.Date, CalendarViewType.Month],
            [CalendarViewType.Hour, CalendarViewType.Date],
            [CalendarViewType.Minute, CalendarViewType.Hour]
        ]);
    }
}
class MonthMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Month;
        this.finalView = CalendarViewType.Month;
        this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Month]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Year]
        ]);
    }
}
class YearMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Year;
        this.finalView = CalendarViewType.Year;
        this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Year]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Year]
        ]);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CalendarConfig {
    /**
     * @param {?} mode
     * @param {?} precision
     * @param {?} mappings
     * @param {?} fallback
     */
    constructor(mode, precision, mappings, fallback) {
        this.mode = mode;
        this.precision = precision;
        this.mappings = mappings;
        this.fallback = fallback;
    }
    /**
     * @param {?} providedDate
     * @return {?}
     */
    updateBounds(providedDate) {
        this.dateMinBound = DateUtil.startOf(DatePrecision.Year, new Date(), true);
        this.dateMinBound.setFullYear(0);
    }
}
class DateConfigBase extends CalendarConfig {
    /**
     * @param {?} precision
     * @param {?} mappings
     * @param {?} fallback
     */
    constructor(precision, mappings, fallback) {
        super(CalendarMode.DateOnly, precision, mappings, fallback);
    }
}
class YearConfig extends DateConfigBase {
    constructor() {
        super(DatePrecision.Year, new YearMappings(), 'number');
    }
}
class MonthConfig extends DateConfigBase {
    constructor() {
        super(DatePrecision.Month, new MonthMappings(), 'month');
    }
}
class DateConfig extends DateConfigBase {
    constructor() {
        super(DatePrecision.Date, new DateMappings(), 'date');
    }
}
class DatetimeConfig extends CalendarConfig {
    constructor() {
        super(CalendarMode.Both, DatePrecision.Minute, new DatetimeMappings(), 'datetime-local');
    }
}
class TimeConfig extends CalendarConfig {
    constructor() {
        super(CalendarMode.TimeOnly, DatePrecision.Minute, new TimeMappings(), 'time');
    }
    /**
     * @param {?} providedDate
     * @return {?}
     */
    updateBounds(providedDate) {
        this.dateMaxBound = DateUtil.endOf(DatePrecision.Date, DateUtil.clone(providedDate));
        this.dateMinBound = DateUtil.previous(DatePrecision.Date, DateUtil.clone(this.dateMaxBound));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateComparer {
    /**
     * @param {?} precision
     * @param {?} isSmallest
     */
    constructor(precision, isSmallest) {
        this._precision = precision;
        this._isSmallest = isSmallest;
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    equal(a, b) {
        if (this._precision === DatePrecision.Minute) {
            return !!b &&
                DateUtil.equal(DatePrecision.Hour, b, a) &&
                Util.Math.roundDown(b.getMinutes(), 5) === Util.Math.roundDown(a.getMinutes(), 5);
        }
        return !!b && DateUtil.equal(this._precision, a, b);
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    lessThan(a, b) {
        if (this._isSmallest) {
            return !b || (b >= a);
        }
        return !b || (DateUtil.endOf(this._precision, DateUtil.clone(b)) >= a);
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    greaterThan(a, b) {
        if (this._isSmallest) {
            return !b || (b <= a);
        }
        return !b || (DateUtil.startOf(this._precision, DateUtil.clone(b)) <= a);
    }
    /**
     * @param {?} date
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    between(date, left, right) {
        return this.greaterThan(date, left) && this.lessThan(date, right);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} values
 * @param {?} defaultType
 * @param {?=} indexCallback
 * @return {?}
 */
function buildLocalizeFn(values, defaultType, indexCallback) {
    return (/**
     * @param {?} dirtyIndex
     * @param {?=} __1
     * @return {?}
     */
    (dirtyIndex, { type } = { type: defaultType }) => {
        /** @type {?} */
        const index = indexCallback ? indexCallback(dirtyIndex) : dirtyIndex;
        return values[`${type}`][index];
    });
}
/**
 * @param {?} values
 * @param {?} defaultType
 * @return {?}
 */
function buildLocalizeArrayFn(values, defaultType) {
    return (/**
     * @param {?=} __0
     * @return {?}
     */
    ({ type } = { type: defaultType }) => values[`${type}`]);
}
/**
 * @param {?} patterns
 * @param {?} defaultType
 * @return {?}
 */
function buildMatchFn(patterns, defaultType) {
    return (/**
     * @param {?} dirtyString
     * @param {?=} __1
     * @return {?}
     */
    (dirtyString, { type } = { type: defaultType }) => dirtyString.match(`^(${patterns[`${type}`].join('|')})`));
}
/**
 * @param {?} patterns
 * @param {?} defaultType
 * @return {?}
 */
function buildParseFn(patterns, defaultType) {
    return (/**
     * @param {?} __0
     * @param {?=} __1
     * @return {?}
     */
    ([, result], { type } = { type: defaultType }) => (patterns[`${type}`] || patterns[defaultType])
        .map((/**
     * @param {?} p
     * @return {?}
     */
    p => new RegExp(`^${p}`)))
        .findIndex((/**
     * @param {?} pattern
     * @return {?}
     */
    pattern => pattern.test(result))));
}
class DateFnsParser {
    /**
     * @param {?} locale
     */
    constructor(locale) {
        this._weekStartsOn = (/** @type {?} */ (locale.firstDayOfWeek));
        /** @type {?} */
        const weekdayValues = {
            long: locale.weekdays,
            short: locale.weekdaysShort,
            narrow: locale.weekdaysNarrow
        };
        /** @type {?} */
        const monthValues = {
            long: locale.months,
            short: locale.monthsShort
        };
        /** @type {?} */
        const timeOfDayValues = {
            long: locale.timesOfDay,
            uppercase: locale.timesOfDayUppercase,
            lowercase: locale.timesOfDayLowercase
        };
        /** @type {?} */
        const timeOfDayMatchValues = {
            long: locale.timesOfDay,
            short: locale.timesOfDayUppercase.concat(locale.timesOfDayLowercase)
        };
        this._locale = (/** @type {?} */ (defaultLocale));
        this._locale.localize = Object.assign({}, this._locale.localize, {
            weekday: buildLocalizeFn(weekdayValues, 'long'),
            weekdays: buildLocalizeArrayFn(weekdayValues, 'long'),
            month: buildLocalizeFn(monthValues, 'long'),
            months: buildLocalizeArrayFn(monthValues, 'long'),
            timeOfDay: buildLocalizeFn(timeOfDayValues, 'long', (/**
             * @param {?} hours
             * @return {?}
             */
            (hours) => {
                return hours / 12 >= 1 ? 1 : 0;
            })),
            timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'long')
        });
        this._locale.match = Object.assign({}, this._locale.match, {
            weekdays: buildMatchFn(weekdayValues, 'long'),
            weekday: buildParseFn(weekdayValues, 'long'),
            months: buildMatchFn(monthValues, 'long'),
            month: buildParseFn(monthValues, 'long'),
            timesOfDay: buildMatchFn(timeOfDayMatchValues, 'long'),
            timeOfDay: buildParseFn(timeOfDayMatchValues, 'long')
        });
    }
    /**
     * @private
     * @return {?}
     */
    get _config() {
        return {
            weekStartsOn: this._weekStartsOn,
            locale: this._locale
        };
    }
    /**
     * @param {?} d
     * @param {?} f
     * @return {?}
     */
    format(d, f) {
        return format(d, f, this._config);
    }
    /**
     * @param {?} dS
     * @param {?} f
     * @param {?} bD
     * @return {?}
     */
    parse(dS, f, bD) {
        return parse(dS, this._config);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateParser {
    /**
     * @param {?} format
     * @param {?} locale
     */
    constructor(format, locale) {
        this._format = format;
        this._parser = new DateFnsParser(locale);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    format(date) {
        return this._parser.format(date, this._format);
    }
    /**
     * @param {?} dateString
     * @param {?=} baseDate
     * @return {?}
     */
    parse(dateString, baseDate = new Date()) {
        return this._parser.parse(dateString, this._format, baseDate);
    }
}
class InternalDateParser extends DateParser {
    /**
     * @param {?} mode
     * @param {?} locale
     */
    constructor(mode, locale) {
        /** @type {?} */
        const internalFormats = {
            time: 'HH:mm',
            datetime: 'YYYY-MM-DDTHH:mm',
            date: 'YYYY-MM-DD',
            month: 'YYYY-MM',
            year: 'YYYY'
        };
        super(internalFormats[mode], locale);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRange {
    /**
     * @param {?} start
     * @param {?} dates
     * @param {?} items
     * @param {?} grouped
     * @param {?} comparer
     */
    constructor(start, dates, items, grouped, comparer) {
        this.start = start;
        this.dates = dates;
        this.items = items;
        this.groupedItems = grouped;
        this._comparer = comparer;
    }
    /**
     * @return {?}
     */
    get inRange() {
        return this.items.filter((/**
         * @param {?} i
         * @return {?}
         */
        i => !i.isOutsideRange));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    find(item) {
        return this.items.find((/**
         * @param {?} i
         * @return {?}
         */
        i => this._comparer.equal(i.date, item.date)));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    findIndex(item) {
        if (!item) {
            return -1;
        }
        return this.items.findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => this._comparer.equal(i.date, item.date)));
    }
    /**
     * @param {?} date
     * @return {?}
     */
    containsDate(date) {
        return !!this.inRange.find((/**
         * @param {?} i
         * @return {?}
         */
        i => this._comparer.equal(i.date, date)));
    }
}
/**
 * @abstract
 */
class CalendarRangeService {
    /**
     * @param {?} interval
     * @param {?} rows
     * @param {?} columns
     */
    constructor(interval, rows, columns) {
        this.interval = interval;
        this.marginal = (/** @type {?} */ (interval)) + 1;
        this.rows = rows;
        this.columns = columns;
    }
    /**
     * @return {?}
     */
    get dateComparer() {
        return new DateComparer(this.marginal, this.service.inFinalView);
    }
    /**
     * @return {?}
     */
    get length() {
        return this.rows * this.columns;
    }
    /**
     * @return {?}
     */
    get canMoveNext() {
        /** @type {?} */
        const firstItem = this.next.inRange[0];
        if (firstItem && this.service.maxDate) {
            return firstItem.date <= this.service.maxDate;
        }
        return true;
    }
    /**
     * @return {?}
     */
    get canMovePrevious() {
        /** @type {?} */
        const lastItem = this.previous.inRange.slice(-1).pop();
        if (lastItem && this.service.minDate) {
            return lastItem.date >= this.service.minDate;
        }
        return true;
    }
    /**
     * @param {?} service
     * @return {?}
     */
    loadService(service) {
        this.service = service;
        this.refresh();
    }
    /**
     * @return {?}
     */
    refresh() {
        this.current = this.calcRange(this.service.currentDate);
        this.next = this.calcRange(DateUtil.next(this.interval, DateUtil.clone(this.service.currentDate)));
        this.previous = this.calcRange(DateUtil.previous(this.interval, DateUtil.clone(this.service.currentDate)));
    }
    /**
     * @param {?} forwards
     * @return {?}
     */
    move(forwards) {
        if (forwards) {
            return this.moveNext();
        }
        return this.movePrevious();
    }
    /**
     * @return {?}
     */
    moveNext() {
        DateUtil.next(this.interval, this.service.currentDate);
        this.previous = this.current;
        this.current = this.next;
        this.next = this.calcRange(DateUtil.next(this.interval, DateUtil.clone(this.service.currentDate)));
    }
    /**
     * @return {?}
     */
    movePrevious() {
        DateUtil.previous(this.interval, this.service.currentDate);
        this.next = this.current;
        this.current = this.previous;
        this.previous = this.calcRange(DateUtil.previous(this.interval, DateUtil.clone(this.service.currentDate)));
    }
    /**
     * @param {?} forwards
     * @return {?}
     */
    calc(forwards) {
        if (forwards) {
            return this.next;
        }
        return this.previous;
    }
    /**
     * @protected
     * @param {?} date
     * @return {?}
     */
    calcStart(date) {
        return DateUtil.startOf(this.interval, DateUtil.clone(date));
    }
    /**
     * @protected
     * @param {?} rangeStart
     * @return {?}
     */
    calcDates(rangeStart) {
        return Util.Array
            .range(this.length)
            .map((/**
         * @param {?} i
         * @return {?}
         */
        i => DateUtil.add(this.marginal, DateUtil.clone(rangeStart), i)));
    }
    /**
     * @protected
     * @param {?} dateRange
     * @param {?} baseDate
     * @return {?}
     */
    calcItems(dateRange, baseDate) {
        return dateRange.map((/**
         * @param {?} date
         * @return {?}
         */
        date => {
            /** @type {?} */
            const item = new CalendarItem(date);
            item.isDisabled = !this.dateComparer.between(item.date, this.service.minDate, this.service.maxDate);
            item.isActive = this.dateComparer.equal(item.date, this.service.selectedDate);
            item.isToday = this.dateComparer.equal(item.date, new Date());
            item.isSelectable = item.isDisabled;
            this.configureItem(item, baseDate);
            return item;
        }));
    }
    /**
     * @private
     * @param {?} startDate
     * @return {?}
     */
    calcRange(startDate) {
        /** @type {?} */
        const start = this.calcStart(startDate);
        if (this.service.inFinalView) {
            DateUtil.startOf(this.marginal, start, true);
        }
        /** @type {?} */
        const dates = this.calcDates(start);
        /** @type {?} */
        const items = this.calcItems(dates, startDate);
        return new CalendarRange(start, dates, items, Util.Array.group(items, this.columns), this.dateComparer);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCalendarViewTitle {
    constructor() {
        this.onZoomOut = new EventEmitter();
    }
}
FuiCalendarViewTitle.ɵfac = function FuiCalendarViewTitle_Factory(t) { return new (t || FuiCalendarViewTitle)(); };
FuiCalendarViewTitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiCalendarViewTitle, selectors: [["fui-calendar-view-title"]], inputs: { ranges: "ranges" }, outputs: { onZoomOut: "zoomOut" }, ngContentSelectors: _c0, decls: 6, vars: 4, consts: [[1, "title", "link", 3, "click"], [1, "prev", "link", 3, "click"], [1, "chevron", "left", "icon"], [1, "next", "link", 3, "click"], [1, "chevron", "right", "icon"]], template: function FuiCalendarViewTitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵlistener("click", function FuiCalendarViewTitle_Template_span_click_0_listener() { return ctx.onZoomOut.emit(); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 1);
        ɵngcc0.ɵɵlistener("click", function FuiCalendarViewTitle_Template_span_click_2_listener() { return ctx.ranges == null ? null : ctx.ranges.movePrevious(); });
        ɵngcc0.ɵɵelement(3, "i", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "span", 3);
        ɵngcc0.ɵɵlistener("click", function FuiCalendarViewTitle_Template_span_click_4_listener() { return ctx.ranges == null ? null : ctx.ranges.moveNext(); });
        ɵngcc0.ɵɵelement(5, "i", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("disabled", !(ctx.ranges == null ? null : ctx.ranges.canMovePrevious));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("disabled", !(ctx.ranges == null ? null : ctx.ranges.canMoveNext));
    } }, styles: [".title.link[_ngcontent-%COMP%] {\n    display: inline-block;\n    margin-left: 2rem;\n    margin-right: 2rem;\n}"] });
/** @nocollapse */
FuiCalendarViewTitle.ctorParameters = () => [];
FuiCalendarViewTitle.propDecorators = {
    ranges: [{ type: Input }],
    onZoomOut: [{ type: Output, args: ['zoomOut',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCalendarViewTitle, [{
        type: Component,
        args: [{
                selector: 'fui-calendar-view-title',
                template: `
<span class="title link" (click)="onZoomOut.emit()">
    <ng-content></ng-content>
</span>
<span class="prev link" [class.disabled]="!ranges?.canMovePrevious" (click)="ranges?.movePrevious()">
    <i class="chevron left icon"></i>
</span>
<span class="next link" [class.disabled]="!ranges?.canMoveNext" (click)="ranges?.moveNext()">
    <i class="chevron right icon"></i>
</span>
`,
                styles: [`
.title.link {
    display: inline-block;
    margin-left: 2rem;
    margin-right: 2rem;
}
`]
            }]
    }], function () { return []; }, { onZoomOut: [{
            type: Output,
            args: ['zoomOut']
        }], ranges: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DatepickerMode = {
    Year: (/** @type {?} */ ('year')),
    Month: (/** @type {?} */ ('month')),
    Date: (/** @type {?} */ ('date')),
    Datetime: (/** @type {?} */ ('datetime')),
    Time: (/** @type {?} */ ('time'))
};
class FuiDatepicker {
    /**
     * @param {?} localizationService
     */
    constructor(localizationService) {
        this.service = new CalendarService(new DatetimeConfig(), localizationService.get().datepicker);
        this.hasClasses = true;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseDown(e) {
        e.preventDefault();
    }
}
FuiDatepicker.ɵfac = function FuiDatepicker_Factory(t) { return new (t || FuiDatepicker)(ɵngcc0.ɵɵdirectiveInject(FuiLocalizationService)); };
FuiDatepicker.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiDatepicker, selectors: [["fui-datepicker"]], hostVars: 6, hostBindings: function FuiDatepicker_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function FuiDatepicker_mousedown_HostBindingHandler($event) { return ctx.onMouseDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ui", ctx.hasClasses)("active", ctx.hasClasses)("calendar", ctx.hasClasses);
    } }, decls: 6, vars: 6, consts: [[3, "ngSwitch"], [3, "service", 4, "ngSwitchCase"], [3, "service"]], template: function FuiDatepicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, FuiDatepicker_fui_calendar_year_view_1_Template, 1, 1, "fui-calendar-year-view", 1);
        ɵngcc0.ɵɵtemplate(2, FuiDatepicker_fui_calendar_month_view_2_Template, 1, 1, "fui-calendar-month-view", 1);
        ɵngcc0.ɵɵtemplate(3, FuiDatepicker_fui_calendar_date_view_3_Template, 1, 1, "fui-calendar-date-view", 1);
        ɵngcc0.ɵɵtemplate(4, FuiDatepicker_fui_calendar_hour_view_4_Template, 1, 1, "fui-calendar-hour-view", 1);
        ɵngcc0.ɵɵtemplate(5, FuiDatepicker_fui_calendar_minute_view_5_Template, 1, 1, "fui-calendar-minute-view", 1);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.service.currentView);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", 1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", 2);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", 3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", 4);
    } }, directives: function () { return [ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, FuiCalendarYearView,
        FuiCalendarMonthView,
        FuiCalendarDateView,
        FuiCalendarHourView,
        FuiCalendarMinuteView]; }, styles: ["[_nghost-%COMP%] {\n    user-select: none;\n}"] });
/** @nocollapse */
FuiDatepicker.ctorParameters = () => [
    { type: FuiLocalizationService }
];
FuiDatepicker.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.active',] }, { type: HostBinding, args: ['class.calendar',] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDatepicker, [{
        type: Component,
        args: [{
                selector: 'fui-datepicker',
                template: `
<ng-container [ngSwitch]="service.currentView">
    <fui-calendar-year-view [service]="service" *ngSwitchCase="0"></fui-calendar-year-view>
    <fui-calendar-month-view [service]="service" *ngSwitchCase="1"></fui-calendar-month-view>
    <fui-calendar-date-view [service]="service" *ngSwitchCase="2"></fui-calendar-date-view>
    <fui-calendar-hour-view [service]="service" *ngSwitchCase="3"></fui-calendar-hour-view>
    <fui-calendar-minute-view [service]="service" *ngSwitchCase="4"></fui-calendar-minute-view>
</ng-container>
`,
                styles: [`
:host {
    user-select: none;
}
`]
            }]
    }], function () { return [{ type: FuiLocalizationService }]; }, { hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.active']
        }, {
            type: HostBinding,
            args: ['class.calendar']
        }], onMouseDown: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PopupTrigger = {
    Hover: (/** @type {?} */ ('hover')),
    Click: (/** @type {?} */ ('click')),
    OutsideClick: (/** @type {?} */ ('outsideClick')),
    Focus: (/** @type {?} */ ('focus')),
    Manual: (/** @type {?} */ ('manual'))
};
class PopupConfig {
    /**
     * @param {?=} defaults
     */
    constructor(defaults = {}) {
        this.placement = PositioningPlacement.TopLeft;
        this.trigger = PopupTrigger.Hover;
        this.isInverted = false;
        this.delay = 0;
        this.isBasic = false;
        this.transition = 'scale';
        this.transitionDuration = 200;
        this.isFlowing = false;
        this.isInline = false;
        Object.assign(this, defaults);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPopup {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.transitionController = new TransitionController(false);
        this._isOpen = false;
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this.tabindex = 0;
    }
    // Returns the direction (`top`, `left`, `right`, `bottom`) of the current placement.
    /**
     * @return {?}
     */
    get direction() {
        // We need to set direction attribute before popper init to allow correct positioning
        return this.config.placement.split(' ').shift();
    }
    // Returns the alignment (`top`, `left`, `right`, `bottom`) of the current placement.
    /**
     * @return {?}
     */
    get alignment() {
        return this.config.placement.split(' ').pop();
    }
    /**
     * @return {?}
     */
    get dynamicClasses() {
        /** @type {?} */
        const classes = {};
        if (this.direction) {
            classes[this.direction] = true;
        }
        if (this.alignment) {
            classes[this.alignment] = true;
        }
        if (this.config.isInverted) {
            classes.inverted = true;
        }
        if (this.config.isBasic) {
            classes.basic = true;
        }
        if (this.config.isFlowing) {
            classes.flowing = true;
        }
        if (this.config.size) {
            classes[this.config.size] = true;
        }
        if (this.config.width) {
            classes[this.config.width] = true;
        }
        return classes;
    }
    /**
     * @param {?} anchor
     * @return {?}
     */
    set anchor(anchor) {
        this._anchor = anchor;
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @return {?}
     */
    open() {
        // Only attempt to open if currently closed.
        if (!this.isOpen) {
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Create positioning service after a brief delay.
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.positioningService = new PositioningService(this._anchor, this._container.element, this.config.placement, '.dynamic.arrow');
                this.positioningService.hasArrow = !this.config.isBasic;
            }));
            // Cancel all other transitions, and initiate the opening transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.In, (/**
             * @return {?}
             */
            () => {
                // Focus any element with [autofocus] attribute.
                /** @type {?} */
                const autoFocus = (/** @type {?} */ (this.elementRef.nativeElement.querySelector('[autofocus]')));
                if (autoFocus) {
                    // Autofocus after the browser has had time to process other event handlers.
                    setTimeout((/**
                     * @return {?}
                     */
                    () => autoFocus.focus()), 10);
                    // Try to focus again when the modal has opened so that autofocus works in IE11.
                    setTimeout((/**
                     * @return {?}
                     */
                    () => autoFocus.focus()), this.config.transitionDuration);
                }
            })));
            // Finally, set the popup to be open.
            this._isOpen = true;
            this.onOpen.emit();
        }
    }
    /**
     * @return {?}
     */
    toggle() {
        if (!this.isOpen) {
            return this.open();
        }
        return this.close();
    }
    /**
     * @return {?}
     */
    close() {
        // Only attempt to close if currently open.
        if (this.isOpen) {
            // Cancel all other transitions, and initiate the closing transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.Out));
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Start the closing timer, that fires the `onClose` event after the transition duration number of milliseconds.
            this.closingTimeout = window.setTimeout((/**
             * @return {?}
             */
            () => this.onClose.emit()), this.config.transitionDuration);
            // Finally, set the popup to be closed.
            this._isOpen = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        // Makes sense here, as the popup shouldn't be attached to any DOM element.
        event.stopPropagation();
    }
}
FuiPopup.ɵfac = function FuiPopup_Factory(t) { return new (t || FuiPopup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FuiPopup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiPopup, selectors: [["fui-popup"]], viewQuery: function FuiPopup_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c6, true, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c7, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateSibling = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._container = _t.first);
    } }, hostVars: 1, hostBindings: function FuiPopup_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FuiPopup_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex);
    } }, decls: 6, vars: 5, consts: [[1, "ui", "popup", 3, "ngClass", "fuiTransition"], ["container", ""], [4, "ngIf"], ["templateSibling", ""], [3, "placement", "inverted", 4, "ngIf"], ["class", "header", 4, "ngIf"], [1, "content"], [1, "header"], [3, "placement", "inverted"]], template: function FuiPopup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵtemplate(2, FuiPopup_ng_container_2_Template, 4, 2, "ng-container", 2);
        ɵngcc0.ɵɵelement(3, "div", null, 3);
        ɵngcc0.ɵɵtemplate(5, FuiPopup_fui_popup_arrow_5_Template, 1, 2, "fui-popup-arrow", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.dynamicClasses)("fuiTransition", ctx.transitionController);
        ɵngcc0.ɵɵattribute("direction", ctx.direction);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.config.template && (!!ctx.config.header || !!ctx.config.text));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.config.isBasic);
    } }, directives: function () { return [ɵngcc1.NgClass, FuiTransition, ɵngcc1.NgIf, FuiPopupArrow]; }, styles: [".ui.popup[_ngcontent-%COMP%] {\n    \n    right: auto;\n    margin: 0;\n}\n\n.ui.animating.popup[_ngcontent-%COMP%] {\n    \n    pointer-events: none;\n}\n\n.ui.popup[_ngcontent-%COMP%]::before {\n    \n    display: none;\n}\n\n\n.ui.popup[direction=\"top\"][_ngcontent-%COMP%], .ui.popup[direction=\"bottom\"][_ngcontent-%COMP%] {\n    margin-top: 0.75em;\n    margin-bottom: 0.75em;\n}\n\n\n.ui.popup[direction=\"left\"][_ngcontent-%COMP%], .ui.popup[direction=\"right\"][_ngcontent-%COMP%] {\n    margin-left: 0.75em;\n    margin-right: 0.75em;\n}"] });
/** @nocollapse */
FuiPopup.ctorParameters = () => [
    { type: ElementRef }
];
FuiPopup.propDecorators = {
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: true },] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    _container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: false },] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiPopup, [{
        type: Component,
        args: [{
                selector: 'fui-popup',
                template: `
<div class="ui popup"
     [ngClass]="dynamicClasses"
     [fuiTransition]="transitionController"
     [attr.direction]="direction"
     #container>

    <ng-container *ngIf="!config.template && (!!config.header || !!config.text)">
        <div class="header" *ngIf="config.header">{{ config.header }}</div>
        <div class="content">{{ config.text }}</div>
    </ng-container>
    <div #templateSibling></div>

    <fui-popup-arrow *ngIf="!config.isBasic"
                     [placement]="config.placement"
                     [inverted]="config.isInverted"></fui-popup-arrow>
</div>
`,
                styles: [`
.ui.popup {
    /* Autofit popup to the contents. */
    right: auto;
    margin: 0;
}

.ui.animating.popup {
    /* When the popup is animating, it may not initially be in the correct position.
       This fires a mouse event, causing the anchor's mouseleave to fire - making the popup flicker.
       Setting pointer-events to none while animating fixes this bug. */
    pointer-events: none;
}

.ui.popup::before {
    /* Hide the Fomantic UI CSS arrow. */
    display: none;
}

/* Offset popup by 0.75em above and below when placed 'vertically'. */
.ui.popup[direction="top"],
.ui.popup[direction="bottom"] {
    margin-top: 0.75em;
    margin-bottom: 0.75em;
}

/* Offset popup by 0.75em either side when placed 'horizontally'. */
.ui.popup[direction="left"],
.ui.popup[direction="right"] {
    margin-left: 0.75em;
    margin-right: 0.75em;
}
`]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], templateSibling: [{
            type: ViewChild,
            args: ['templateSibling', { read: ViewContainerRef, static: true }]
        }], _container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef, static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FuiPopupController {
    /**
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} _componentFactory
     * @param {?} config
     */
    constructor(_renderer, _element, _componentFactory, config) {
        this._renderer = _renderer;
        this._element = _element;
        this._componentFactory = _componentFactory;
        // Generate a new FuiPopup component and attach it to the application view.
        this._componentRef = this._componentFactory.createComponent(FuiPopup);
        // Configure popup with provided config.
        this.popup.config = config;
        // When the popup is closed (onClose fires on animation complete),
        this.popup.onClose.subscribe((/**
         * @return {?}
         */
        () => this.cleanup()));
    }
    // Returns generated popup instance.
    /**
     * @return {?}
     */
    get popup() {
        // Use non-null assertion as we only access this when a popup exists.
        return this._componentRef.instance;
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    configure(config) {
        if (config) {
            Object.assign(this.popup.config, config);
        }
    }
    /**
     * @return {?}
     */
    openDelayed() {
        // Cancel the opening timer.
        clearTimeout(this._openingTimeout);
        // Start the popup opening after the specified delay interval.
        this._openingTimeout = window.setTimeout((/**
         * @return {?}
         */
        () => this.open()), this.popup.config.delay);
    }
    /**
     * @return {?}
     */
    open() {
        // Attach the generated component to the current application.
        this._componentFactory.attachToApplication(this._componentRef);
        if (this.popup.config.isInline) {
            this._componentFactory.moveToElement(this._componentRef, this._element.nativeElement.parentElement);
        }
        else {
            // Move the generated element to the body to avoid any positioning issues.
            this._componentFactory.moveToDocumentBody(this._componentRef);
        }
        // Attach a reference to the anchor element. We do it here because IE11 loves to complain.
        this.popup.anchor = this._element;
        // Add a listener to the document body to handle closing.
        this._documentListener = this._renderer
            .listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.onDocumentClick(e)));
        // Start popup open transition.
        this.popup.open();
        // Call lifecyle hook
        /** @type {?} */
        const lifecycle = ((/** @type {?} */ (this))).popupOnOpen;
        if (lifecycle) {
            lifecycle.call(this);
        }
    }
    /**
     * @return {?}
     */
    close() {
        // Cancel the opening timer to stop the popup opening after close has been called.
        clearTimeout(this._openingTimeout);
        if (this._componentRef) {
            // Start popup close transition.
            this.popup.close();
        }
        // Call lifecyle hook
        /** @type {?} */
        const lifecycle = ((/** @type {?} */ (this))).popupOnClose;
        if (lifecycle) {
            lifecycle.call(this);
        }
    }
    /**
     * @return {?}
     */
    toggleDelayed() {
        // If the popup hasn't been created, or it has but it isn't currently open, open the popup.
        if (!this._componentRef || (this._componentRef && !this.popup.isOpen)) {
            return this.openDelayed();
        }
        // O'wise, close it.
        return this.close();
    }
    /**
     * @return {?}
     */
    toggle() {
        // If the popup hasn't been created, or it has but it isn't currently open, open the popup.
        if (!this._componentRef || (this._componentRef && !this.popup.isOpen)) {
            return this.open();
        }
        // O'wise, close it.
        return this.close();
    }
    /**
     * @return {?}
     */
    onMouseEnter() {
        if (this.popup.config.trigger === PopupTrigger.Hover) {
            this.openDelayed();
        }
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        if (this.popup.config.trigger === PopupTrigger.Hover) {
            this.close();
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.popup.config.trigger === PopupTrigger.Click ||
            this.popup.config.trigger === PopupTrigger.OutsideClick) {
            // Repeated clicks require a toggle, rather than just opening the popup each time.
            this.toggleDelayed();
        }
        else if (this.popup.config.trigger === PopupTrigger.Focus &&
            (!this._componentRef || (this._componentRef && !this.popup.isOpen))) {
            // Repeated clicks with a focus trigger requires an open (as focus isn't ever lost on repeated click).
            this.openDelayed();
        }
    }
    /**
     * @return {?}
     */
    onFocusIn() {
        if (this.popup.config.trigger === PopupTrigger.Focus) {
            this.openDelayed();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocusOut(e) {
        if (!this._element.nativeElement.contains(e.relatedTarget) &&
            !this.popup.elementRef.nativeElement.contains(e.relatedTarget) &&
            this.popup.config.trigger === PopupTrigger.Focus) {
            this.close();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.cleanup();
    }
    /**
     * @protected
     * @return {?}
     */
    cleanup() {
        clearTimeout(this._openingTimeout);
        if (this._componentRef.instance && this._componentRef.instance.positioningService) {
            this._componentRef.instance.positioningService.destroy();
        }
        this._componentFactory.detachFromApplication(this._componentRef);
        if (this._documentListener) {
            this._documentListener();
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    onDocumentClick(e) {
        // If the popup trigger is outside click,
        if (this._componentRef && this.popup.config.trigger === PopupTrigger.OutsideClick) {
            /** @type {?} */
            const target = (/** @type {?} */ (e.target));
            // Close the popup if the click is outside of the popup element.
            if (!((/** @type {?} */ (this._element.nativeElement))).contains(target)) {
                this.close();
            }
        }
    }
}
FuiPopupController.ɵfac = function FuiPopupController_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FuiPopupController.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiPopupController, hostBindings: function FuiPopupController_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function FuiPopupController_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function FuiPopupController_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); })("click", function FuiPopupController_click_HostBindingHandler() { return ctx.onClick(); })("focusin", function FuiPopupController_focusin_HostBindingHandler() { return ctx.onFocusIn(); })("focusout", function FuiPopupController_focusout_HostBindingHandler($event) { return ctx.onFocusOut($event); });
    } } });
FuiPopupController.propDecorators = {
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onFocusIn: [{ type: HostListener, args: ['focusin',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }]
};


/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiPopupComponentController extends FuiPopupController {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} componentFactory
     * @param {?} _component
     * @param {?} config
     */
    constructor(renderer, element, componentFactory, _component, config) {
        super(renderer, element, componentFactory, config);
        this._component = _component;
    }
    /**
     * @return {?}
     */
    get componentInstance() {
        if (this._contentComponentRef) {
            return this._contentComponentRef.instance;
        }
    }
    /**
     * @return {?}
     */
    open() {
        if (!this._contentComponentRef) {
            this._contentComponentRef = this._componentFactory.createComponent((/** @type {?} */ (this._component)));
            this._componentFactory.attachToView(this._contentComponentRef, this.popup.templateSibling);
        }
        super.open();
    }
    /**
     * @protected
     * @return {?}
     */
    cleanup() {
        super.cleanup();
        if (this._contentComponentRef) {
            this._contentComponentRef.destroy();
            this._contentComponentRef = undefined;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiPopupTemplateController extends FuiPopupController {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} componentFactory
     * @param {?} config
     */
    constructor(renderer, element, componentFactory, config) {
        super(renderer, element, componentFactory, config);
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    configure(config) {
        super.configure(config);
        if (config) {
            this.template = config.template;
            this.context = config.context;
        }
    }
    /**
     * @return {?}
     */
    open() {
        // If there is a template, inject it into the view.
        if (this.template) {
            this.popup.templateSibling.clear();
            this._componentFactory.createView(this.popup.templateSibling, this.template, {
                $implicit: this.popup,
                context: this.context
            });
        }
        super.open();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPopupArrow {
    /**
     * @return {?}
     */
    get direction() {
        if (this.placement) {
            return this.placement.split(' ').shift();
        }
    }
    /**
     * @return {?}
     */
    get alignment() {
        if (this.placement) {
            /** @type {?} */
            const alignment = this.placement.split(' ').pop();
            if (alignment === this.direction) {
                return 'center';
            }
            return alignment;
        }
    }
}
FuiPopupArrow.ɵfac = function FuiPopupArrow_Factory(t) { return new (t || FuiPopupArrow)(); };
FuiPopupArrow.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiPopupArrow, selectors: [["fui-popup-arrow"]], hostVars: 2, hostBindings: function FuiPopupArrow_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("inverted", ctx.inverted);
    } }, inputs: { placement: "placement", inverted: "inverted" }, decls: 2, vars: 2, consts: [["class", "dynamic arrow", 4, "ngIf"], ["class", "static arrow", 4, "ngIf"], [1, "dynamic", "arrow"], [1, "static", "arrow"]], template: function FuiPopupArrow_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FuiPopupArrow_div_0_Template, 1, 1, "div", 0);
        ɵngcc0.ɵɵtemplate(1, FuiPopupArrow_div_1_Template, 1, 2, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.alignment == "center");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alignment != "center");
    } }, directives: [ɵngcc1.NgIf], styles: [".arrow[_ngcontent-%COMP%] {\n    position: absolute;\n    width: 0.71428571em;\n    height: 0.71428571em;\n    background: #ffffff;\n    -webkit-transform: rotate(45deg);\n    -ms-transform: rotate(45deg);\n    transform: rotate(45deg);\n    z-index: 2;\n}\n\n.inverted[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%] {\n    background: #1b1c1d;\n}\n\n.arrow[direction=\"top\"][_ngcontent-%COMP%] {\n    bottom: -0.30714286em;\n    box-shadow: 1px 1px 0 0 #bababc;\n}\n\n.arrow[direction=\"left\"][_ngcontent-%COMP%] {\n    right: -0.30714286em;\n    box-shadow: 1px -1px 1px 0 #bababc;\n}\n\n.arrow[direction=\"bottom\"][_ngcontent-%COMP%] {\n    top: -0.30714286em;\n    box-shadow: -1px -1px 0 0 #bababc;\n}\n\n.arrow[direction=\"right\"][_ngcontent-%COMP%] {\n    left: -0.30714286em;\n    box-shadow: -1px 1px 1px 0 #bababc;\n}\n\n.static.arrow[direction=\"bottom\"][alignment=\"left\"][_ngcontent-%COMP%], .static.arrow[direction=\"top\"][alignment=\"left\"][_ngcontent-%COMP%] {\n    left: 1em;\n    right: auto;\n}\n\n.static.arrow[direction=\"left\"][alignment=\"top\"][_ngcontent-%COMP%], .static.arrow[direction=\"right\"][alignment=\"top\"][_ngcontent-%COMP%] {\n    top: 1em;\n    bottom: auto;\n}\n\n.static.arrow[direction=\"bottom\"][alignment=\"right\"][_ngcontent-%COMP%], .static.arrow[direction=\"top\"][alignment=\"right\"][_ngcontent-%COMP%] {\n    left: auto;\n    right: 1em;\n}\n\n.static.arrow[direction=\"left\"][alignment=\"bottom\"][_ngcontent-%COMP%], .static.arrow[direction=\"right\"][alignment=\"bottom\"][_ngcontent-%COMP%] {\n    top: auto;\n    bottom: 1em;\n}"] });
FuiPopupArrow.propDecorators = {
    placement: [{ type: Input }],
    inverted: [{ type: HostBinding, args: ['class.inverted',] }, { type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiPopupArrow, [{
        type: Component,
        args: [{
                selector: 'fui-popup-arrow',
                template: `
<div class="dynamic arrow" [attr.direction]="direction" *ngIf="alignment == 'center'"></div>
<div class="static arrow" [attr.direction]="direction" [attr.alignment]="alignment" *ngIf="alignment != 'center'"></div>
`,
                styles: [`
.arrow {
    position: absolute;
    width: 0.71428571em;
    height: 0.71428571em;
    background: #ffffff;
    -webkit-transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    transform: rotate(45deg);
    z-index: 2;
}

:host.inverted .arrow {
    background: #1b1c1d;
}

.arrow[direction="top"] {
    bottom: -0.30714286em;
    box-shadow: 1px 1px 0 0 #bababc;
}

.arrow[direction="left"] {
    right: -0.30714286em;
    box-shadow: 1px -1px 1px 0 #bababc;
}

.arrow[direction="bottom"] {
    top: -0.30714286em;
    box-shadow: -1px -1px 0 0 #bababc;
}

.arrow[direction="right"] {
    left: -0.30714286em;
    box-shadow: -1px 1px 1px 0 #bababc;
}

.static.arrow[direction="bottom"][alignment="left"],
.static.arrow[direction="top"][alignment="left"] {
    left: 1em;
    right: auto;
}

.static.arrow[direction="left"][alignment="top"],
.static.arrow[direction="right"][alignment="top"] {
    top: 1em;
    bottom: auto;
}

.static.arrow[direction="bottom"][alignment="right"],
.static.arrow[direction="top"][alignment="right"] {
    left: auto;
    right: 1em;
}

.static.arrow[direction="left"][alignment="bottom"],
.static.arrow[direction="right"][alignment="bottom"] {
    top: auto;
    bottom: 1em;
}
`]
            }]
    }], null, { placement: [{
            type: Input
        }], inverted: [{
            type: HostBinding,
            args: ['class.inverted']
        }, {
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPopupConfig extends PopupConfig {
    constructor() {
        // We use an empty constructor to ensure Angular DI works correctly.
        super();
    }
}
FuiPopupConfig.ɵfac = function FuiPopupConfig_Factory(t) { return new (t || FuiPopupConfig)(); };
FuiPopupConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FuiPopupConfig, factory: FuiPopupConfig.ɵfac });
/** @nocollapse */
FuiPopupConfig.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiPopupConfig, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiPopupDirective extends FuiPopupTemplateController {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} componentFactory
     * @param {?} popupDefaults
     */
    constructor(renderer, element, componentFactory, popupDefaults) {
        super(renderer, element, componentFactory, new PopupConfig(popupDefaults));
    }
    /**
     * @param {?} header
     * @return {?}
     */
    set popupHeader(header) {
        this.popup.config.header = header;
    }
    /**
     * @param {?} text
     * @return {?}
     */
    set popupText(text) {
        this.popup.config.text = text;
    }
    /**
     * @param {?} inverted
     * @return {?}
     */
    set popupInverted(inverted) {
        this.popup.config.isInverted = Util.DOM.parseBooleanAttribute(inverted);
    }
    /**
     * @param {?} basic
     * @return {?}
     */
    set popupBasic(basic) {
        this.popup.config.isBasic = Util.DOM.parseBooleanAttribute(basic);
    }
    /**
     * @param {?} inline
     * @return {?}
     */
    set popupInline(inline) {
        this.popup.config.isInline = Util.DOM.parseBooleanAttribute(inline);
    }
    /**
     * @param {?} flowing
     * @return {?}
     */
    set popupFlowing(flowing) {
        this.popup.config.isFlowing = Util.DOM.parseBooleanAttribute(flowing);
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    set popupTransition(transition) {
        this.popup.config.transition = transition;
    }
    /**
     * @param {?} duration
     * @return {?}
     */
    set popupTransitionDuration(duration) {
        this.popup.config.transitionDuration = duration;
    }
    /**
     * @param {?} placement
     * @return {?}
     */
    set popupPlacement(placement) {
        this.popup.config.placement = placement;
    }
    /**
     * @param {?} width
     * @return {?}
     */
    set popupWidth(width) {
        this.popup.config.width = width;
    }
    /**
     * @param {?} size
     * @return {?}
     */
    set popupSize(size) {
        this.popup.config.size = size;
    }
    /**
     * @param {?} delay
     * @return {?}
     */
    set popupDelay(delay) {
        this.popup.config.delay = delay;
    }
    /**
     * @return {?}
     */
    get popupTrigger() {
        return this.popup.config.trigger;
    }
    /**
     * @param {?} trigger
     * @return {?}
     */
    set popupTrigger(trigger) {
        this.popup.config.trigger = trigger;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    set popupTemplate(template) {
        this.template = template;
    }
    /**
     * @param {?} context
     * @return {?}
     */
    set popupTemplateContext(context) {
        this.context = context;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    set popupConfig(config) {
        this.configure(config);
    }
}
FuiPopupDirective.ɵfac = function FuiPopupDirective_Factory(t) { return new (t || FuiPopupDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(FuiComponentFactory), ɵngcc0.ɵɵdirectiveInject(FuiPopupConfig)); };
FuiPopupDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiPopupDirective, selectors: [["", "fuiPopup", ""]], inputs: { popupHeader: "popupHeader", popupText: "popupText", popupInverted: "popupInverted", popupBasic: "popupBasic", popupInline: "popupInline", popupFlowing: "popupFlowing", popupTransition: "popupTransition", popupTransitionDuration: "popupTransitionDuration", popupPlacement: "popupPlacement", popupWidth: "popupWidth", popupSize: "popupSize", popupDelay: "popupDelay", popupTrigger: "popupTrigger", popupTemplate: "popupTemplate", popupTemplateContext: "popupTemplateContext", popupConfig: "popupConfig" }, exportAs: ["fuiPopup"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FuiPopupDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: FuiComponentFactory },
    { type: FuiPopupConfig }
];
FuiPopupDirective.propDecorators = {
    popupHeader: [{ type: Input }],
    popupText: [{ type: Input }],
    popupInverted: [{ type: Input }],
    popupBasic: [{ type: Input }],
    popupInline: [{ type: Input }],
    popupFlowing: [{ type: Input }],
    popupTransition: [{ type: Input }],
    popupTransitionDuration: [{ type: Input }],
    popupPlacement: [{ type: Input }],
    popupWidth: [{ type: Input }],
    popupSize: [{ type: Input }],
    popupDelay: [{ type: Input }],
    popupTrigger: [{ type: Input }],
    popupTemplate: [{ type: Input }],
    popupTemplateContext: [{ type: Input }],
    popupConfig: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiPopupDirective, [{
        type: Directive,
        args: [{
                selector: '[fuiPopup]',
                exportAs: 'fuiPopup'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: FuiComponentFactory }, { type: FuiPopupConfig }]; }, { popupHeader: [{
            type: Input
        }], popupText: [{
            type: Input
        }], popupInverted: [{
            type: Input
        }], popupBasic: [{
            type: Input
        }], popupInline: [{
            type: Input
        }], popupFlowing: [{
            type: Input
        }], popupTransition: [{
            type: Input
        }], popupTransitionDuration: [{
            type: Input
        }], popupPlacement: [{
            type: Input
        }], popupWidth: [{
            type: Input
        }], popupSize: [{
            type: Input
        }], popupDelay: [{
            type: Input
        }], popupTrigger: [{
            type: Input
        }], popupTemplate: [{
            type: Input
        }], popupTemplateContext: [{
            type: Input
        }], popupConfig: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPopupModule {
}
FuiPopupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiPopupModule });
FuiPopupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiPopupModule_Factory(t) { return new (t || FuiPopupModule)(); }, providers: [
        FuiPopupConfig
    ], imports: [[
            CommonModule,
            FuiTransitionModule,
            FuiUtilityModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiPopupModule, { declarations: function () { return [FuiPopupDirective,
        FuiPopupArrow,
        FuiPopup]; }, imports: function () { return [CommonModule,
        FuiTransitionModule,
        FuiUtilityModule]; }, exports: function () { return [FuiPopupDirective,
        FuiPopup]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiPopupModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FuiTransitionModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiPopupDirective,
                    FuiPopupArrow,
                    FuiPopup
                ],
                exports: [
                    FuiPopupDirective,
                    FuiPopup
                ],
                providers: [
                    FuiPopupConfig
                ],
                entryComponents: [
                    FuiPopup
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDatepickerDirective extends FuiPopupComponentController {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} componentFactory
     * @param {?} localizationService
     */
    constructor(renderer, element, componentFactory, localizationService) {
        super(renderer, element, componentFactory, FuiDatepicker, new PopupConfig({
            trigger: PopupTrigger.Focus,
            placement: PositioningPlacement.BottomLeft,
            transition: 'scale',
            transitionDuration: 200
        }));
        this.localizationService = localizationService;
        // This ensures the popup is drawn correctly (i.e. no border).
        this._renderer.addClass(this.popup.elementRef.nativeElement, 'ui');
        this._renderer.addClass(this.popup.elementRef.nativeElement, 'calendar');
        this.onLocaleUpdate();
        this.localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        () => this.onLocaleUpdate()));
        this.onSelectedDateChange = new EventEmitter();
        this.onValidatorChange = new EventEmitter();
        this.mode = DatepickerMode.Datetime;
    }
    /**
     * @param {?} placement
     * @return {?}
     */
    set placement(placement) {
        this.popup.config.placement = placement;
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    set transition(transition) {
        this.popup.config.transition = transition;
    }
    /**
     * @param {?} duration
     * @return {?}
     */
    set transitionDuration(duration) {
        this.popup.config.transitionDuration = duration;
    }
    /**
     * @return {?}
     */
    get selectedDate() {
        return this._selectedDate;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    set selectedDate(date) {
        this._selectedDate = date;
        this.onSelectedDateChange.emit(date);
    }
    /**
     * @return {?}
     */
    get mode() {
        return this._mode;
    }
    /**
     * @param {?} mode
     * @return {?}
     */
    set mode(mode) {
        this._mode = mode || DatepickerMode.Datetime;
        switch (this._mode) {
            case DatepickerMode.Year:
                this.config = new YearConfig();
                break;
            case DatepickerMode.Month:
                this.config = new MonthConfig();
                break;
            case DatepickerMode.Date:
            default:
                this.config = new DateConfig();
                break;
            case DatepickerMode.Datetime:
                this.config = new DatetimeConfig();
                break;
            case DatepickerMode.Time:
                this.config = new TimeConfig();
                break;
        }
        this.writeValue(this.selectedDate);
    }
    /**
     * @return {?}
     */
    get localeValues() {
        return this.localizationService.override(this._localeValues, this.localeOverrides);
    }
    /**
     * @return {?}
     */
    popupOnOpen() {
        if (this.componentInstance) {
            this.componentInstance.service.config = this.config;
            this.componentInstance.service.localeValues = this.localeValues;
            this.componentInstance.service.currentDate = this.initialDate || new Date();
            this.componentInstance.service.selectedDate = this.selectedDate;
            this.componentInstance.service.maxDate = this.maxDate;
            this.componentInstance.service.minDate = this.minDate;
            if (this.firstDayOfWeek != undefined) {
                this.componentInstance.service.firstDayOfWeek = this.firstDayOfWeek;
            }
            this.componentInstance.service.reset();
            this.componentInstance.service.onDateChange.subscribe((/**
             * @param {?} d
             * @return {?}
             */
            (d) => {
                this.selectedDate = d;
                this.close();
            }));
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    ngOnChanges({ maxDate, minDate, mode }) {
        if (maxDate || minDate || mode) {
            this.onValidatorChange.emit();
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        /** @type {?} */
        const value = c.value;
        if (value != undefined) {
            // We post process the min & max date because sometimes this puts the date outside of the allowed range.
            if (this.minDate && value < this.minDate) {
                return { fuiMinDate: { required: this.minDate, actual: value } };
            }
            if (this.maxDate && value > this.maxDate) {
                return { fuiMaxDate: { required: this.maxDate, actual: value } };
            }
        }
        // Angular expects null
        // tslint:disable-next-line:no-null-keyword
        return null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.selectedDate = value;
        if (this.componentInstance) {
            this.componentInstance.service.selectedDate = value;
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        if (e.keyCode === KeyCode.Escape) {
            this.close();
        }
    }
    /**
     * @private
     * @return {?}
     */
    onLocaleUpdate() {
        this._localeValues = this.localizationService.get().datepicker;
    }
}
FuiDatepickerDirective.ɵfac = function FuiDatepickerDirective_Factory(t) { return new (t || FuiDatepickerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(FuiComponentFactory), ɵngcc0.ɵɵdirectiveInject(FuiLocalizationService)); };
FuiDatepickerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiDatepickerDirective, selectors: [["", "fuiDatepicker", ""]], hostBindings: function FuiDatepickerDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function FuiDatepickerDirective_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } }, inputs: { mode: ["pickerMode", "mode"], placement: ["pickerPlacement", "placement"], transition: ["pickerTransition", "transition"], transitionDuration: ["pickerTransitionDuration", "transitionDuration"], initialDate: ["pickerInitialDate", "initialDate"], maxDate: ["pickerMaxDate", "maxDate"], minDate: ["pickerMinDate", "minDate"], firstDayOfWeek: ["pickerFirstDayOfWeek", "firstDayOfWeek"], localeOverrides: ["pickerLocaleOverrides", "localeOverrides"] }, outputs: { onSelectedDateChange: "pickerSelectedDateChange", onValidatorChange: "pickerValidatorChange" }, features: [ɵngcc0.ɵɵProvidersFeature([customValidatorFactory(FuiDatepickerDirective)]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
FuiDatepickerDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: FuiComponentFactory },
    { type: FuiLocalizationService }
];
FuiDatepickerDirective.propDecorators = {
    initialDate: [{ type: Input, args: ['pickerInitialDate',] }],
    maxDate: [{ type: Input, args: ['pickerMaxDate',] }],
    minDate: [{ type: Input, args: ['pickerMinDate',] }],
    firstDayOfWeek: [{ type: Input, args: ['pickerFirstDayOfWeek',] }],
    localeOverrides: [{ type: Input, args: ['pickerLocaleOverrides',] }],
    onSelectedDateChange: [{ type: Output, args: ['pickerSelectedDateChange',] }],
    onValidatorChange: [{ type: Output, args: ['pickerValidatorChange',] }],
    placement: [{ type: Input, args: ['pickerPlacement',] }],
    transition: [{ type: Input, args: ['pickerTransition',] }],
    transitionDuration: [{ type: Input, args: ['pickerTransitionDuration',] }],
    mode: [{ type: Input, args: ['pickerMode',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDatepickerDirective, [{
        type: Directive,
        args: [{
                selector: '[fuiDatepicker]',
                providers: [customValidatorFactory(FuiDatepickerDirective)]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: FuiComponentFactory }, { type: FuiLocalizationService }]; }, { onSelectedDateChange: [{
            type: Output,
            args: ['pickerSelectedDateChange']
        }], onValidatorChange: [{
            type: Output,
            args: ['pickerValidatorChange']
        }], mode: [{
            type: Input,
            args: ['pickerMode']
        }], placement: [{
            type: Input,
            args: ['pickerPlacement']
        }], transition: [{
            type: Input,
            args: ['pickerTransition']
        }], transitionDuration: [{
            type: Input,
            args: ['pickerTransitionDuration']
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], initialDate: [{
            type: Input,
            args: ['pickerInitialDate']
        }], maxDate: [{
            type: Input,
            args: ['pickerMaxDate']
        }], minDate: [{
            type: Input,
            args: ['pickerMinDate']
        }], firstDayOfWeek: [{
            type: Input,
            args: ['pickerFirstDayOfWeek']
        }], localeOverrides: [{
            type: Input,
            args: ['pickerLocaleOverrides']
        }] }); })();
class FuiDatepickerDirectiveValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
        this.host = host;
    }
}
FuiDatepickerDirectiveValueAccessor.ɵfac = function FuiDatepickerDirectiveValueAccessor_Factory(t) { return new (t || FuiDatepickerDirectiveValueAccessor)(ɵngcc0.ɵɵdirectiveInject(FuiDatepickerDirective)); };
FuiDatepickerDirectiveValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiDatepickerDirectiveValueAccessor, selectors: [["", "fuiDatepicker", ""]], hostBindings: function FuiDatepickerDirectiveValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pickerSelectedDateChange", function FuiDatepickerDirectiveValueAccessor_pickerSelectedDateChange_HostBindingHandler($event) { return ctx.onChange($event); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([customValueAccessorFactory(FuiDatepickerDirectiveValueAccessor)]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FuiDatepickerDirectiveValueAccessor.ctorParameters = () => [
    { type: FuiDatepickerDirective }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDatepickerDirectiveValueAccessor, [{
        type: Directive,
        args: [{
                selector: '[fuiDatepicker]',
                host: { '(pickerSelectedDateChange)': 'onChange($event)' },
                providers: [customValueAccessorFactory(FuiDatepickerDirectiveValueAccessor)]
            }]
    }], function () { return [{ type: FuiDatepickerDirective }]; }, null); })();
class FuiDatepickerDirectiveValidator extends CustomValidator {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
        this.host = host;
    }
}
FuiDatepickerDirectiveValidator.ɵfac = function FuiDatepickerDirectiveValidator_Factory(t) { return new (t || FuiDatepickerDirectiveValidator)(ɵngcc0.ɵɵdirectiveInject(FuiDatepickerDirective)); };
FuiDatepickerDirectiveValidator.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiDatepickerDirectiveValidator, selectors: [["", "fuiDatepicker", ""]], hostBindings: function FuiDatepickerDirectiveValidator_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pickerValidatorChange", function FuiDatepickerDirectiveValidator_pickerValidatorChange_HostBindingHandler() { return ctx.onValidatorChange(); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([customValidatorFactory(FuiDatepickerDirectiveValidator)]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FuiDatepickerDirectiveValidator.ctorParameters = () => [
    { type: FuiDatepickerDirective }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDatepickerDirectiveValidator, [{
        type: Directive,
        args: [{
                selector: '[fuiDatepicker]',
                host: { '(pickerValidatorChange)': 'onValidatorChange()' },
                providers: [customValidatorFactory(FuiDatepickerDirectiveValidator)]
            }]
    }], function () { return [{ type: FuiDatepickerDirective }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDatepickerInputDirective {
    /**
     * @param {?} datepicker
     * @param {?} valueAccessor
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} localizationService
     */
    constructor(datepicker, valueAccessor, _renderer, _element, localizationService) {
        this.datepicker = datepicker;
        this.valueAccessor = valueAccessor;
        this._renderer = _renderer;
        this._element = _element;
        this.useNativeOnMobile = true;
        this.fallbackActive = false;
        // Whenever the datepicker value updates, update the input text alongside it.
        this.datepicker.onSelectedDateChange.subscribe((/**
         * @return {?}
         */
        () => this.updateValue(this.selectedDateString)));
        localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        () => this.updateValue(this.selectedDateString)));
    }
    /**
     * @return {?}
     */
    get parser() {
        if (this.fallbackActive) {
            return new InternalDateParser(this.datepicker.mode, this.datepicker.localeValues);
        }
        return new DateParser(this.datepicker.localeValues.formats[this.datepicker.mode], this.datepicker.localeValues);
    }
    /**
     * @return {?}
     */
    get selectedDateString() {
        if (this.datepicker.selectedDate) {
            return this.parser.format(this.datepicker.selectedDate);
        }
    }
    /**
     * @return {?}
     */
    get type() {
        if (this.fallbackActive) {
            return this.datepicker.config.fallback;
        }
        return 'text';
    }
    /**
     * @return {?}
     */
    get max() {
        if (this.fallbackActive && this.datepicker.maxDate) {
            // Since HTML doesn't use a date object max is somewhat tricky.
            // Our Datepicker will always choose the 1st date on the provided precision,
            // meaning anything below the maxDate will work, hence endOf.
            /** @type {?} */
            const max = DateUtil.endOf(this.datepicker.config.precision, DateUtil.clone(this.datepicker.maxDate));
            return this.parser.format(max);
        }
    }
    /**
     * @return {?}
     */
    get min() {
        if (this.fallbackActive && this.datepicker.minDate) {
            // Since HTML doesn't use a date object min is somewhat tricky.
            // We use 1 minute before the next date at the configured precision since
            // our Datepicker picks the first available date at that precision.
            /** @type {?} */
            const min = DateUtil.clone(this.datepicker.minDate);
            return this.parser.format(min);
        }
    }
    /**
     * @return {?}
     */
    get useNativeOnMobile() {
        return this._useNativeOnMobile;
    }
    /**
     * @param {?} fallback
     * @return {?}
     */
    set useNativeOnMobile(fallback) {
        this._useNativeOnMobile = fallback;
        /** @type {?} */
        const isOnMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(navigator.userAgent);
        this.fallbackActive = this.useNativeOnMobile && isOnMobile;
    }
    /**
     * @return {?}
     */
    get fallbackActive() {
        return this._fallbackActive;
    }
    /**
     * @param {?} active
     * @return {?}
     */
    set fallbackActive(active) {
        this._fallbackActive = active;
        // If the fallback is active, then the trigger must be manual so the datepicker never opens.
        this.datepicker.popup.config.trigger = this.fallbackActive ? PopupTrigger.Manual : PopupTrigger.Focus;
        // Update the input value (this will insert the `T` as required).
        this.updateValue(this.selectedDateString);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    typeValue(value) {
        this._lastUpdateTyped = true;
        this._currentInputValue = value;
        if (!value) {
            // Delete the selected date if no date was entered manually.
            return this.datepicker.writeValue(undefined);
        }
        /** @type {?} */
        const parsed = this.parser.parse(value, this.datepicker.selectedDate);
        if (!isNaN(parsed.getTime()) && value === this.parser.format(parsed)) {
            return this.datepicker.writeValue(parsed);
        }
        return this.datepicker.writeValue(undefined);
    }
    /**
     * @return {?}
     */
    onFocusOut() {
        this.valueAccessor.onTouched();
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        // Only update the current value if it is different to what it's being updated to.
        // This is so that the editing position isn't changed when manually typing the date.
        if (!this._lastUpdateTyped) {
            this._renderer.setProperty(this._element.nativeElement, 'value', value || '');
        }
        this._lastUpdateTyped = false;
    }
}
FuiDatepickerInputDirective.ɵfac = function FuiDatepickerInputDirective_Factory(t) { return new (t || FuiDatepickerInputDirective)(ɵngcc0.ɵɵdirectiveInject(FuiDatepickerDirective, 1), ɵngcc0.ɵɵdirectiveInject(FuiDatepickerDirectiveValueAccessor, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(FuiLocalizationService)); };
FuiDatepickerInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiDatepickerInputDirective, selectors: [["input", "fuiDatepicker", ""]], hostVars: 3, hostBindings: function FuiDatepickerInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function FuiDatepickerInputDirective_input_HostBindingHandler($event) { return ctx.typeValue($event.target.value); })("focusout", function FuiDatepickerInputDirective_focusout_HostBindingHandler() { return ctx.onFocusOut(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("type", ctx.type)("max", ctx.max)("min", ctx.min);
    } }, inputs: { useNativeOnMobile: ["pickerUseNativeOnMobile", "useNativeOnMobile"] } });
/** @nocollapse */
FuiDatepickerInputDirective.ctorParameters = () => [
    { type: FuiDatepickerDirective, decorators: [{ type: Host }] },
    { type: FuiDatepickerDirectiveValueAccessor, decorators: [{ type: Host }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: FuiLocalizationService }
];
FuiDatepickerInputDirective.propDecorators = {
    type: [{ type: HostBinding, args: ['attr.type',] }],
    max: [{ type: HostBinding, args: ['attr.max',] }],
    min: [{ type: HostBinding, args: ['attr.min',] }],
    useNativeOnMobile: [{ type: Input, args: ['pickerUseNativeOnMobile',] }],
    typeValue: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
    onFocusOut: [{ type: HostListener, args: ['focusout',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDatepickerInputDirective, [{
        type: Directive,
        args: [{
                selector: 'input[fuiDatepicker]'
            }]
    }], function () { return [{ type: FuiDatepickerDirective, decorators: [{
                type: Host
            }] }, { type: FuiDatepickerDirectiveValueAccessor, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: FuiLocalizationService }]; }, { useNativeOnMobile: [{
            type: Input,
            args: ['pickerUseNativeOnMobile']
        }], type: [{
            type: HostBinding,
            args: ['attr.type']
        }], max: [{
            type: HostBinding,
            args: ['attr.max']
        }], min: [{
            type: HostBinding,
            args: ['attr.min']
        }], typeValue: [{
            type: HostListener,
            args: ['input', ['$event.target.value']]
        }], onFocusOut: [{
            type: HostListener,
            args: ['focusout']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeDateService extends CalendarRangeService {
    /**
     * @param {?} start
     * @return {?}
     */
    calcStart(start) {
        /** @type {?} */
        const monthStart = DateUtil.startOf(DatePrecision.Month, DateUtil.clone(start));
        monthStart.setDate((1 - monthStart.getDay() + this.service.firstDayOfWeek - 7) % 7);
        return monthStart;
    }
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        item.humanReadable = item.date.getDate().toString();
        item.isOutsideRange = item.date.getMonth() !== baseDate.getMonth();
        item.isSelectable = item.isDisabled;
    }
}
class FuiCalendarDateView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Date, new CalendarRangeDateService(DatePrecision.Month, 6, 7));
    }
    /**
     * @return {?}
     */
    get days() {
        /** @type {?} */
        const days = this.service.localeValues.weekdaysNarrow;
        return days.map((/**
         * @param {?} d
         * @param {?} i
         * @return {?}
         */
        (d, i) => days[(i + this.service.firstDayOfWeek) % days.length]));
    }
    /**
     * @return {?}
     */
    get date() {
        return new DateParser(this.service.localeValues.formats.month, this.service.localeValues).format(this.currentDate);
    }
}
FuiCalendarDateView.ɵfac = function FuiCalendarDateView_Factory(t) { return new (t || FuiCalendarDateView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FuiCalendarDateView.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiCalendarDateView, selectors: [["fui-calendar-date-view"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 4, consts: [[1, "ui", "celled", "center", "aligned", "unstackable", "table", "seven", "column", "day"], ["colspan", "7"], [3, "ranges", "zoomOut"], [4, "ngFor", "ngForOf"], ["class", "link", 3, "calendarItem", "click", 4, "ngFor", "ngForOf"], [1, "link", 3, "calendarItem", "click"]], template: function FuiCalendarDateView_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "table", 0);
        ɵngcc0.ɵɵelementStart(1, "thead");
        ɵngcc0.ɵɵelementStart(2, "tr");
        ɵngcc0.ɵɵelementStart(3, "th", 1);
        ɵngcc0.ɵɵelementStart(4, "fui-calendar-view-title", 2);
        ɵngcc0.ɵɵlistener("zoomOut", function FuiCalendarDateView_Template_fui_calendar_view_title_zoomOut_4_listener() { return ctx.zoomOut(); });
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "tr");
        ɵngcc0.ɵɵtemplate(7, FuiCalendarDateView_th_7_Template, 2, 1, "th", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "tbody");
        ɵngcc0.ɵɵtemplate(9, FuiCalendarDateView_tr_9_Template, 2, 1, "tr", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ranges", ctx.ranges);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.date, " ");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.days);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ranges.current.groupedItems);
    } }, directives: [FuiCalendarViewTitle, ɵngcc1.NgForOf, FuiCalendarItem], encapsulation: 2 });
/** @nocollapse */
FuiCalendarDateView.ctorParameters = () => [
    { type: Renderer2 }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCalendarDateView, [{
        type: Component,
        args: [{
                selector: 'fui-calendar-date-view',
                template: `
<table class="ui celled center aligned unstackable table seven column day">
<thead>
    <tr>
        <th colspan="7">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ date }}
            </fui-calendar-view-title>
        </th>
    </tr>
    <tr>
        <th *ngFor="let day of days">{{ day }}</th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeHourService extends CalendarRangeService {
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        // Set minutes and seconds to 0
        /** @type {?} */
        const customFormat = this.service.localeValues.formats.time.replace(/[ms]/g, '0');
        item.humanReadable = new DateParser(customFormat, this.service.localeValues).format(item.date);
        item.isOutsideRange = false;
    }
}
class FuiCalendarHourView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Hour, new CalendarRangeHourService(DatePrecision.Date, 6, 4));
    }
    /**
     * @return {?}
     */
    get date() {
        return new DateParser(this.service.localeValues.formats.date, this.service.localeValues).format(this.currentDate);
    }
}
FuiCalendarHourView.ɵfac = function FuiCalendarHourView_Factory(t) { return new (t || FuiCalendarHourView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FuiCalendarHourView.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiCalendarHourView, selectors: [["fui-calendar-hour-view"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 2, consts: [[1, "ui", "celled", "center", "aligned", "unstackable", "table", "four", "column", "hour"], [4, "ngIf"], [4, "ngFor", "ngForOf"], ["colspan", "4"], [3, "ranges", "zoomOut"], ["class", "link", 3, "calendarItem", "click", 4, "ngFor", "ngForOf"], [1, "link", 3, "calendarItem", "click"]], template: function FuiCalendarHourView_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "table", 0);
        ɵngcc0.ɵɵtemplate(1, FuiCalendarHourView_thead_1_Template, 5, 2, "thead", 1);
        ɵngcc0.ɵɵelementStart(2, "tbody");
        ɵngcc0.ɵɵtemplate(3, FuiCalendarHourView_tr_3_Template, 2, 1, "tr", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.service.config.mode != 1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ranges.current.groupedItems);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, FuiCalendarViewTitle,
        FuiCalendarItem], encapsulation: 2 });
/** @nocollapse */
FuiCalendarHourView.ctorParameters = () => [
    { type: Renderer2 }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCalendarHourView, [{
        type: Component,
        args: [{
                selector: 'fui-calendar-hour-view',
                template: `
<table class="ui celled center aligned unstackable table four column hour">
<thead *ngIf="service.config.mode != 1">
    <tr>
        <th colspan="4">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ date }}
            </fui-calendar-view-title>
        </th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeMinuteService extends CalendarRangeService {
    /**
     * @param {?} start
     * @return {?}
     */
    calcStart(start) {
        return DateUtil.startOf(DatePrecision.Hour, DateUtil.clone(start), true);
    }
    /**
     * @param {?} start
     * @return {?}
     */
    calcDates(start) {
        return Util.Array
            .range(this.length)
            .map((/**
         * @param {?} i
         * @return {?}
         */
        i => DateUtil.add(DatePrecision.Minute, DateUtil.clone(start), i * 5)));
    }
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        item.humanReadable = new DateParser(this.service.localeValues.formats.time, this.service.localeValues).format(item.date);
        item.isOutsideRange = false;
    }
}
class FuiCalendarMinuteView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Minute, new CalendarRangeMinuteService(DatePrecision.Hour, 4, 3));
    }
    /**
     * @return {?}
     */
    get date() {
        if (this.service.config.mode !== CalendarMode.TimeOnly) {
            // Set minutes and seconds to 0
            /** @type {?} */
            const dateTimeFormat = this.service.localeValues.formats.datetime.replace(/[ms]/g, '0');
            return new DateParser(dateTimeFormat, this.service.localeValues).format(this.currentDate);
        }
        else {
            // Set minutes and seconds to 0
            /** @type {?} */
            const timeFormat = this.service.localeValues.formats.time.replace(/[ms]/g, '0');
            return new DateParser(timeFormat, this.service.localeValues).format(this.currentDate);
        }
    }
}
FuiCalendarMinuteView.ɵfac = function FuiCalendarMinuteView_Factory(t) { return new (t || FuiCalendarMinuteView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FuiCalendarMinuteView.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiCalendarMinuteView, selectors: [["fui-calendar-minute-view"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 8, vars: 3, consts: [[1, "ui", "celled", "center", "aligned", "unstackable", "table", "three", "column", "minute"], ["colspan", "4"], [3, "ranges", "zoomOut"], [4, "ngFor", "ngForOf"], ["class", "link", 3, "calendarItem", "click", 4, "ngFor", "ngForOf"], [1, "link", 3, "calendarItem", "click"]], template: function FuiCalendarMinuteView_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "table", 0);
        ɵngcc0.ɵɵelementStart(1, "thead");
        ɵngcc0.ɵɵelementStart(2, "tr");
        ɵngcc0.ɵɵelementStart(3, "th", 1);
        ɵngcc0.ɵɵelementStart(4, "fui-calendar-view-title", 2);
        ɵngcc0.ɵɵlistener("zoomOut", function FuiCalendarMinuteView_Template_fui_calendar_view_title_zoomOut_4_listener() { return ctx.zoomOut(); });
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "tbody");
        ɵngcc0.ɵɵtemplate(7, FuiCalendarMinuteView_tr_7_Template, 2, 1, "tr", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ranges", ctx.ranges);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.date, " ");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ranges.current.groupedItems);
    } }, directives: [FuiCalendarViewTitle, ɵngcc1.NgForOf, FuiCalendarItem], encapsulation: 2 });
/** @nocollapse */
FuiCalendarMinuteView.ctorParameters = () => [
    { type: Renderer2 }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCalendarMinuteView, [{
        type: Component,
        args: [{
                selector: 'fui-calendar-minute-view',
                template: `
<table class="ui celled center aligned unstackable table three column minute">
<thead>
    <tr>
        <th colspan="4">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ date }}
            </fui-calendar-view-title>
        </th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeMonthService extends CalendarRangeService {
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        item.humanReadable = this.service.localeValues.monthsShort[item.date.getMonth()];
        item.isOutsideRange = false;
    }
}
class FuiCalendarMonthView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Month, new CalendarRangeMonthService(DatePrecision.Year, 4, 3));
    }
    /**
     * @return {?}
     */
    get year() {
        return new DateParser(this.service.localeValues.formats.year, this.service.localeValues).format(this.currentDate);
    }
}
FuiCalendarMonthView.ɵfac = function FuiCalendarMonthView_Factory(t) { return new (t || FuiCalendarMonthView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FuiCalendarMonthView.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiCalendarMonthView, selectors: [["fui-calendar-month-view"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 8, vars: 3, consts: [[1, "ui", "celled", "center", "aligned", "unstackable", "table", "three", "column", "month"], ["colspan", "3"], [3, "ranges", "zoomOut"], [4, "ngFor", "ngForOf"], ["class", "link", 3, "calendarItem", "click", 4, "ngFor", "ngForOf"], [1, "link", 3, "calendarItem", "click"]], template: function FuiCalendarMonthView_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "table", 0);
        ɵngcc0.ɵɵelementStart(1, "thead");
        ɵngcc0.ɵɵelementStart(2, "tr");
        ɵngcc0.ɵɵelementStart(3, "th", 1);
        ɵngcc0.ɵɵelementStart(4, "fui-calendar-view-title", 2);
        ɵngcc0.ɵɵlistener("zoomOut", function FuiCalendarMonthView_Template_fui_calendar_view_title_zoomOut_4_listener() { return ctx.zoomOut(); });
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "tbody");
        ɵngcc0.ɵɵtemplate(7, FuiCalendarMonthView_tr_7_Template, 2, 1, "tr", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ranges", ctx.ranges);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.year, " ");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ranges.current.groupedItems);
    } }, directives: [FuiCalendarViewTitle, ɵngcc1.NgForOf, FuiCalendarItem], encapsulation: 2 });
/** @nocollapse */
FuiCalendarMonthView.ctorParameters = () => [
    { type: Renderer2 }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCalendarMonthView, [{
        type: Component,
        args: [{
                selector: 'fui-calendar-month-view',
                template: `
<table class="ui celled center aligned unstackable table three column month">
<thead>
    <tr>
        <th colspan="3">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ year }}
            </fui-calendar-view-title>
        </th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeYearService extends CalendarRangeService {
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        item.humanReadable = Util.String.padLeft(item.date.getFullYear().toString(), 4, '0');
        item.isOutsideRange = item.date.getFullYear() >= this.calcStart(baseDate).getFullYear() + 10;
    }
}
class FuiCalendarYearView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Year, new CalendarRangeYearService(DatePrecision.Decade, 4, 3));
    }
    /**
     * @return {?}
     */
    get decadeStart() {
        return DateUtil
            .startOf(DatePrecision.Decade, DateUtil.clone(this.service.currentDate))
            .getFullYear();
    }
    /**
     * @param {?} year
     * @return {?}
     */
    pad(year) {
        return Util.String.padLeft(year.toString(), 4, '0');
    }
}
FuiCalendarYearView.ɵfac = function FuiCalendarYearView_Factory(t) { return new (t || FuiCalendarYearView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FuiCalendarYearView.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiCalendarYearView, selectors: [["fui-calendar-year-view"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 8, vars: 4, consts: [[1, "ui", "celled", "center", "aligned", "unstackable", "table", "three", "column", "year"], ["colspan", "3"], [3, "ranges", "zoomOut"], [4, "ngFor", "ngForOf"], ["class", "link", 3, "calendarItem", "click", 4, "ngFor", "ngForOf"], [1, "link", 3, "calendarItem", "click"]], template: function FuiCalendarYearView_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "table", 0);
        ɵngcc0.ɵɵelementStart(1, "thead");
        ɵngcc0.ɵɵelementStart(2, "tr");
        ɵngcc0.ɵɵelementStart(3, "th", 1);
        ɵngcc0.ɵɵelementStart(4, "fui-calendar-view-title", 2);
        ɵngcc0.ɵɵlistener("zoomOut", function FuiCalendarYearView_Template_fui_calendar_view_title_zoomOut_4_listener() { return ctx.zoomOut(); });
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "tbody");
        ɵngcc0.ɵɵtemplate(7, FuiCalendarYearView_tr_7_Template, 2, 1, "tr", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ranges", ctx.ranges);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate2(" ", ctx.pad(ctx.decadeStart), " - ", ctx.pad(ctx.decadeStart + 10), " ");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ranges.current.groupedItems);
    } }, directives: [FuiCalendarViewTitle, ɵngcc1.NgForOf, FuiCalendarItem], encapsulation: 2 });
/** @nocollapse */
FuiCalendarYearView.ctorParameters = () => [
    { type: Renderer2 }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiCalendarYearView, [{
        type: Component,
        args: [{
                selector: 'fui-calendar-year-view',
                template: `
<table class="ui celled center aligned unstackable table three column year">
<thead>
    <tr>
        <th colspan="3">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ pad(decadeStart) }} - {{ pad(decadeStart + 10) }}
            </fui-calendar-view-title>
        </th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDatepickerModule {
}
FuiDatepickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiDatepickerModule });
FuiDatepickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiDatepickerModule_Factory(t) { return new (t || FuiDatepickerModule)(); }, imports: [[
            CommonModule,
            FormsModule,
            FuiPopupModule,
            FuiLocalizationModule,
            FuiUtilityModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiDatepickerModule, { declarations: function () { return [FuiCalendarItem,
        FuiCalendarViewTitle,
        FuiCalendarYearView,
        FuiCalendarMonthView,
        FuiCalendarDateView,
        FuiCalendarHourView,
        FuiCalendarMinuteView,
        FuiDatepicker,
        FuiDatepickerDirective,
        FuiDatepickerDirectiveValueAccessor,
        FuiDatepickerDirectiveValidator,
        FuiDatepickerInputDirective]; }, imports: function () { return [CommonModule,
        FormsModule,
        FuiPopupModule,
        FuiLocalizationModule,
        FuiUtilityModule]; }, exports: function () { return [FuiDatepickerDirective,
        FuiDatepickerDirectiveValueAccessor,
        FuiDatepickerDirectiveValidator,
        FuiDatepickerInputDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDatepickerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FuiPopupModule,
                    FuiLocalizationModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiCalendarItem,
                    FuiCalendarViewTitle,
                    FuiCalendarYearView,
                    FuiCalendarMonthView,
                    FuiCalendarDateView,
                    FuiCalendarHourView,
                    FuiCalendarMinuteView,
                    FuiDatepicker,
                    FuiDatepickerDirective,
                    FuiDatepickerDirectiveValueAccessor,
                    FuiDatepickerDirectiveValidator,
                    FuiDatepickerInputDirective
                ],
                exports: [
                    FuiDatepickerDirective,
                    FuiDatepickerDirectiveValueAccessor,
                    FuiDatepickerDirectiveValidator,
                    FuiDatepickerInputDirective
                ],
                entryComponents: [
                    FuiDatepicker
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDimmer extends FuiTransition {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(renderer, element, changeDetector) {
        super(renderer, element, changeDetector);
        this._isDimmed = false;
        this.isDimmedChange = new EventEmitter();
        this.isClickable = true;
        this.wrapContent = true;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get isDimmed() {
        return this._isDimmed;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isDimmed(value) {
        /** @type {?} */
        const isDimmed = !!value;
        if (!this._transitionController) {
            // Initialise transition functionality when first setting dimmed, to ensure initial state doesn't transition.
            this._transitionController = new TransitionController(isDimmed, 'block');
            this.setTransitionController(this._transitionController);
            this._isDimmed = isDimmed;
        }
        else if (this._isDimmed !== isDimmed) {
            this._isDimmed = isDimmed;
            this._transitionController.stopAll();
            this._transitionController.animate(new Transition('fade', this.transitionDuration, isDimmed ? TransitionDirection.In : TransitionDirection.Out));
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.isClickable) {
            this.isDimmed = false;
            this.isDimmedChange.emit(this.isDimmed);
        }
    }
}
FuiDimmer.ɵfac = function FuiDimmer_Factory(t) { return new (t || FuiDimmer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
FuiDimmer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiDimmer, selectors: [["fui-dimmer"]], hostVars: 6, hostBindings: function FuiDimmer_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FuiDimmer_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ui", ctx.hasClasses)("dimmer", ctx.hasClasses)("active", ctx.isDimmed);
    } }, inputs: { isClickable: "isClickable", wrapContent: "wrapContent", isDimmed: "isDimmed", transition: "transition", transitionDuration: "transitionDuration" }, outputs: { isDimmedChange: "isDimmedChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 2, vars: 2, template: function FuiDimmer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("content", ctx.wrapContent);
    } }, styles: [".dimmer[_nghost-%COMP%]:not(.hidden) {\n    transition: none;\n    display: flex !important;\n}"] });
/** @nocollapse */
FuiDimmer.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiDimmer.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.dimmer',] }],
    isDimmedChange: [{ type: Output }],
    isClickable: [{ type: Input }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    wrapContent: [{ type: Input }],
    isDimmed: [{ type: HostBinding, args: ['class.active',] }, { type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDimmer, [{
        type: Component,
        args: [{
                selector: 'fui-dimmer',
                template: `
<div [class.content]="wrapContent">
    <ng-content></ng-content>
</div>
`,
                styles: [`
:host.dimmer:not(.hidden) {
    transition: none;
    display: flex !important;
}
`]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { isDimmedChange: [{
            type: Output
        }], isClickable: [{
            type: Input
        }], wrapContent: [{
            type: Input
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.dimmer']
        }], isDimmed: [{
            type: HostBinding,
            args: ['class.active']
        }, {
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], transition: [{
            type: Input
        }], transitionDuration: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDimmerModule {
}
FuiDimmerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiDimmerModule });
FuiDimmerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiDimmerModule_Factory(t) { return new (t || FuiDimmerModule)(); }, imports: [[
            CommonModule,
            FuiTransitionModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiDimmerModule, { declarations: function () { return [FuiDimmer]; }, imports: function () { return [CommonModule,
        FuiTransitionModule]; }, exports: function () { return [FuiDimmer]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDimmerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FuiTransitionModule
                ],
                declarations: [
                    FuiDimmer
                ],
                exports: [
                    FuiDimmer
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Creates essentially a 'string' enum.
/** @type {?} */
const DropdownAutoCloseType = {
    ItemClick: (/** @type {?} */ ('itemClick')),
    OutsideClick: (/** @type {?} */ ('outsideClick')),
    Disabled: (/** @type {?} */ ('disabled'))
};
class DropdownService {
    /**
     * @param {?=} autoCloseMode
     */
    constructor(autoCloseMode = DropdownAutoCloseType.ItemClick) {
        this.isOpen = false;
        this.isOpenChange = new EventEmitter();
        this.isDisabled = false;
        this.autoCloseMode = autoCloseMode;
        this.children = [];
    }
    /**
     * @return {?}
     */
    get isNested() {
        return !!this.parent;
    }
    /**
     * @param {?} isOpen
     * @param {?=} reflectInParent
     * @return {?}
     */
    setOpenState(isOpen, reflectInParent = false) {
        if (this.isOpen !== isOpen && !this.isDisabled) {
            // Only update the state if it has changed, and the dropdown isn't disabled.
            this.isOpen = !!isOpen;
            this.isAnimating = true;
            // We must delay the emitting to avoid the 'changed after checked' Angular errors.
            this.delay((/**
             * @return {?}
             */
            () => this.isOpenChange.emit(this.isOpen)));
            if (!this.isOpen) {
                // Close the child dropdowns when this one closes.
                this.children.forEach((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => c.setOpenState(this.isOpen)));
            }
            if (this.parent && reflectInParent) {
                // Open the parent dropdowns when this one opens.
                this.parent.setOpenState(this.isOpen, true);
            }
        }
        else if (this.isOpen !== isOpen && this.isDisabled) {
            // If the state has changed, but the dropdown is disabled, re-emit the original isOpen value.
            this.delay((/**
             * @return {?}
             */
            () => this.isOpenChange.emit(this.isOpen)));
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        if (this.isDisabled !== isDisabled) {
            if (!!isDisabled) {
                // Close the dropdown as it is now disabled
                this.setOpenState(false);
            }
            this.isDisabled = !!isDisabled;
        }
    }
    /**
     * @return {?}
     */
    toggleOpenState() {
        this.setOpenState(!this.isOpen);
    }
    // Registers a dropdown service as a child of this service.
    /**
     * @param {?} child
     * @return {?}
     */
    registerChild(child) {
        if (!this.isChildRegistered(child)) {
            this.children.push(child);
            child.parent = this;
        }
    }
    // Recursive method to check if the provided dropdown is already registered as a child, or is a descendant of a child.
    /**
     * @param {?} child
     * @return {?}
     */
    isChildRegistered(child) {
        return this === child || !!this.children
            .find((/**
         * @param {?} c
         * @return {?}
         */
        c => !!c.children
            .find((/**
         * @param {?} cChild
         * @return {?}
         */
        cChild => cChild.isChildRegistered(child)))));
    }
    // Wipes any nested data, so all services can be cleanly reattached.
    /**
     * @return {?}
     */
    clearChildren() {
        this.children.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => {
            c.parent = undefined;
        }));
        this.children = [];
    }
    // Method for delaying an event into the next tick, to avoid Angular "changed after checked" error.
    /**
     * @private
     * @param {?} callback
     * @return {?}
     */
    delay(callback) {
        setTimeout((/**
         * @return {?}
         */
        () => callback()));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDropdownMenuItem {
    /**
     * @param {?} _renderer
     * @param {?} element
     */
    constructor(_renderer, element) {
        this._renderer = _renderer;
        this.element = element;
        this.isSelected = false;
        this.selectedClass = 'selected';
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        // We must use nativeElement as Angular doesn't have a way of reading class information.
        /** @type {?} */
        const element = (/** @type {?} */ (this.element.nativeElement));
        return element.classList.contains('disabled');
    }
    /**
     * @return {?}
     */
    get hasChildDropdown() {
        return !!this.childDropdownMenu;
    }
    /**
     * @return {?}
     */
    get isSelected() {
        return this._isSelected;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isSelected(value) {
        // Renderer is used to enable a dynamic class name.
        if (value) {
            this._renderer.addClass(this.element.nativeElement, this.selectedClass);
        }
        else {
            this._renderer.removeClass(this.element.nativeElement, this.selectedClass);
        }
    }
    /**
     * @return {?}
     */
    performClick() {
        // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
        this.element.nativeElement.click();
    }
}
FuiDropdownMenuItem.ɵfac = function FuiDropdownMenuItem_Factory(t) { return new (t || FuiDropdownMenuItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FuiDropdownMenuItem.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiDropdownMenuItem, selectors: [["", 8, "item"]], contentQueries: function FuiDropdownMenuItem_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiDropdownMenu, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childDropdownMenu = _t.first);
    } } });
/** @nocollapse */
FuiDropdownMenuItem.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FuiDropdownMenuItem.propDecorators = {
    childDropdownMenu: [{ type: ContentChild, args: [forwardRef((/**
                 * @return {?}
                 */
                () => FuiDropdownMenu)), { static: false },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDropdownMenuItem, [{
        type: Directive,
        args: [{
                // We must attach to every '.item' as Angular doesn't support > selectors.
                selector: '.item'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { childDropdownMenu: [{
            type: ContentChild,
            args: [forwardRef(( /**
                             * @return {?}
                             */() => FuiDropdownMenu)), { static: false }]
        }] }); })();
class FuiDropdownMenu extends FuiTransition {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(renderer, element, changeDetector) {
        super(renderer, element, changeDetector);
        // Initialise transition functionality.
        this._transitionController = new TransitionController(false);
        this.setTransitionController(this._transitionController);
        this.menuTransition = 'slide down';
        this.menuTransitionDuration = 200;
        this.menuAutoSelectFirst = false;
        this.menuSelectedItemClass = 'selected';
        // In case the dropdown menu is destroyed before it has a chance to be fully initialised.
        this._parentKeyDownListener = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set parentElement(value) {
        this._parentKeyDownListener = this._renderer
            .listen(value.nativeElement, 'keydown', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.onParentKeyDown(e)));
    }
    /**
     * @param {?} items
     * @return {?}
     */
    set items(items) {
        this._itemsQueryOverride = items;
    }
    /**
     * @return {?}
     */
    get service() {
        return this._service;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set service(value) {
        this._service = value;
        /** @type {?} */
        let previousIsOpen = this._service.isOpen;
        this._service.isOpenChange.subscribe((/**
         * @param {?} isOpen
         * @return {?}
         */
        (isOpen) => {
            if (isOpen !== previousIsOpen) {
                // Only run transitions if the open state has changed.
                this._transitionController.stopAll();
                this._transitionController.animate(new Transition(this.menuTransition, this.menuTransitionDuration, TransitionDirection.Either, (/**
                 * @return {?}
                 */
                () => this._service.isAnimating = false)));
            }
            if (!isOpen) {
                // Reset the item selections when a nested item is selected to avoid incosistent open states.
                if (this.selectedItems.length > 1) {
                    this.resetSelection();
                }
            }
            previousIsOpen = isOpen;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    get _itemsQuery() {
        return this._itemsQueryOverride || this._itemsQueryInternal;
    }
    // Get the list of items, ignoring those that are disabled.
    /**
     * @private
     * @return {?}
     */
    get _items() {
        return this._itemsQuery.filter((/**
         * @param {?} i
         * @return {?}
         */
        i => !i.isDisabled));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            if (this._service.autoCloseMode === DropdownAutoCloseType.ItemClick) {
                /** @type {?} */
                const target = (/** @type {?} */ (e.target));
                if (this._element.nativeElement.contains(target.closest('.item')) && !/input|textarea/i.test(target.tagName)) {
                    // Once an item is selected, we can close the entire dropdown.
                    this._service.setOpenState(false, true);
                }
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onParentKeyDown(e) {
        // Only the root dropdown (i.e. not nested dropdowns) is responsible for keeping track of the currently selected item.
        if (this._service && this._service.isOpen && !this._service.isNested) {
            // Stop document events like scrolling while open.
            /** @type {?} */
            const target = (/** @type {?} */ (e.target));
            if (!/input/i.test(target.tagName) &&
                [KeyCode.Escape, KeyCode.Enter, KeyCode.Up, KeyCode.Down, KeyCode.Left, KeyCode.Right].find((/**
                 * @param {?} kC
                 * @return {?}
                 */
                kC => kC === e.keyCode))) {
                e.preventDefault();
            }
            // Gets the top selected item from the stack.
            const [selected] = this.selectedItems.slice(-1);
            // Keeping track of the menu containing the currently selected element allows us to easily determine its siblings.
            /** @type {?} */
            let selectedContainer = this;
            if (this.selectedItems.length >= 2) {
                const [selectedParent] = this.selectedItems.slice(-2);
                selectedContainer = selectedParent.childDropdownMenu;
            }
            switch (e.keyCode) {
                // Escape : close the entire dropdown.
                case KeyCode.Escape: {
                    this._service.setOpenState(false);
                    break;
                }
                // Down : select the next item below the current one, or the 1st if none selected.
                case KeyCode.Down:
                // Up : select the next item above the current one, or the 1st if none selected.
                case KeyCode.Up: {
                    this.selectedItems.pop();
                    this.selectedItems.push(selectedContainer.updateSelection(selected, e.keyCode));
                    // Prevent default regardless of whether we are in an input, to stop jumping to the start or end of the query string.
                    e.preventDefault();
                    break;
                }
                // Enter : if the item doesn't contain a nested dropdown, 'click' it. Otherwise, fall through to 'Right' action.
                case KeyCode.Enter: {
                    if (selected && !selected.hasChildDropdown) {
                        selected.performClick();
                        break;
                    }
                }
                // falls through
                // Right : if the selected item contains a nested dropdown, open the dropdown & select the 1st item.
                case KeyCode.Right: {
                    if (selected && selected.hasChildDropdown) {
                        selected.childDropdownMenu.service.setOpenState(true);
                        this.selectedItems.push(selected.childDropdownMenu.updateSelection(selected, e.keyCode));
                    }
                    break;
                }
                // Left : if the selected item is in a nested dropdown, close it and select the containing item.
                case KeyCode.Left: {
                    if (this.selectedItems.length >= 2) {
                        this.selectedItems.pop();
                        const [selectedParent] = this.selectedItems.slice(-1);
                        selectedParent.childDropdownMenu.service.setOpenState(false);
                        selectedParent.isSelected = true;
                    }
                    break;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    resetSelection() {
        this.selectedItems = [];
        this._items.forEach((/**
         * @param {?} i
         * @return {?}
         */
        i => {
            i.selectedClass = this.menuSelectedItemClass;
            i.isSelected = false;
        }));
        if (this.menuAutoSelectFirst && this._items.length > 0) {
            // Autoselect 1st item if required & possible.
            this._items[0].isSelected = true;
            this.scrollToItem(this._items[0]);
            this.selectedItems.push(this._itemsQuery.first);
        }
    }
    // Determines the item to next be selected, based on the keyboard input & the currently selected item.
    /**
     * @param {?} selectedItem
     * @param {?} keyCode
     * @return {?}
     */
    updateSelection(selectedItem, keyCode) {
        if (selectedItem) {
            // Remove the selected status on the previously selected item.
            selectedItem.isSelected = false;
        }
        /** @type {?} */
        let selectedIndex = this._items
            .findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => i === selectedItem));
        /** @type {?} */
        let newSelection;
        switch (keyCode) {
            case KeyCode.Enter:
            case KeyCode.Right:
            case KeyCode.Down:
                selectedIndex += 1;
                break;
            case KeyCode.Up:
                if (selectedIndex === -1) {
                    // If none are selected, select the 1st item. Should this be `this.items.last - 1`?
                    selectedIndex = 0;
                    break;
                }
                selectedIndex -= 1;
                break;
        }
        // Select the item at the updated index. The || is to stop us selecting past the start or end of the item list.
        newSelection = this._items[selectedIndex] || selectedItem;
        if (newSelection) {
            // Set the selected status on the newly selected item.
            newSelection.isSelected = true;
            // Set the current scroll position to the location of the newly selected item.
            this.scrollToItem(newSelection);
        }
        return newSelection;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    scrollToItem(item) {
        /** @type {?} */
        const menu = this._element.nativeElement;
        /** @type {?} */
        const selectedRect = item.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const menuRect = menu.getBoundingClientRect();
        /** @type {?} */
        let scrollAmount = 0;
        if (selectedRect.bottom > menuRect.bottom) {
            scrollAmount = selectedRect.bottom - menuRect.bottom;
        }
        if (selectedRect.top < menuRect.top) {
            scrollAmount = selectedRect.top - menuRect.top;
        }
        menu.scrollTop += Math.round(scrollAmount);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.onItemsChanged();
        this._itemsQuery.changes.subscribe((/**
         * @return {?}
         */
        () => this.onItemsChanged()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._parentKeyDownListener();
    }
    /**
     * @private
     * @return {?}
     */
    onItemsChanged() {
        // We use `_items` rather than `items` in case one or more have become disabled.
        this.resetSelection();
    }
}
FuiDropdownMenu.ɵfac = function FuiDropdownMenu_Factory(t) { return new (t || FuiDropdownMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
FuiDropdownMenu.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiDropdownMenu, selectors: [["", "fuiDropdownMenu", ""]], contentQueries: function FuiDropdownMenu_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiDropdownMenuItem, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._itemsQueryInternal = _t);
    } }, hostBindings: function FuiDropdownMenu_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FuiDropdownMenu_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, inputs: { menuTransition: "menuTransition", menuTransitionDuration: "menuTransitionDuration", menuAutoSelectFirst: "menuAutoSelectFirst", menuSelectedItemClass: "menuSelectedItemClass" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FuiDropdownMenu.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiDropdownMenu.propDecorators = {
    menuTransition: [{ type: Input }],
    menuTransitionDuration: [{ type: Input }],
    menuAutoSelectFirst: [{ type: Input }],
    menuSelectedItemClass: [{ type: Input }],
    _itemsQueryInternal: [{ type: ContentChildren, args: [FuiDropdownMenuItem,] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDropdownMenu, [{
        type: Directive,
        args: [{
                selector: '[fuiDropdownMenu]'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { menuTransition: [{
            type: Input
        }], menuTransitionDuration: [{
            type: Input
        }], menuAutoSelectFirst: [{
            type: Input
        }], menuSelectedItemClass: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], _itemsQueryInternal: [{
            type: ContentChildren,
            args: [FuiDropdownMenuItem]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDropdown {
    /**
     * @param {?} _element
     */
    constructor(_element) {
        this._element = _element;
        this.service = new DropdownService();
        this.service.isOpenChange.subscribe((/**
         * @return {?}
         */
        () => {
            if (this.service.isOpen) {
                this._element.nativeElement.focus();
            }
        }));
    }
    /**
     * @return {?}
     */
    get isOpenChange() {
        return this.service.isOpenChange;
    }
    /**
     * @return {?}
     */
    get isActive() {
        // This is to ensure nested dropdowns don't get made bold.
        return this.service.isOpen && !this.service.isNested;
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this.service.isOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        // If we are opening the dropdown, we want to always open its parents.
        this.service.setOpenState(value, !!value);
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        return this.service.isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isDisabled(value) {
        this.service.setDisabledState(value);
    }
    /**
     * @return {?}
     */
    get autoClose() {
        return this.service.autoCloseMode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoClose(value) {
        this.service.autoCloseMode = value;
    }
    /**
     * @return {?}
     */
    get children() {
        // @ContentChildren includes the current element by default.
        return this._children.filter((/**
         * @param {?} c
         * @return {?}
         */
        c => c !== this));
    }
    /**
     * @return {?}
     */
    get tabIndex() {
        if (this.isDisabled || this.service.isNested) {
            // If disabled, remove from tabindex.
            return undefined;
        }
        if (this._tabIndex != undefined) {
            // If custom tabindex, default to that.
            return this._tabIndex;
        }
        // Otherwise, return default of 0.
        return 0;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this._menu) {
            throw new Error('You must set [fuiDropdownMenu] on the menu element.');
        }
        this._menu.service = this.service;
        this._menu.parentElement = this._element;
        this.childrenUpdated();
        this._children.changes
            .subscribe((/**
         * @return {?}
         */
        () => this.childrenUpdated()));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            this.service.toggleOpenState();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocusOut(e) {
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.externallyClose();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeypress(e) {
        // Block the keyboard event from being fired on parent dropdowns.
        if (!e.eventHandled) {
            if (e.keyCode === KeyCode.Enter) {
                e.eventHandled = true;
                this.service.setOpenState(true);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    childrenUpdated() {
        // Reregister child dropdowns each time the menu content changes.
        this.children
            .map((/**
         * @param {?} c
         * @return {?}
         */
        c => c.service))
            .forEach((/**
         * @param {?} s
         * @return {?}
         */
        s => this.service.registerChild(s)));
    }
    /**
     * @private
     * @return {?}
     */
    externallyClose() {
        if (this.service.autoCloseMode === DropdownAutoCloseType.ItemClick ||
            this.service.autoCloseMode === DropdownAutoCloseType.OutsideClick) {
            // No need to reflect in parent since they are also bound to document.
            this.service.setOpenState(false);
        }
    }
}
FuiDropdown.ɵfac = function FuiDropdown_Factory(t) { return new (t || FuiDropdown)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FuiDropdown.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiDropdown, selectors: [["", "fuiDropdown", ""]], contentQueries: function FuiDropdown_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiDropdownMenu, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiDropdown, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._menu = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._children = _t);
    } }, hostVars: 5, hostBindings: function FuiDropdown_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FuiDropdown_click_HostBindingHandler($event) { return ctx.onClick($event); })("focusout", function FuiDropdown_focusout_HostBindingHandler($event) { return ctx.onFocusOut($event); })("keypress", function FuiDropdown_keypress_HostBindingHandler($event) { return ctx.onKeypress($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive)("disabled", ctx.isDisabled);
    } }, inputs: { isOpen: "isOpen", isDisabled: "isDisabled", autoClose: "autoClose", _tabIndex: ["tabindex", "_tabIndex"] }, outputs: { isOpenChange: "isOpenChange" } });
/** @nocollapse */
FuiDropdown.ctorParameters = () => [
    { type: ElementRef }
];
FuiDropdown.propDecorators = {
    _menu: [{ type: ContentChild, args: [FuiDropdownMenu, { static: false },] }],
    isOpenChange: [{ type: Output }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    isOpen: [{ type: Input }],
    isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    autoClose: [{ type: Input }],
    _children: [{ type: ContentChildren, args: [FuiDropdown, { descendants: true },] }],
    _tabIndex: [{ type: Input, args: ['tabindex',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }],
    onKeypress: [{ type: HostListener, args: ['keypress', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDropdown, [{
        type: Directive,
        args: [{
                selector: '[fuiDropdown]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { isOpenChange: [{
            type: Output
        }], isActive: [{
            type: HostBinding,
            args: ['class.active']
        }], isOpen: [{
            type: Input
        }], isDisabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }, {
            type: Input
        }], autoClose: [{
            type: Input
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onFocusOut: [{
            type: HostListener,
            args: ['focusout', ['$event']]
        }], onKeypress: [{
            type: HostListener,
            args: ['keypress', ['$event']]
        }], _menu: [{
            type: ContentChild,
            args: [FuiDropdownMenu, { static: false }]
        }], _children: [{
            type: ContentChildren,
            args: [FuiDropdown, { descendants: true }]
        }], _tabIndex: [{
            type: Input,
            args: ['tabindex']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDropdownModule {
}
FuiDropdownModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiDropdownModule });
FuiDropdownModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiDropdownModule_Factory(t) { return new (t || FuiDropdownModule)(); }, imports: [[
            CommonModule,
            FuiTransitionModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiDropdownModule, { declarations: function () { return [FuiDropdown,
        FuiDropdownMenu,
        FuiDropdownMenuItem]; }, imports: function () { return [CommonModule,
        FuiTransitionModule]; }, exports: function () { return [FuiDropdown,
        FuiDropdownMenu,
        FuiDropdownMenuItem]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiDropdownModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FuiTransitionModule
                ],
                declarations: [
                    FuiDropdown,
                    FuiDropdownMenu,
                    FuiDropdownMenuItem
                ],
                exports: [
                    FuiDropdown,
                    FuiDropdownMenu,
                    FuiDropdownMenuItem
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Helper class to support method chaining when calling `FuiModalService.open(...)`.
/**
 * @template T, U, V
 */
class ActiveModal {
    /**
     * @param {?} instance
     * @param {?} componentRef
     */
    constructor(instance, componentRef) {
        this._config = instance;
        this._componentRef = componentRef;
        // Automatically destroy the modal component when it has been dismissed.
        this.component.onDismiss.subscribe((/**
         * @return {?}
         */
        () => this._componentRef.destroy()));
    }
    // Shorthand for direct access to the `FuiModal` instance.
    /**
     * @return {?}
     */
    get component() {
        return this._componentRef.instance;
    }
    // Registers a callback for when `onApprove` is fired.
    /**
     * @param {?} callback
     * @return {?}
     */
    onApprove(callback) {
        this.component.onApprove.subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => callback(res)));
        return this;
    }
    // Registers a callback for when `onDeny` is fired.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDeny(callback) {
        this.component.onDeny.subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => callback(res)));
        return this;
    }
    // Fires the approve event of the modal manually.
    /**
     * @param {?} result
     * @return {?}
     */
    approve(result) {
        this.component.approve(result);
    }
    // Fires the deny event of the modal manually.
    /**
     * @param {?} result
     * @return {?}
     */
    deny(result) {
        this.component.deny(result);
    }
    // Removes the modal component instantly, without transitions or firing any events.
    /**
     * @return {?}
     */
    destroy() {
        this._componentRef.destroy();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ModalSize = {
    Mini: (/** @type {?} */ ('mini')),
    Tiny: (/** @type {?} */ ('tiny')),
    Small: (/** @type {?} */ ('small')),
    Normal: (/** @type {?} */ ('normal')),
    Large: (/** @type {?} */ ('large'))
};
// Stores a basic set of configuration options for a modal.
/**
 * @template T, U, V
 */
class ModalConfig {
    /**
     * @param {?=} context
     * @param {?=} isClosable
     */
    constructor(context = undefined, isClosable = true) {
        // Initialise with default values.
        this.isClosable = isClosable;
        this.context = context;
        this.size = ModalSize.Normal;
        this.isFullScreen = false;
        this.isBasic = false;
        this.isInverted = false;
        this.isCentered = true;
        this.mustScroll = false;
        this.transition = 'scale';
        this.transitionDuration = 500;
    }
}
// Used when creating a modal from a `TemplateRef`.
/**
 * @template T, U, V
 */
class TemplateModalConfig extends ModalConfig {
    /**
     * @param {?} template
     * @param {?=} context
     * @param {?=} isClosable
     */
    constructor(template, context = undefined, isClosable = true) {
        super(context, isClosable);
        this.template = template;
    }
}
// Used when creating a modal from an existing component.
/**
 * @template T, U, V
 */
class ComponentModalConfig extends ModalConfig {
    /**
     * @param {?} component
     * @param {?=} context
     * @param {?=} isClosable
     */
    constructor(component, context = undefined, isClosable = true) {
        super(context, isClosable);
        this.component = component;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Used to pass ability to control a modal to a component.
/**
 * @template T, U
 */
class ModalControls {
    /**
     * @param {?} approve
     * @param {?} deny
     */
    constructor(approve, deny) {
        this.approve = approve;
        this.deny = deny;
    }
    // Use method here rather than arrow variables to make intellisense show they're methods.
    /**
     * @param {?} result
     * @return {?}
     */
    approve(result) {
    }
    /**
     * @param {?} result
     * @return {?}
     */
    deny(result) {
    }
}
// Injected into custom modal components, to allow control of the modal, and access to a context object.
/**
 * @template T, U, V
 */
class Modal extends ModalControls {
    /**
     * @param {?} controls
     * @param {?} context
     */
    constructor(controls, context) {
        // Instances of `ModalControls` are only created in the `FuiModal` constructor,
        // so we take an initialised instance rather than remaking one each time.
        super(controls.approve, controls.deny);
        this.context = context;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Shorthand for a modal template. Sets up ability to write: `<ng-template let-context let-modal="modal">...</ng-template>`
// We use an abstract class as ModalTemplate tends to be used within decorated properties, which means it needs to exist!
/**
 * @abstract
 * @template T, U, V
 */
class ModalTemplate extends TemplateRef {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
class FuiModal {
    /**
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} _componentFactory
     */
    constructor(_renderer, _element, _componentFactory) {
        this._renderer = _renderer;
        this._element = _element;
        this._componentFactory = _componentFactory;
        // Initialise with default configuration from `ModalConfig` (to avoid writing defaults twice).
        /** @type {?} */
        const config = new ModalConfig();
        this.loadConfig(config);
        // Event emitters for each of the possible modal outcomes.
        this.onApprove = new EventEmitter();
        this.onDeny = new EventEmitter();
        this.onDismiss = new EventEmitter();
        // Initialise controls with actions for the `approve` and `deny` cases.
        this.controls = new ModalControls((/**
         * @param {?} res
         * @return {?}
         */
        res => this.dismiss((/**
         * @return {?}
         */
        () => this.onApprove.emit(res)))), (/**
         * @param {?} res
         * @return {?}
         */
        res => this.dismiss((/**
         * @return {?}
         */
        () => this.onDeny.emit(res)))));
        // Internal variable initialisation.
        this.dimBackground = false;
        this._isClosing = false;
        this.transitionController = new TransitionController(false);
    }
    /**
     * @return {?}
     */
    get approve() {
        return this.controls.approve;
    }
    /**
     * @return {?}
     */
    get deny() {
        return this.controls.deny;
    }
    /**
     * @return {?}
     */
    get dynamicClasses() {
        /** @type {?} */
        const classes = {};
        if (this.size) {
            classes[this.size] = true;
        }
        return classes;
    }
    // Value to deny with when closing via `isClosable`.
    /**
     * @return {?}
     */
    get isFullScreen() {
        return this._isFullScreen;
    }
    /**
     * @param {?} fullScreen
     * @return {?}
     */
    set isFullScreen(fullScreen) {
        this._isFullScreen = Util.DOM.parseBooleanAttribute(fullScreen);
    }
    /**
     * @return {?}
     */
    get mustScroll() {
        return this._mustScroll;
    }
    /**
     * @param {?} mustScroll
     * @return {?}
     */
    set mustScroll(mustScroll) {
        this._mustScroll = mustScroll;
        // 'Cache' value in _mustAlwaysScroll so that if `true`, _mustScroll isn't ever auto-updated.
        this._mustAlwaysScroll = mustScroll;
        this.updateScroll();
    }
    /**
     * @return {?}
     */
    get isInverted() {
        return this._isInverted;
    }
    /**
     * @param {?} inverted
     * @return {?}
     */
    set isInverted(inverted) {
        this._isInverted = Util.DOM.parseBooleanAttribute(inverted);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Transition the modal to be visible.
        this.transitionController.animate(new Transition(this.transition, this.transitionDuration, TransitionDirection.In));
        setTimeout((/**
         * @return {?}
         */
        () => this.dimBackground = true));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Move the modal to the document body to ensure correct scrolling.
        this._originalContainer = this._element.nativeElement.parentNode;
        (/** @type {?} */ (document.querySelector('body'))).appendChild(this._element.nativeElement);
        // Remove the #templateSibling element from the DOM to fix bottom border styles.
        /** @type {?} */
        const templateElement = (/** @type {?} */ (this.templateSibling.element.nativeElement));
        if (templateElement.parentNode) {
            templateElement.parentNode.removeChild(templateElement);
        }
        /** @type {?} */
        const element = (/** @type {?} */ (this._modalElement.nativeElement));
        setTimeout((/**
         * @return {?}
         */
        () => this.updateScroll()));
        // Focus any element with [autofocus] attribute.
        /** @type {?} */
        const autoFocus = (/** @type {?} */ (element.querySelector('[autofocus]')));
        if (autoFocus) {
            // Autofocus after the browser has had time to process other event handlers.
            setTimeout((/**
             * @return {?}
             */
            () => autoFocus.focus()), 10);
            // Try to focus again when the modal has opened so that autofocus works in IE11.
            setTimeout((/**
             * @return {?}
             */
            () => autoFocus.focus()), this.transitionDuration);
        }
    }
    // Updates the modal with the specified configuration.
    /**
     * @template V
     * @param {?} config
     * @return {?}
     */
    loadConfig(config) {
        this.isClosable = config.isClosable;
        this.closeResult = config.closeResult;
        this.size = config.size;
        this.isFullScreen = config.isFullScreen;
        this.isBasic = config.isBasic;
        this.isInverted = config.isInverted;
        this.isCentered = config.isCentered;
        this.mustScroll = config.mustScroll;
        this.transition = config.transition;
        this.transitionDuration = config.transitionDuration;
    }
    // Closes the modal with a 'deny' outcome, using the specified default reason.
    /**
     * @return {?}
     */
    close() {
        if (this.isClosable) {
            // If we are allowed to close, fire the deny result with the default value.
            this.deny(this.closeResult);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        // Makes sense here, as the modal shouldn't be attached to any DOM element.
        e.stopPropagation();
    }
    // Document listener is fine here because nobody will have enough modals open.
    /**
     * @param {?} e
     * @return {?}
     */
    onDocumentKeyUp(e) {
        if (e.keyCode === KeyCode.Escape) {
            // Close automatically covers case of `!isClosable`, so check not needed.
            this.close();
        }
    }
    /**
     * @return {?}
     */
    onDocumentResize() {
        this.updateScroll();
    }
    // Dismisses the modal with a transition, firing the callback after the modal has finished transitioning.
    /**
     * @private
     * @param {?=} callback
     * @return {?}
     */
    dismiss(callback = (/**
     * @return {?}
     */
    () => {
    })) {
        // If we aren't currently closing,
        if (!this._isClosing) {
            this._isClosing = true;
            // Transition the modal to be invisible.
            this.dimBackground = false;
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.transition, this.transitionDuration, TransitionDirection.Out, (/**
             * @return {?}
             */
            () => {
                // When done, move the modal back to its original location, emit a dismiss event, and fire the callback.
                if (this._originalContainer) {
                    this._originalContainer.appendChild(this._element.nativeElement);
                }
                this.onDismiss.emit();
                callback();
            })));
        }
    }
    // Decides whether the modal needs to reposition to allow scrolling.
    /**
     * @private
     * @return {?}
     */
    updateScroll() {
        // _mustAlwaysScroll works by stopping _mustScroll from being automatically updated, so it stays `true`.
        if (!this._mustAlwaysScroll && this._modalElement) {
            // Fomantic UI modal margin and dimmer padding are 1rem, which is relative to the global font size, so for compatibility:
            /** @type {?} */
            const fontSize = parseFloat(window.getComputedStyle(document.documentElement).getPropertyValue('font-size'));
            /** @type {?} */
            const margin = fontSize * 2;
            /** @type {?} */
            const element = (/** @type {?} */ (this._modalElement.nativeElement));
            // The modal must scroll if the window height is smaller than the modal height + both margins.
            this._mustScroll = window.innerHeight < element.clientHeight + margin * 2;
        }
    }
}
FuiModal.ɵfac = function FuiModal_Factory(t) { return new (t || FuiModal)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(FuiComponentFactory)); };
FuiModal.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiModal, selectors: [["fui-modal"]], viewQuery: function FuiModal_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c6, true, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c8, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateSibling = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._modalElement = _t.first);
    } }, hostBindings: function FuiModal_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup", function FuiModal_keyup_HostBindingHandler($event) { return ctx.onDocumentKeyUp($event); }, false, ɵngcc0.ɵɵresolveDocument)("resize", function FuiModal_resize_HostBindingHandler() { return ctx.onDocumentResize(); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, inputs: { isFullScreen: "isFullScreen", mustScroll: "mustScroll", isInverted: "isInverted", isClosable: "isClosable", closeResult: "closeResult", size: "size", isBasic: "isBasic", isCentered: "isCentered", transition: "transition", transitionDuration: "transitionDuration" }, outputs: { onApprove: "approved", onDeny: "denied", onDismiss: "dismissed" }, ngContentSelectors: _c0, decls: 7, vars: 20, consts: [[3, "ngClass", "isDimmed", "transitionDuration", "isDimmedChange", "click"], [1, "ui", "modal", 3, "fuiTransition", "ngClass", "click"], ["modal", ""], ["class", "close icon", 3, "click", 4, "ngIf"], ["templateSibling", ""], [1, "close", "icon", 3, "click"]], template: function FuiModal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "fui-modal-dimmer", 0);
        ɵngcc0.ɵɵlistener("isDimmedChange", function FuiModal_Template_fui_modal_dimmer_isDimmedChange_0_listener($event) { return ctx.dimBackground = $event; })("click", function FuiModal_Template_fui_modal_dimmer_click_0_listener() { return ctx.close(); });
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵlistener("click", function FuiModal_Template_div_click_1_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵtemplate(3, FuiModal_i_3_Template, 1, 0, "i", 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelement(5, "div", null, 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("inverted", ctx.isInverted);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(18, _c9, !ctx.isCentered))("isDimmed", ctx.dimBackground)("transitionDuration", ctx.transitionDuration);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.transitionController == null ? null : ctx.transitionController.isVisible)("fullscreen", ctx.isFullScreen)("basic", ctx.isBasic)("scrolling", ctx.mustScroll)("inverted", ctx.isInverted);
        ɵngcc0.ɵɵproperty("fuiTransition", ctx.transitionController)("ngClass", ctx.dynamicClasses);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isClosable);
    } }, directives: function () { return [FuiModalDimmer, ɵngcc1.NgClass, FuiTransition, ɵngcc1.NgIf]; }, styles: [""] });
/** @nocollapse */
FuiModal.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: FuiComponentFactory }
];
FuiModal.propDecorators = {
    isClosable: [{ type: Input }],
    closeResult: [{ type: Input }],
    onApprove: [{ type: Output, args: ['approved',] }],
    onDeny: [{ type: Output, args: ['denied',] }],
    onDismiss: [{ type: Output, args: ['dismissed',] }],
    size: [{ type: Input }],
    isCentered: [{ type: Input }],
    isBasic: [{ type: Input }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: true },] }],
    _modalElement: [{ type: ViewChild, args: ['modal', { static: false },] }],
    isFullScreen: [{ type: Input }],
    mustScroll: [{ type: Input }],
    isInverted: [{ type: Input }],
    onDocumentKeyUp: [{ type: HostListener, args: ['document:keyup', ['$event'],] }],
    onDocumentResize: [{ type: HostListener, args: ['window:resize',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiModal, [{
        type: Component,
        args: [{
                selector: 'fui-modal',
                template: `
<!-- Page dimmer for modal background. -->
<fui-modal-dimmer [ngClass]="{'top aligned': !isCentered}"
                  [class.inverted]="isInverted"
                  [(isDimmed)]="dimBackground"
                  [transitionDuration]="transitionDuration"
                  (click)="close()">

    <!-- Modal component, with transition component attached -->
    <div class="ui modal"
         [fuiTransition]="transitionController"
         [class.active]="transitionController?.isVisible"
         [class.fullscreen]="isFullScreen"
         [class.basic]="isBasic"
         [class.scrolling]="mustScroll"
         [class.inverted]="isInverted"
         [ngClass]="dynamicClasses"
         (click)="onClick($event)"
         #modal>

        <!-- Configurable close icon -->
        <i class="close icon" *ngIf="isClosable" (click)="close()"></i>
        <!-- <ng-content> so that <fui-modal> can be used as a normal component. -->
        <ng-content></ng-content>
        <!-- @ViewChild reference so we can insert elements beside this div. -->
        <div #templateSibling></div>
    </div>
</fui-modal-dimmer>
`,
                styles: [``]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: FuiComponentFactory }]; }, { onApprove: [{
            type: Output,
            args: ['approved']
        }], onDeny: [{
            type: Output,
            args: ['denied']
        }], onDismiss: [{
            type: Output,
            args: ['dismissed']
        }], isFullScreen: [{
            type: Input
        }], mustScroll: [{
            type: Input
        }], isInverted: [{
            type: Input
        }], isClosable: [{
            type: Input
        }], closeResult: [{
            type: Input
        }], size: [{
            type: Input
        }], isBasic: [{
            type: Input
        }], isCentered: [{
            type: Input
        }], transition: [{
            type: Input
        }], transitionDuration: [{
            type: Input
        }], onDocumentKeyUp: [{
            type: HostListener,
            args: ['document:keyup', ['$event']]
        }], onDocumentResize: [{
            type: HostListener,
            args: ['window:resize']
        }], templateSibling: [{
            type: ViewChild,
            args: ['templateSibling', { read: ViewContainerRef, static: true }]
        }], _modalElement: [{
            type: ViewChild,
            args: ['modal', { static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiModalService {
    /**
     * @param {?} _componentFactory
     */
    constructor(_componentFactory) {
        this._componentFactory = _componentFactory;
    }
    /**
     * @template T, U, V
     * @param {?} modal
     * @return {?}
     */
    open(modal) {
        // Generate the modal component to be shown.
        /** @type {?} */
        const componentRef = this._componentFactory.createComponent(FuiModal);
        // Shorthand for the created modal component instance.
        /** @type {?} */
        const modalComponent = componentRef.instance;
        if (modal instanceof TemplateModalConfig) {
            // Inject the template into the view.
            this._componentFactory.createView(modalComponent.templateSibling, modal.template, {
                // `let-context`
                $implicit: modal.context,
                // `let-modal="modal"`
                modal: componentRef.instance.controls
            });
        }
        else if (modal instanceof ComponentModalConfig) {
            // Generate the component to be used as the modal content,
            // injecting an instance of `Modal` to be used in the component constructor.
            /** @type {?} */
            const contentComponentRef = this._componentFactory.createComponent(modal.component, [
                {
                    provide: Modal,
                    useValue: new Modal(modalComponent.controls, modal.context)
                }
            ]);
            // Insert the new component into the content of the modal.
            this._componentFactory.attachToView(contentComponentRef, modalComponent.templateSibling);
            // Shorthand for access to the content component's DOM element.
            /** @type {?} */
            const contentElement = (/** @type {?} */ (contentComponentRef.location.nativeElement));
            // Move all of the DOM elements inside the component to the main modal element.
            // This is done so that CSS classes apply correctly. It does stop any custom styles from working however,
            // so other ways may have to be investigated.
            while (contentElement.hasChildNodes() && contentElement.parentElement && contentElement.firstChild) {
                contentElement.parentElement.appendChild(contentElement.removeChild(contentElement.firstChild));
            }
            // Remove the generated component's 'empty shell' from the DOM.
            this._componentFactory.detachFromDocument(contentComponentRef);
        }
        // Attach the new modal component to the application.
        // The component will move itself to the document body for correctl styling.
        this._componentFactory.attachToApplication(componentRef);
        // Initialise the generated modal with the provided config.
        modalComponent.loadConfig(modal);
        // Return an instance of an `ActiveModal`, so the user can control the new modal.
        return new ActiveModal(modal, componentRef);
    }
}
FuiModalService.ɵfac = function FuiModalService_Factory(t) { return new (t || FuiModalService)(ɵngcc0.ɵɵinject(FuiComponentFactory)); };
FuiModalService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FuiModalService, factory: FuiModalService.ɵfac });
/** @nocollapse */
FuiModalService.ctorParameters = () => [
    { type: FuiComponentFactory }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiModalService, [{
        type: Injectable
    }], function () { return [{ type: FuiComponentFactory }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiModalDimmer extends FuiDimmer {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(renderer, element, changeDetector) {
        super(renderer, element, changeDetector);
        this.hasClasses = true;
        this.isClickable = false;
    }
}
FuiModalDimmer.ɵfac = function FuiModalDimmer_Factory(t) { return new (t || FuiModalDimmer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
FuiModalDimmer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiModalDimmer, selectors: [["fui-modal-dimmer"]], hostVars: 4, hostBindings: function FuiModalDimmer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("page", ctx.hasClasses)("modals", ctx.hasClasses);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function FuiModalDimmer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [".ui.dimmer[_nghost-%COMP%]:not(.hidden) {\n            transition: none;\n            overflow-y: auto;\n            display: flex !important;\n        }"] });
/** @nocollapse */
FuiModalDimmer.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiModalDimmer.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.page',] }, { type: HostBinding, args: ['class.modals',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiModalDimmer, [{
        type: Component,
        args: [{
                selector: 'fui-modal-dimmer',
                template: `<ng-content></ng-content>`,
                styles: [`
        :host.ui.dimmer:not(.hidden) {
            transition: none;
            overflow-y: auto;
            display: flex !important;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { hasClasses: [{
            type: HostBinding,
            args: ['class.page']
        }, {
            type: HostBinding,
            args: ['class.modals']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiModalModule {
}
FuiModalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiModalModule });
FuiModalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiModalModule_Factory(t) { return new (t || FuiModalModule)(); }, providers: [
        FuiModalService
    ], imports: [[
            CommonModule,
            FuiDimmerModule,
            FuiTransitionModule,
            FuiUtilityModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiModalModule, { declarations: function () { return [FuiModal,
        FuiModalDimmer]; }, imports: function () { return [CommonModule,
        FuiDimmerModule,
        FuiTransitionModule,
        FuiUtilityModule]; }, exports: function () { return [FuiModal]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiModalModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FuiDimmerModule,
                    FuiTransitionModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiModal,
                    FuiModalDimmer
                ],
                exports: [
                    FuiModal
                ],
                providers: [
                    FuiModalService
                ],
                entryComponents: [
                    FuiModal
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiRating {
    constructor() {
        this.hoveredIndex = -1;
        this.value = 0;
        this.valueChange = new EventEmitter();
        this.type = 'star';
        this.maximum = 5;
        this.isReadonly = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get icons() {
        // tslint:disable-next-line:prefer-literal
        return new Array(this.maximum);
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value;
    }
    /**
     * @return {?}
     */
    get maximum() {
        return this._maximum;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maximum(value) {
        this._maximum = +value;
    }
    /**
     * @param {?} i
     * @return {?}
     */
    onClick(i) {
        if (!this.isReadonly) {
            this.value = i + 1;
            this.valueChange.emit(this.value);
        }
    }
    /**
     * @param {?} i
     * @return {?}
     */
    onMouseover(i) {
        this.hoveredIndex = i;
    }
    /**
     * @return {?}
     */
    onMouseout() {
        this.hoveredIndex = -1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
}
FuiRating.ɵfac = function FuiRating_Factory(t) { return new (t || FuiRating)(); };
FuiRating.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiRating, selectors: [["fui-rating"]], hostVars: 6, hostBindings: function FuiRating_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseout", function FuiRating_mouseout_HostBindingHandler() { return ctx.onMouseout(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("read-only", ctx.isReadonly)("ui", ctx.hasClasses)("rating", ctx.hasClasses);
    } }, inputs: { type: "type", maximum: "maximum", isReadonly: "isReadonly" }, outputs: { valueChange: "valueChange" }, decls: 1, vars: 1, consts: [[3, "class", "selected", "active", "mouseover", "click", 4, "ngFor", "ngForOf"], [3, "mouseover", "click"]], template: function FuiRating_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FuiRating_i_0_Template, 1, 7, "i", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.icons);
    } }, directives: [ɵngcc1.NgForOf], styles: [".read-only[_nghost-%COMP%]   .icon[_ngcontent-%COMP%] {\n    cursor: auto\n}"] });
/** @nocollapse */
FuiRating.ctorParameters = () => [];
FuiRating.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.rating',] }],
    valueChange: [{ type: Output }],
    isReadonly: [{ type: HostBinding, args: ['class.read-only',] }, { type: Input }],
    type: [{ type: Input }],
    maximum: [{ type: Input }],
    onMouseout: [{ type: HostListener, args: ['mouseout',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiRating, [{
        type: Component,
        args: [{
                selector: 'fui-rating',
                // tslint:disable-next-line
                template: `<i *ngFor="let icon of icons; let i = index" class="icon {{type}}" (mouseover)="onMouseover(i)" (click)="onClick(i)" [class.selected]="hoveredIndex >= i && !isReadonly" [class.active]="value > i"></i>`,
                styles: [`
:host.read-only .icon {
    cursor: auto
}
`]
            }]
    }], function () { return []; }, { valueChange: [{
            type: Output
        }], type: [{
            type: Input
        }], maximum: [{
            type: Input
        }], isReadonly: [{
            type: HostBinding,
            args: ['class.read-only']
        }, {
            type: Input
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.rating']
        }], onMouseout: [{
            type: HostListener,
            args: ['mouseout']
        }] }); })();
class FuiRatingValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiRatingValueAccessor.ɵfac = function FuiRatingValueAccessor_Factory(t) { return new (t || FuiRatingValueAccessor)(ɵngcc0.ɵɵdirectiveInject(FuiRating)); };
FuiRatingValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiRatingValueAccessor, selectors: [["fui-rating"]], hostBindings: function FuiRatingValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("valueChange", function FuiRatingValueAccessor_valueChange_HostBindingHandler($event) { return ctx.onChange($event); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([customValueAccessorFactory(FuiRatingValueAccessor)]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FuiRatingValueAccessor.ctorParameters = () => [
    { type: FuiRating }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiRatingValueAccessor, [{
        type: Directive,
        args: [{
                selector: 'fui-rating',
                host: { '(valueChange)': 'onChange($event)' },
                providers: [customValueAccessorFactory(FuiRatingValueAccessor)]
            }]
    }], function () { return [{ type: FuiRating }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiRatingModule {
}
FuiRatingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiRatingModule });
FuiRatingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiRatingModule_Factory(t) { return new (t || FuiRatingModule)(); }, imports: [[
            FormsModule,
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiRatingModule, { declarations: function () { return [FuiRating,
        FuiRatingValueAccessor]; }, imports: function () { return [FormsModule,
        CommonModule]; }, exports: function () { return [FuiRating,
        FuiRatingValueAccessor]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiRatingModule, [{
        type: NgModule,
        args: [{
                imports: [
                    FormsModule,
                    CommonModule
                ],
                declarations: [
                    FuiRating,
                    FuiRatingValueAccessor
                ],
                exports: [
                    FuiRating,
                    FuiRatingValueAccessor
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiSearchResult {
    /**
     * @param {?} componentFactory
     */
    constructor(componentFactory) {
        this.componentFactory = componentFactory;
        this.hasClasses = true;
        // By default we make this function return an empty string, for the brief moment when it isn't displaying the correct label.
        this.formatter = (/**
         * @param {?} value
         * @return {?}
         */
        value => '');
    }
    /**
     * @return {?}
     */
    get template() {
        return this._template;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    set template(template) {
        this._template = template;
        if (this.template) {
            this.componentFactory.createView(this.templateSibling, this.template, {
                $implicit: this.value,
                query: this.query
            });
        }
    }
}
FuiSearchResult.ɵfac = function FuiSearchResult_Factory(t) { return new (t || FuiSearchResult)(ɵngcc0.ɵɵdirectiveInject(FuiComponentFactory)); };
FuiSearchResult.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiSearchResult, selectors: [["fui-search-result"]], viewQuery: function FuiSearchResult_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c6, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateSibling = _t.first);
    } }, hostVars: 2, hostBindings: function FuiSearchResult_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("result", ctx.hasClasses);
    } }, inputs: { formatter: "formatter", template: "template", value: "value", query: "query" }, decls: 3, vars: 1, consts: [["templateSibling", ""], [3, "innerHTML", 4, "ngIf"], [3, "innerHTML"]], template: function FuiSearchResult_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", null, 0);
        ɵngcc0.ɵɵtemplate(2, FuiSearchResult_span_2_Template, 1, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.template);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/** @nocollapse */
FuiSearchResult.ctorParameters = () => [
    { type: FuiComponentFactory }
];
FuiSearchResult.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.result',] }],
    value: [{ type: Input }],
    query: [{ type: Input }],
    formatter: [{ type: Input }],
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
    template: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSearchResult, [{
        type: Component,
        args: [{
                selector: 'fui-search-result',
                template: `
<span #templateSibling></span>
<span *ngIf="!template" [innerHTML]="formatter(value, query)"></span>
`
            }]
    }], function () { return [{ type: FuiComponentFactory }]; }, { hasClasses: [{
            type: HostBinding,
            args: ['class.result']
        }], formatter: [{
            type: Input
        }], template: [{
            type: Input
        }], value: [{
            type: Input
        }], query: [{
            type: Input
        }], templateSibling: [{
            type: ViewChild,
            args: ['templateSibling', { read: ViewContainerRef, static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
class SearchService {
    /**
     * @param {?=} allowEmptyQuery
     */
    constructor(allowEmptyQuery = false) {
        this._options = [];
        this.optionsFilter = (/**
         * @param {?} os
         * @param {?} q
         * @return {?}
         */
        (os, q) => {
            // Convert the query string to a RegExp.
            /** @type {?} */
            const regex = this.toRegex(this._query);
            if (regex instanceof RegExp) {
                // Only update the results if the query was valid regex.
                // This avoids the results suddenly becoming empty if an invalid regex string is inputted.
                return os
                    // Filter on the options with a string match on the field we are testing.
                    .filter((/**
                 * @param {?} o
                 * @return {?}
                 */
                o => Util.Object.readValue(o, this._optionsField)
                    .toString()
                    .match(regex)));
            }
            // Don't update since it wasn't a valid regex.
            return false;
        });
        // Set default values and reset.
        this.allowEmptyQuery = allowEmptyQuery;
        this.searchDelay = 0;
        this.reset();
    }
    /**
     * @return {?}
     */
    get hasItemLookup() {
        return !!this.optionsLookup && this.optionsLookup.length === 2;
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        this._options = options || [];
        // We cannot use both local & remote options simultaneously.
        this._optionsLookup = undefined;
        // Reset entire service with new options.
        this.reset();
    }
    /**
     * @return {?}
     */
    get optionsLookup() {
        return this._optionsLookup;
    }
    /**
     * @param {?} lookupFn
     * @return {?}
     */
    set optionsLookup(lookupFn) {
        this._optionsLookup = lookupFn;
        // As before, cannot use local & remote options simultaneously.
        this._options = [];
        this.reset();
    }
    /**
     * @return {?}
     */
    get optionsField() {
        return this._optionsField;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    set optionsField(field) {
        this._optionsField = field;
        // We need to reset otherwise we would now be showing invalid search results.
        this.reset();
    }
    /**
     * @return {?}
     */
    get results() {
        return this._results;
    }
    /**
     * @return {?}
     */
    get query() {
        return this._query;
    }
    /**
     * @return {?}
     */
    get isSearching() {
        return this._isSearching;
    }
    // Updates the query after the specified search delay.
    /**
     * @param {?} query
     * @param {?=} callback
     * @return {?}
     */
    updateQueryDelayed(query, callback = (/**
     * @return {?}
     */
    () => {
    })) {
        this._query = query;
        clearTimeout(this._searchDelayTimeout);
        this._searchDelayTimeout = window.setTimeout((/**
         * @return {?}
         */
        () => {
            this.updateQuery(query, callback);
        }), this.searchDelay);
    }
    // Updates the current search query.
    /**
     * @param {?} query
     * @param {?=} callback
     * @return {?}
     */
    updateQuery(query, callback = (/**
     * @return {?}
     */
    () => {
    })) {
        this._query = query;
        if (this._query === '' && !this.allowEmptyQuery) {
            // Don't update if the new query is empty (and we don't allow empty queries).
            // Don't reset so that when animating closed we don't get a judder.
            return callback();
        }
        if (this._resultsCache.hasOwnProperty(this._query)) {
            // If the query is already cached, make use of it.
            this._results = this._resultsCache[this._query];
            return callback();
        }
        if (this._optionsLookup) {
            this._isSearching = true;
            // Call the options lookup without a this context.
            /** @type {?} */
            const queryLookup = (/** @type {?} */ (this._optionsLookup.call(undefined, this._query)));
            queryLookup
                .then((/**
             * @param {?} results
             * @return {?}
             */
            results => {
                this._isSearching = false;
                this.updateResults(results);
                return callback();
            }))
                .catch((/**
             * @param {?} error
             * @return {?}
             */
            error => {
                // Unset 'loading' state, and throw the returned error without updating the results.
                this._isSearching = false;
                return callback(error);
            }));
            return;
        }
        /** @type {?} */
        const filtered = this.optionsFilter.call(undefined, this._options, this._query);
        if (filtered) {
            this.updateResults(filtered);
        }
        return callback();
    }
    // tslint:disable-next-line:promise-function-async
    /**
     * @param {?} initial
     * @return {?}
     */
    initialLookup(initial) {
        if (initial instanceof Array) {
            return (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this._optionsLookup)))))(undefined, initial)));
        }
        return (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this._optionsLookup)))))(undefined, initial)));
    }
    // Generates HTML for highlighted match text.
    /**
     * @param {?} text
     * @param {?} query
     * @return {?}
     */
    highlightMatches(text, query) {
        /** @type {?} */
        const regex = this.toRegex(query);
        if (regex instanceof RegExp) {
            return text.replace(regex, (/**
             * @param {?} match
             * @return {?}
             */
            match => `<b>${match}</b>`));
        }
        return text;
    }
    // Updates & caches the new set of results.
    /**
     * @private
     * @param {?} results
     * @return {?}
     */
    updateResults(results) {
        this._resultsCache[this._query] = results;
        this._results = results;
    }
    // Converts a query string to regex without throwing an error.
    /**
     * @private
     * @param {?} query
     * @return {?}
     */
    toRegex(query) {
        try {
            return new RegExp(query, 'i');
        }
        catch (e) {
            return query;
        }
    }
    // Resets the search back to a pristine state.
    /**
     * @private
     * @return {?}
     */
    reset() {
        this._results = [];
        this._resultsCache = {};
        this._isSearching = false;
        this.updateQuery('');
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiSearch {
    /**
     * @param {?} _element
     * @param {?} renderer
     * @param {?} _localizationService
     */
    constructor(_element, renderer, _localizationService) {
        this._element = _element;
        this._localizationService = _localizationService;
        this.dropdownService = new DropdownService();
        this.searchService = new SearchService();
        this.onLocaleUpdate();
        this._localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        () => this.onLocaleUpdate()));
        this.hasClasses = true;
        this.tabindex = 0;
        this.hasIcon = true;
        this.retainSelectedResult = true;
        this.searchDelay = 200;
        this.maxResults = 7;
        this.onResultSelected = new EventEmitter();
        this.transition = 'scale';
        this.transitionDuration = 200;
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this.dropdownService.isOpen;
    }
    /**
     * @return {?}
     */
    get query() {
        return this.searchService.query;
    }
    /**
     * @param {?} query
     * @return {?}
     */
    set query(query) {
        this.selectedResult = undefined;
        // Initialise a delayed search.
        this.searchService.updateQueryDelayed(query, (/**
         * @return {?}
         */
        () => {
            // Set the results open state depending on whether a query has been entered.
            return this.dropdownService.setOpenState(this.searchService.query.length > 0);
        }));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        if (options) {
            this.searchService.options = options;
        }
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    set optionsFilter(filter) {
        if (filter) {
            this.searchService.optionsFilter = filter;
        }
    }
    /**
     * @param {?} lookupFn
     * @return {?}
     */
    set optionsLookup(lookupFn) {
        this.searchService.optionsLookup = lookupFn;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    set optionsField(field) {
        this.searchService.optionsField = field;
    }
    /**
     * @param {?} delay
     * @return {?}
     */
    set searchDelay(delay) {
        this.searchService.searchDelay = delay;
    }
    /**
     * @return {?}
     */
    get isSearching() {
        return this.searchService.isSearching;
    }
    /**
     * @return {?}
     */
    get results() {
        return this.searchService.results.slice(0, this.maxResults);
    }
    // Gets & sets the placeholder text displayed inside the text input.
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder || this.localeValues.placeholder;
    }
    /**
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = placeholder;
    }
    /**
     * @return {?}
     */
    get localeValues() {
        return this._localizationService.override(this._localeValues, this.localeOverrides);
    }
    /**
     * @return {?}
     */
    get resultFormatter() {
        if (this._resultFormatter) {
            return this._resultFormatter;
        }
        else if (this.searchService.optionsLookup) {
            return (/**
             * @param {?} r
             * @return {?}
             */
            r => this.readValue(r));
        }
        else {
            return (/**
             * @param {?} r
             * @param {?} q
             * @return {?}
             */
            (r, q) => this.searchService.highlightMatches(this.readValue(r), q));
        }
    }
    /**
     * @param {?} formatter
     * @return {?}
     */
    set resultFormatter(formatter) {
        this._resultFormatter = formatter;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._menu.service = this.dropdownService;
    }
    // Selects a result.
    /**
     * @param {?} result
     * @return {?}
     */
    select(result) {
        this.onResultSelected.emit(result);
        this.dropdownService.setOpenState(false);
        if (this.retainSelectedResult) {
            this.selectedResult = result;
            this.searchService.updateQuery(this.readValue(result));
        }
        else {
            this.searchService.updateQuery('');
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        this.open();
    }
    /**
     * @return {?}
     */
    onFocusIn() {
        if (!this.dropdownService.isAnimating) {
            this.open();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocusOut(e) {
        console.log(e);
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.dropdownService.setOpenState(false);
        }
    }
    // Reads the specified field from an item.
    /**
     * @param {?} object
     * @return {?}
     */
    readValue(object) {
        return Util.Object.readValue(object, this.searchService.optionsField);
    }
    /**
     * @private
     * @return {?}
     */
    onLocaleUpdate() {
        this._localeValues = this._localizationService.get().search;
    }
    /**
     * @private
     * @return {?}
     */
    open() {
        if (this.searchService.query.length > 0) {
            // Only open on click when there is a query entered.
            this.dropdownService.setOpenState(true);
        }
    }
}
FuiSearch.ɵfac = function FuiSearch_Factory(t) { return new (t || FuiSearch)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(FuiLocalizationService)); };
FuiSearch.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiSearch, selectors: [["fui-search"]], viewQuery: function FuiSearch_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(FuiDropdownMenu, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._menu = _t.first);
    } }, hostVars: 9, hostBindings: function FuiSearch_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function FuiSearch_focusin_HostBindingHandler() { return ctx.onFocusIn(); })("focusout", function FuiSearch_focusout_HostBindingHandler($event) { return ctx.onFocusOut($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("ui", ctx.hasClasses)("search", ctx.hasClasses)("active", ctx.isActive)("loading", ctx.isSearching);
    } }, inputs: { hasIcon: "hasIcon", retainSelectedResult: "retainSelectedResult", searchDelay: "searchDelay", maxResults: "maxResults", transition: "transition", transitionDuration: "transitionDuration", options: "options", optionsFilter: "optionsFilter", optionsLookup: "optionsLookup", optionsField: "optionsField", placeholder: "placeholder", resultFormatter: "resultFormatter", resultTemplate: "resultTemplate" }, outputs: { onResultSelected: "resultSelected" }, decls: 6, vars: 9, consts: [[1, "ui", "input", 3, "click"], ["type", "text", "autocomplete", "off", 1, "prompt", 3, "ngModel", "ngModelChange"], ["class", "search icon", 4, "ngIf"], ["fuiDropdownMenu", "", "menuSelectedItemClass", "active", 1, "results", 3, "menuTransition", "menuTransitionDuration"], ["class", "item", 3, "value", "query", "formatter", "template", "click", 4, "ngFor", "ngForOf"], ["class", "message empty", 4, "ngIf"], [1, "search", "icon"], [1, "item", 3, "value", "query", "formatter", "template", "click"], [1, "message", "empty"], [1, "header"], [1, "description"]], template: function FuiSearch_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function FuiSearch_Template_div_click_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementStart(1, "input", 1);
        ɵngcc0.ɵɵlistener("ngModelChange", function FuiSearch_Template_input_ngModelChange_1_listener($event) { return ctx.query = $event; });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, FuiSearch_i_2_Template, 1, 0, "i", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, FuiSearch_fui_search_result_4_Template, 1, 4, "fui-search-result", 4);
        ɵngcc0.ɵɵtemplate(5, FuiSearch_div_5_Template, 5, 2, "div", 5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("icon", ctx.hasIcon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngModel", ctx.query);
        ɵngcc0.ɵɵattribute("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasIcon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("menuTransition", ctx.transition)("menuTransitionDuration", ctx.transitionDuration);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.results.length == 0);
    } }, directives: [ɵngcc2.DefaultValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel, ɵngcc1.NgIf, FuiDropdownMenu, ɵngcc1.NgForOf, FuiSearchResult,
        FuiDropdownMenuItem], styles: ["[_nghost-%COMP%] {\n    display: inline-block;\n    outline: 0;\n}\n\n\n.results[_ngcontent-%COMP%] {\n    margin-bottom: .5em;\n}"] });
/** @nocollapse */
FuiSearch.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: FuiLocalizationService }
];
FuiSearch.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.search',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hasIcon: [{ type: Input }],
    resultTemplate: [{ type: Input }],
    retainSelectedResult: [{ type: Input }],
    maxResults: [{ type: Input }],
    onResultSelected: [{ type: Output, args: ['resultSelected',] }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    _menu: [{ type: ViewChild, args: [FuiDropdownMenu, { static: false },] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    options: [{ type: Input }],
    optionsFilter: [{ type: Input }],
    optionsLookup: [{ type: Input }],
    optionsField: [{ type: Input }],
    searchDelay: [{ type: Input }],
    isSearching: [{ type: HostBinding, args: ['class.loading',] }],
    placeholder: [{ type: Input }],
    resultFormatter: [{ type: Input }],
    onFocusIn: [{ type: HostListener, args: ['focusin',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSearch, [{
        type: Component,
        args: [{
                selector: 'fui-search',
                template: `
<div class="ui input" [class.icon]="hasIcon" (click)="onClick($event)">
    <input class="prompt" type="text" [attr.placeholder]="placeholder" autocomplete="off" [(ngModel)]="query">
    <i *ngIf="hasIcon" class="search icon"></i>
</div>
<div class="results"
     fuiDropdownMenu
     [menuTransition]="transition"
     [menuTransitionDuration]="transitionDuration"
     menuSelectedItemClass="active">

    <fui-search-result *ngFor="let r of results"
                       class="item"
                       [value]="r"
                       [query]="query"
                       [formatter]="resultFormatter"
                       [template]="resultTemplate"
                       (click)="select(r)"></fui-search-result>

    <div *ngIf="results.length == 0" class="message empty">
        <div class="header">{{ localeValues.noResults.header }}</div>
        <div class="description">{{ localeValues.noResults.message }}</div>
    </div>
</div>
`,
                styles: [`
/* Ensures results div has margin. */
:host {
    display: inline-block;
    outline: 0;
}

/* Fixes positioning when results are pushed above the search. */
.results {
    margin-bottom: .5em;
}
`]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: FuiLocalizationService }]; }, { hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.search']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], hasIcon: [{
            type: Input
        }], retainSelectedResult: [{
            type: Input
        }], searchDelay: [{
            type: Input
        }], maxResults: [{
            type: Input
        }], onResultSelected: [{
            type: Output,
            args: ['resultSelected']
        }], transition: [{
            type: Input
        }], transitionDuration: [{
            type: Input
        }], isActive: [{
            type: HostBinding,
            args: ['class.active']
        }], options: [{
            type: Input
        }], optionsFilter: [{
            type: Input
        }], optionsLookup: [{
            type: Input
        }], optionsField: [{
            type: Input
        }], isSearching: [{
            type: HostBinding,
            args: ['class.loading']
        }], placeholder: [{
            type: Input
        }], resultFormatter: [{
            type: Input
        }], onFocusIn: [{
            type: HostListener,
            args: ['focusin']
        }], onFocusOut: [{
            type: HostListener,
            args: ['focusout', ['$event']]
        }], resultTemplate: [{
            type: Input
        }], _menu: [{
            type: ViewChild,
            args: [FuiDropdownMenu, { static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSearchModule {
}
FuiSearchModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiSearchModule });
FuiSearchModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiSearchModule_Factory(t) { return new (t || FuiSearchModule)(); }, imports: [[
            CommonModule,
            FormsModule,
            FuiDropdownModule,
            FuiLocalizationModule,
            FuiUtilityModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiSearchModule, { declarations: function () { return [FuiSearch,
        FuiSearchResult]; }, imports: function () { return [CommonModule,
        FormsModule,
        FuiDropdownModule,
        FuiLocalizationModule,
        FuiUtilityModule]; }, exports: function () { return [FuiSearch]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSearchModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FuiDropdownModule,
                    FuiLocalizationModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiSearch,
                    FuiSearchResult
                ],
                exports: [
                    FuiSearch
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiSelectOption extends FuiDropdownMenuItem {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(renderer, element, changeDetector) {
        // We inherit FuiDropdownMenuItem to automatically gain all keyboard navigation functionality.
        // This is not done via adding the .item class because it isn't supported by Angular.
        super(renderer, element);
        this.changeDetector = changeDetector;
        this.hasClasses = true;
        this.isActive = false;
        this.onSelected = new EventEmitter();
        // By default we make the default text an empty label, for the brief moment when it isn't displaying the correct one.
        this.renderedText = '';
        this.usesTemplate = false;
    }
    /**
     * @param {?} formatter
     * @return {?}
     */
    set formatter(formatter) {
        if (!this.usesTemplate) {
            this.renderedText = formatter(this.value);
        }
        else {
            this.renderedText = '';
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        e.eventHandled = true;
        setTimeout((/**
         * @return {?}
         */
        () => this.onSelected.emit(this.value)));
    }
}
FuiSelectOption.ɵfac = function FuiSelectOption_Factory(t) { return new (t || FuiSelectOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
FuiSelectOption.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiSelectOption, selectors: [["fui-select-option"]], viewQuery: function FuiSelectOption_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c6, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateSibling = _t.first);
    } }, hostVars: 4, hostBindings: function FuiSelectOption_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FuiSelectOption_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("item", ctx.hasClasses)("active", ctx.isActive);
    } }, inputs: { value: "value" }, outputs: { onSelected: "onSelected" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 1, consts: [["templateSibling", ""], [3, "innerHTML"]], template: function FuiSelectOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", null, 0);
        ɵngcc0.ɵɵelement(2, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("innerHTML", ctx.renderedText, ɵngcc0.ɵɵsanitizeHtml);
    } }, encapsulation: 2 });
/** @nocollapse */
FuiSelectOption.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiSelectOption.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.item',] }],
    value: [{ type: Input }],
    onSelected: [{ type: Output }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSelectOption, [{
        type: Component,
        args: [{
                selector: 'fui-select-option',
                template: `
<span #templateSibling></span>
<span [innerHTML]="renderedText"></span>
`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { hasClasses: [{
            type: HostBinding,
            args: ['class.item']
        }], isActive: [{
            type: HostBinding,
            args: ['class.active']
        }], onSelected: [{
            type: Output
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], value: [{
            type: Input
        }], templateSibling: [{
            type: ViewChild,
            args: ['templateSibling', { read: ViewContainerRef, static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSelectSearch {
    /**
     * @param {?} _renderer
     * @param {?} _element
     */
    constructor(_renderer, _element) {
        this._renderer = _renderer;
        this._element = _element;
        this.onQueryUpdated = new EventEmitter();
        this.onQueryKeyDown = new EventEmitter();
        this.hasClasses = true;
        this.autoComplete = 'off';
    }
    /**
     * @param {?} query
     * @return {?}
     */
    set query(query) {
        this._renderer.setProperty(this._element.nativeElement, 'value', query);
    }
    /**
     * @param {?} query
     * @return {?}
     */
    updateQuery(query) {
        this.onQueryUpdated.emit(query);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        this.onQueryKeyDown.emit(e);
    }
    /**
     * @return {?}
     */
    focus() {
        // Slightly delay to support in menu search.
        this._element.nativeElement.focus();
        setTimeout((/**
         * @return {?}
         */
        () => this._element.nativeElement.focus()));
    }
}
FuiSelectSearch.ɵfac = function FuiSelectSearch_Factory(t) { return new (t || FuiSelectSearch)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FuiSelectSearch.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiSelectSearch, selectors: [["input", "fuiSelectSearch", ""]], hostVars: 3, hostBindings: function FuiSelectSearch_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function FuiSelectSearch_input_HostBindingHandler($event) { return ctx.updateQuery($event.target.value); })("keydown", function FuiSelectSearch_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("autocomplete", ctx.autoComplete);
        ɵngcc0.ɵɵclassProp("search", ctx.hasClasses);
    } } });
/** @nocollapse */
FuiSelectSearch.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FuiSelectSearch.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.search',] }],
    autoComplete: [{ type: HostBinding, args: ['attr.autocomplete',] }],
    updateQuery: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSelectSearch, [{
        type: Directive,
        args: [{
                selector: 'input[fuiSelectSearch]'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { hasClasses: [{
            type: HostBinding,
            args: ['class.search']
        }], autoComplete: [{
            type: HostBinding,
            args: ['attr.autocomplete']
        }], updateQuery: [{
            type: HostListener,
            args: ['input', ['$event.target.value']]
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// We use generic type T to smenuTransitionDurationpecify the type of the options we are working with,
// and U to specify the type of the property of the option used as the value.
/**
 * @abstract
 * @template T, U
 */
class FuiSelectBase {
    /**
     * @param {?} _element
     * @param {?} _localizationService
     */
    constructor(_element, _localizationService) {
        this._element = _element;
        this._localizationService = _localizationService;
        this.dropdownService = new DropdownService();
        // We do want an empty query to return all results.
        this.searchService = new SearchService(true);
        this.isSearchable = false;
        this.onLocaleUpdate();
        this._localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        () => this.onLocaleUpdate()));
        this._renderedSubscriptions = [];
        this.icon = 'dropdown';
        this.transition = 'slide down';
        this.transitionDuration = 200;
        this.onTouched = new EventEmitter();
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this.dropdownService.isOpen;
    }
    /**
     * @return {?}
     */
    get isVisible() {
        return this._menu.isVisible;
    }
    /**
     * @return {?}
     */
    get hasSearchClass() {
        return this.isSearchable && !this.isSearchExternal;
    }
    /**
     * @return {?}
     */
    get isSearching() {
        return this.searchService.isSearching;
    }
    /**
     * @return {?}
     */
    get isClearing() {
        return this.isClearable;
    }
    /**
     * @return {?}
     */
    get searchInput() {
        return this._manualSearch || this._internalSearch;
    }
    /**
     * @return {?}
     */
    get tabindex() {
        if (this.isDisabled) {
            // If disabled, remove from tabindex.
            return -1;
        }
        if (this.dropdownService.isOpen && this.isSearchExternal) {
            // If open & in menu search, remove from tabindex (as input always autofocusses).
            return -1;
        }
        if (this._tabIndex != undefined) {
            // If custom tabindex, default to that.
            return this._tabIndex;
        }
        if (this.hasSearchClass) {
            // If search input enabled, tab goes to input.
            return -1;
        }
        // Otherwise, return default of 0.
        return 0;
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        return this.dropdownService.isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isDisabled(value) {
        this.dropdownService.isDisabled = !!value;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        if (options) {
            this.searchService.options = options;
            this.optionsUpdateHook();
        }
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    set optionsFilter(filter) {
        if (filter) {
            this.searchService.optionsFilter = filter;
            this.optionsUpdateHook();
        }
    }
    /**
     * @param {?} lookup
     * @return {?}
     */
    set optionsLookup(lookup) {
        if (lookup) {
            this.searchService.optionsLookup = lookup;
            this.optionsUpdateHook();
        }
    }
    /**
     * @return {?}
     */
    get filteredOptions() {
        return this.searchService.results;
    }
    // Deprecated
    /**
     * @return {?}
     */
    get availableOptions() {
        return this.filteredOptions;
    }
    /**
     * @return {?}
     */
    get query() {
        return this.isSearchable ? this.searchService.query : undefined;
    }
    /**
     * @param {?} query
     * @return {?}
     */
    set query(query) {
        if (query != undefined) {
            this.queryUpdateHook();
            this.updateQuery(query);
            // Update the rendered text as query has changed.
            this._renderedOptions.forEach((/**
             * @param {?} ro
             * @return {?}
             */
            ro => this.initialiseRenderedOption(ro)));
            if (this.searchInput) {
                this.searchInput.query = query;
            }
        }
    }
    /**
     * @return {?}
     */
    get labelField() {
        return this.searchService.optionsField;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    set labelField(field) {
        this.searchService.optionsField = field;
    }
    /**
     * @return {?}
     */
    get labelGetter() {
        // Helper function to retrieve the label from an item.
        return (/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => {
            /** @type {?} */
            const label = Util.Object.readValue(obj, this.labelField);
            if (label != undefined) {
                return label.toString();
            }
            return '';
        });
    }
    /**
     * @return {?}
     */
    get valueGetter() {
        // Helper function to retrieve the value from an item.
        return (/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => Util.Object.readValue(obj, this.valueField));
    }
    /**
     * @return {?}
     */
    get configuredFormatter() {
        if (this._optionFormatter) {
            return (/**
             * @param {?} o
             * @return {?}
             */
            o => (/** @type {?} */ (this._optionFormatter))(o, this.isSearchable ? this.query : undefined));
        }
        else if (this.searchService.optionsLookup) {
            return (/**
             * @param {?} o
             * @return {?}
             */
            o => this.labelGetter(o));
        }
        else {
            return (/**
             * @param {?} o
             * @return {?}
             */
            o => this.searchService.highlightMatches(this.labelGetter(o), this.query || ''));
        }
    }
    /**
     * @param {?} formatter
     * @return {?}
     */
    set optionFormatter(formatter) {
        this._optionFormatter = formatter;
    }
    /**
     * @return {?}
     */
    get localeValues() {
        return this._localizationService.override(this._localeValues, this.localeOverrides);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._menu.service = this.dropdownService;
        // We manually specify the menu items to the menu because the @ContentChildren doesn't pick up our dynamically rendered items.
        this._menu.items = this._renderedOptions;
        this._menu.parentElement = this._element;
        if (this._manualSearch) {
            this.isSearchable = true;
            this.isSearchExternal = true;
        }
        if (this.searchInput) {
            this.searchInput.onQueryUpdated.subscribe((/**
             * @param {?} q
             * @return {?}
             */
            (q) => this.query = q));
            this.searchInput.onQueryKeyDown.subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => this.onQueryInputKeydown(e)));
        }
        // We must call this immediately as changes doesn't fire when you subscribe.
        this.onAvailableOptionsRendered();
        this._renderedOptions.changes.subscribe((/**
         * @return {?}
         */
        () => this.onAvailableOptionsRendered()));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onCaretClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            if (!this.dropdownService.isAnimating) {
                this.dropdownService.setOpenState(!this.dropdownService.isOpen);
                this.focus();
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        if (!e.eventHandled && !this.dropdownService.isAnimating) {
            e.eventHandled = true;
            // If the dropdown is searchable, clicking should keep it open, otherwise we toggle the open state.
            this.dropdownService.setOpenState(this.isSearchable ? true : !this.dropdownService.isOpen);
            // Immediately focus the search input whenever clicking on the select.
            this.focus();
        }
    }
    /**
     * @return {?}
     */
    onFocusIn() {
        if (!this.dropdownService.isOpen && !this.dropdownService.isAnimating) {
            this.dropdownService.setOpenState(true);
            this.focus();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocusOut(e) {
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.dropdownService.setOpenState(false);
            this.onTouched.emit();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyPress(e) {
        if (e.keyCode === KeyCode.Enter) {
            // Enables support for focussing and opening with the keyboard alone.
            // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
            this._element.nativeElement.click();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        if (!this.dropdownService.isOpen && e.keyCode === KeyCode.Down) {
            // Enables support for focussing and opening with the keyboard alone.
            // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
            this._element.nativeElement.click();
            e.preventDefault();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onQueryInputKeydown(event) {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._renderedSubscriptions.forEach((/**
         * @param {?} s
         * @return {?}
         */
        s => s.unsubscribe()));
    }
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    /**
     * @protected
     * @return {?}
     */
    optionsUpdateHook() {
    }
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    /**
     * @protected
     * @return {?}
     */
    queryUpdateHook() {
    }
    /**
     * @protected
     * @param {?} query
     * @return {?}
     */
    updateQuery(query) {
        // Update the query then open the dropdown, as after keyboard input it should always be open.
        this.searchService.updateQuery(query, (/**
         * @return {?}
         */
        () => this.dropdownService.setOpenState(true)));
    }
    /**
     * @protected
     * @param {?=} delayed
     * @return {?}
     */
    resetQuery(delayed = true) {
        // The search delay is set to the transition duration to ensure results
        // aren't rendered as the select closes as that causes a sudden flash.
        if (delayed) {
            this.searchService.searchDelay = this._menu.menuTransitionDuration;
            this.searchService.updateQueryDelayed('');
        }
        else {
            this.searchService.updateQuery('');
        }
        if (this.searchInput) {
            this.searchInput.query = '';
        }
    }
    /**
     * @protected
     * @return {?}
     */
    onAvailableOptionsRendered() {
        // Unsubscribe from all previous subscriptions to avoid memory leaks on large selects.
        this._renderedSubscriptions.forEach((/**
         * @param {?} rs
         * @return {?}
         */
        rs => rs.unsubscribe()));
        this._renderedSubscriptions = [];
        this._renderedOptions.forEach((/**
         * @param {?} ro
         * @return {?}
         */
        ro => {
            // Slightly delay initialisation to avoid change after checked errors. TODO - look into avoiding this!
            setTimeout((/**
             * @return {?}
             */
            () => this.initialiseRenderedOption(ro)));
            this._renderedSubscriptions.push(ro.onSelected.subscribe((/**
             * @return {?}
             */
            () => this.selectOption(ro.value))));
        }));
        // If no options have been provided, autogenerate them from the rendered ones.
        if (this.searchService.options.length === 0 && !this.searchService.optionsLookup) {
            this.options = this._renderedOptions.map((/**
             * @param {?} ro
             * @return {?}
             */
            ro => ro.value));
        }
    }
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    initialiseRenderedOption(option) {
        option.usesTemplate = !!this.optionTemplate;
        option.formatter = this.configuredFormatter;
        if (option.usesTemplate) {
            this.drawTemplate(option.templateSibling, option.value);
        }
        option.changeDetector.markForCheck();
    }
    /**
     * @protected
     * @param {?} options
     * @param {?} value
     * @return {?}
     */
    findOption(options, value) {
        // Tries to find an option in options array
        return options.find((/**
         * @param {?} o
         * @return {?}
         */
        o => value === this.valueGetter(o)));
    }
    /**
     * @protected
     * @return {?}
     */
    focus() {
        if (this.isSearchable && this.searchInput) {
            // Focusses the search input only when searchable.
            // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
            this.searchInput.focus();
        }
        else {
            this._element.nativeElement.focus();
        }
    }
    // Helper that draws the provided template beside the provided ViewContainerRef.
    /**
     * @protected
     * @param {?} siblingRef
     * @param {?} value
     * @return {?}
     */
    drawTemplate(siblingRef, value) {
        siblingRef.clear();
        // Use of `$implicit` means use of <ng-template let-option> syntax is supported.
        siblingRef.createEmbeddedView(this.optionTemplate, {
            $implicit: value,
            query: this.query
        });
    }
    /**
     * @private
     * @return {?}
     */
    onLocaleUpdate() {
        this._localeValues = this._localizationService.get().select;
    }
}
FuiSelectBase.ɵfac = function FuiSelectBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FuiSelectBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiSelectBase, contentQueries: function FuiSelectBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiSelectSearch, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiSelectOption, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._manualSearch = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._renderedOptions = _t);
    } }, viewQuery: function FuiSelectBase_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(FuiDropdownMenu, true);
        ɵngcc0.ɵɵviewQuery(FuiSelectSearch, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._menu = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._internalSearch = _t.first);
    } }, hostVars: 17, hostBindings: function FuiSelectBase_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FuiSelectBase_click_HostBindingHandler($event) { return ctx.onClick($event); })("focusin", function FuiSelectBase_focusin_HostBindingHandler() { return ctx.onFocusIn(); })("focusout", function FuiSelectBase_focusout_HostBindingHandler($event) { return ctx.onFocusOut($event); })("keypress", function FuiSelectBase_keypress_HostBindingHandler($event) { return ctx.onKeyPress($event); })("keydown", function FuiSelectBase_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("ui", ctx.hasClasses)("dropdown", ctx.hasClasses)("active", ctx.isActive)("visible", ctx.isVisible)("search", ctx.hasSearchClass)("loading", ctx.isSearching)("clearable", ctx.isClearing)("disabled", ctx.isDisabled);
    } }, inputs: { isSearchable: "isSearchable", icon: "icon", transition: "transition", transitionDuration: "transitionDuration", isDisabled: "isDisabled", options: "options", optionsFilter: "optionsFilter", optionsLookup: "optionsLookup", labelField: "labelField", optionFormatter: "optionFormatter", isClearable: "isClearable", valueField: "valueField", optionTemplate: "optionTemplate", _tabIndex: ["tabindex", "_tabIndex"] }, outputs: { onTouched: "touched" } });
FuiSelectBase.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.dropdown',] }],
    isClearable: [{ type: Input }],
    isSearchable: [{ type: Input }],
    valueField: [{ type: Input }],
    optionTemplate: [{ type: Input }],
    icon: [{ type: Input }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    onTouched: [{ type: Output, args: ['touched',] }],
    _menu: [{ type: ViewChild, args: [FuiDropdownMenu, { static: true },] }],
    _renderedOptions: [{ type: ContentChildren, args: [FuiSelectOption, { descendants: true },] }],
    _internalSearch: [{ type: ViewChild, args: [FuiSelectSearch, { static: false },] }],
    _manualSearch: [{ type: ContentChild, args: [FuiSelectSearch, { static: false },] }],
    _tabIndex: [{ type: Input, args: ['tabindex',] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    isVisible: [{ type: HostBinding, args: ['class.visible',] }],
    hasSearchClass: [{ type: HostBinding, args: ['class.search',] }],
    isSearching: [{ type: HostBinding, args: ['class.loading',] }],
    isClearing: [{ type: HostBinding, args: ['class.clearable',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    options: [{ type: Input }],
    optionsFilter: [{ type: Input }],
    optionsLookup: [{ type: Input }],
    labelField: [{ type: Input }],
    optionFormatter: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onFocusIn: [{ type: HostListener, args: ['focusin',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }],
    onKeyPress: [{ type: HostListener, args: ['keypress', ['$event'],] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};


/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiMultiSelectLabel extends FuiTransition {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     * @param {?} componentFactory
     */
    constructor(renderer, element, changeDetector, componentFactory) {
        super(renderer, element, changeDetector);
        this.componentFactory = componentFactory;
        // Initialise transition functionality.
        this._transitionController = new TransitionController(false, 'inline-block');
        this.setTransitionController(this._transitionController);
        this.onDeselected = new EventEmitter();
        this.hasClasses = true;
        this._transitionController.animate(new Transition('scale', 100, TransitionDirection.In));
    }
    /**
     * @return {?}
     */
    get template() {
        return this._template;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    set template(template) {
        this._template = template;
        if (this.template) {
            this.componentFactory.createView(this.templateSibling, this.template, {
                $implicit: this.value,
                query: this.query
            });
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    deselectOption(e) {
        e.eventHandled = true;
        this._transitionController.animate(new Transition('scale', 100, TransitionDirection.Out, (/**
         * @return {?}
         */
        () => this.onDeselected.emit(this.value))));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        e.eventHandled = true;
    }
}
FuiMultiSelectLabel.ɵfac = function FuiMultiSelectLabel_Factory(t) { return new (t || FuiMultiSelectLabel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(FuiComponentFactory)); };
FuiMultiSelectLabel.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiMultiSelectLabel, selectors: [["fui-multi-select-label"]], viewQuery: function FuiMultiSelectLabel_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c6, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateSibling = _t.first);
    } }, hostVars: 4, hostBindings: function FuiMultiSelectLabel_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FuiMultiSelectLabel_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ui", ctx.hasClasses)("label", ctx.hasClasses);
    } }, inputs: { template: "template", value: "value", query: "query", formatter: "formatter" }, outputs: { onDeselected: "deselected" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 1, consts: [["templateSibling", ""], [3, "innerHTML", 4, "ngIf"], [1, "delete", "icon", 3, "click"], [3, "innerHTML"]], template: function FuiMultiSelectLabel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", null, 0);
        ɵngcc0.ɵɵtemplate(2, FuiMultiSelectLabel_span_2_Template, 1, 1, "span", 1);
        ɵngcc0.ɵɵelementStart(3, "i", 2);
        ɵngcc0.ɵɵlistener("click", function FuiMultiSelectLabel_Template_i_click_3_listener($event) { return ctx.deselectOption($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.template);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/** @nocollapse */
FuiMultiSelectLabel.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: FuiComponentFactory }
];
FuiMultiSelectLabel.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.label',] }],
    value: [{ type: Input }],
    query: [{ type: Input }],
    onDeselected: [{ type: Output, args: ['deselected',] }],
    formatter: [{ type: Input }],
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
    template: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiMultiSelectLabel, [{
        type: Component,
        args: [{
                selector: 'fui-multi-select-label',
                template: `
<span #templateSibling></span>
<span *ngIf="!template" [innerHTML]="formatter(value)"></span>
<i class="delete icon" (click)="deselectOption($event)"></i>
`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: FuiComponentFactory }]; }, { onDeselected: [{
            type: Output,
            args: ['deselected']
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.label']
        }], template: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], value: [{
            type: Input
        }], query: [{
            type: Input
        }], formatter: [{
            type: Input
        }], templateSibling: [{
            type: ViewChild,
            args: ['templateSibling', { read: ViewContainerRef, static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
class FuiMultiSelect extends FuiSelectBase {
    /**
     * @param {?} element
     * @param {?} localizationService
     */
    constructor(element, localizationService) {
        super(element, localizationService);
        this.selectedOptions = [];
        this.selectedOptionsChange = new EventEmitter();
        this.hasLabels = true;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get filteredOptions() {
        if (this.maxSelectedReached) {
            // If we have reached the maximum number of selections, then empty the results completely.
            return [];
        }
        /** @type {?} */
        const searchResults = this.searchService.results;
        if (!this.hasLabels) {
            return searchResults;
        }
        else {
            // Returns the search results \ selected options.
            return searchResults
                .filter((/**
             * @param {?} r
             * @return {?}
             */
            r => this.selectedOptions.find((/**
             * @param {?} o
             * @return {?}
             */
            o => r === o)) == undefined));
        }
    }
    /**
     * @return {?}
     */
    get availableOptions() {
        return this.filteredOptions;
    }
    /**
     * @return {?}
     */
    get maxSelectedReached() {
        if (this.maxSelected == undefined) {
            // If there is no maximum then we can immediately return.
            return false;
        }
        return this.selectedOptions.length === this.maxSelected;
    }
    /**
     * @return {?}
     */
    get maxSelectedMessage() {
        return this._localizationService.interpolate(this.localeValues.multi.maxSelectedMessage, [['max', this.maxSelected.toString()]]);
    }
    /**
     * @return {?}
     */
    get selectedMessage() {
        return this._localizationService.interpolate(this.localeValues.multi.selectedMessage, [['count', this.selectedOptions.length.toString() === '0' && this._showCountText ?
                    this._showCountText : this.selectedOptions.length.toString()]]);
    }
    /**
     * @return {?}
     */
    get hasLabels() {
        return this._hasLabels;
    }
    /**
     * @param {?} hasLabels
     * @return {?}
     */
    set hasLabels(hasLabels) {
        this._hasLabels = hasLabels;
    }
    /**
     * @return {?}
     */
    get showCountText() {
        return this._showCountText;
    }
    /**
     * @param {?} showCountText
     * @return {?}
     */
    set showCountText(showCountText) {
        this._showCountText = showCountText;
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder || this.localeValues.multi.placeholder;
    }
    /**
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = placeholder;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    selectOption(option) {
        if (this.selectedOptions.indexOf(option) !== -1) {
            this.deselectOption(option);
            return;
        }
        this.selectedOptions.push(option);
        this.selectedOptionsChange.emit(this.selectedOptions.map((/**
         * @param {?} o
         * @return {?}
         */
        o => this.valueGetter(o))));
        this.resetQuery(false);
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
        if (!this.hasLabels) {
            this.onAvailableOptionsRendered();
        }
    }
    /**
     * @param {?} values
     * @return {?}
     */
    writeValue(values) {
        if (values instanceof Array) {
            if (this.searchService.options.length > 0) {
                // If the options have already been loaded, we can immediately match the ngModel values to options.
                this.selectedOptions = values
                    // non-null assertion added here because Typescript doesn't recognise the non-null filter.
                    .map((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => (/** @type {?} */ (this.findOption(this.searchService.options, v)))))
                    .filter((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => v != undefined));
            }
            if (values.length > 0 && this.selectedOptions.length === 0) {
                if (this.searchService.hasItemLookup) {
                    // If the search service has a selected lookup function, make use of that to load the initial values.
                    this.searchService
                        .initialLookup(values)
                        .then((/**
                     * @param {?} items
                     * @return {?}
                     */
                    items => this.selectedOptions = items));
                }
                else {
                    // Otherwise, cache the written value for when options are set.
                    this._writtenOptions = values;
                }
            }
            if (values.length === 0) {
                this.selectedOptions = [];
            }
        }
        else {
            this.selectedOptions = [];
        }
    }
    /**
     * @param {?} option
     * @return {?}
     */
    deselectOption(option) {
        // Update selected options to the previously selected options \ {option}.
        this.selectedOptions = this.selectedOptions.filter((/**
         * @param {?} so
         * @return {?}
         */
        so => so !== option));
        this.selectedOptionsChange.emit(this.selectedOptions.map((/**
         * @param {?} o
         * @return {?}
         */
        o => this.valueGetter(o))));
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
        if (!this.hasLabels) {
            this.onAvailableOptionsRendered();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onQueryInputKeydown(event) {
        if (event.keyCode === KeyCode.Backspace && this.query === '' && this.selectedOptions.length > 0) {
            // Deselect the rightmost option when the user presses backspace in the search input.
            this.deselectOption(this.selectedOptions[this.selectedOptions.length - 1]);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    optionsUpdateHook() {
        if (!this._writtenOptions && this.selectedOptions.length > 0) {
            // We need to check the options still exist.
            this.writeValue(this.selectedOptions.map((/**
             * @param {?} o
             * @return {?}
             */
            o => this.valueGetter(o))));
        }
        if (this._writtenOptions && this.searchService.options.length > 0) {
            // If there were values written by ngModel before the options had been loaded, this runs to fix it.
            this.selectedOptions = this._writtenOptions
                // non-null assertion added here because Typescript doesn't recognise the non-null filter.
                .map((/**
             * @param {?} v
             * @return {?}
             */
            v => (/** @type {?} */ (this.findOption(this.searchService.options, v)))))
                .filter((/**
             * @param {?} v
             * @return {?}
             */
            v => v != undefined));
            if (this.selectedOptions.length === this._writtenOptions.length) {
                this._writtenOptions = undefined;
            }
        }
    }
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    initialiseRenderedOption(option) {
        super.initialiseRenderedOption(option);
        // Boldens the item so it appears selected in the dropdown.
        option.isActive = !this.hasLabels && this.selectedOptions.indexOf(option.value) !== -1;
    }
}
FuiMultiSelect.ɵfac = function FuiMultiSelect_Factory(t) { return new (t || FuiMultiSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(FuiLocalizationService)); };
FuiMultiSelect.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiMultiSelect, selectors: [["fui-multi-select"]], hostVars: 2, hostBindings: function FuiMultiSelect_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("multiple", ctx.hasClasses);
    } }, inputs: { hasLabels: "hasLabels", showCountText: "showCountText", placeholder: "placeholder", maxSelected: "maxSelected" }, outputs: { selectedOptionsChange: "selectedOptionsChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 10, vars: 15, consts: [[3, "click"], [4, "ngIf"], ["fuiSelectSearch", "", "type", "text", 3, "hidden"], [1, "text"], [4, "ngIf", "ngIfElse"], ["selectedBlock", ""], ["fuiDropdownMenu", "", 1, "menu", 3, "menuTransition", "menuTransitionDuration", "menuAutoSelectFirst"], [3, "value", "query", "formatter", "template", "deselected", 4, "ngFor", "ngForOf"], [3, "value", "query", "formatter", "template", "deselected"], ["class", "message", 4, "ngIf"], [1, "message"]], template: function FuiMultiSelect_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "i", 0);
        ɵngcc0.ɵɵlistener("click", function FuiMultiSelect_Template_i_click_0_listener($event) { return ctx.onCaretClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(1, FuiMultiSelect_ng_container_1_Template, 2, 1, "ng-container", 1);
        ɵngcc0.ɵɵelement(2, "input", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, FuiMultiSelect_ng_container_4_Template, 2, 1, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(5, FuiMultiSelect_ng_template_5_Template, 1, 1, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 6);
        ɵngcc0.ɵɵprojection(8);
        ɵngcc0.ɵɵtemplate(9, FuiMultiSelect_ng_container_9_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r413 = ɵngcc0.ɵɵreference(6);
        ɵngcc0.ɵɵclassMapInterpolate1("", ctx.icon, " icon");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasLabels);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", !ctx.isSearchable || ctx.isSearchExternal);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("default", ctx.hasLabels)("filtered", !!ctx.query && !ctx.isSearchExternal);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasLabels)("ngIfElse", _r413);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("menuTransition", ctx.transition)("menuTransitionDuration", ctx.transitionDuration)("menuAutoSelectFirst", true);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.availableOptions.length == 0);
    } }, directives: [ɵngcc1.NgIf, FuiSelectSearch,
        FuiDropdownMenu, ɵngcc1.NgForOf, FuiMultiSelectLabel], styles: ["[_nghost-%COMP%]   input.search[_ngcontent-%COMP%] {\n    width: 12em !important;\n}"] });
/** @nocollapse */
FuiMultiSelect.ctorParameters = () => [
    { type: ElementRef },
    { type: FuiLocalizationService }
];
FuiMultiSelect.propDecorators = {
    selectedOptionsChange: [{ type: Output }],
    maxSelected: [{ type: Input }],
    hasClasses: [{ type: HostBinding, args: ['class.multiple',] }],
    hasLabels: [{ type: Input }],
    showCountText: [{ type: Input }],
    placeholder: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiMultiSelect, [{
        type: Component,
        args: [{
                selector: 'fui-multi-select',
                template: `
<!-- Dropdown icon -->
<i class="{{ icon }} icon" (click)="onCaretClick($event)"></i>

<ng-container *ngIf="hasLabels">
<!-- Multi-select labels -->
    <fui-multi-select-label *ngFor="let selected of selectedOptions;"
                            [value]="selected"
                            [query]="query"
                            [formatter]="configuredFormatter"
                            [template]="optionTemplate"
                            (deselected)="deselectOption($event)"></fui-multi-select-label>
</ng-container>

<!-- Query input -->
<input fuiSelectSearch
       type="text"
       [hidden]="!isSearchable || isSearchExternal">

<!-- Helper text -->
<div class="text"
     [class.default]="hasLabels"
     [class.filtered]="!!query && !isSearchExternal">

    <!-- Placeholder text -->
    <ng-container *ngIf="hasLabels; else selectedBlock">{{ placeholder }}</ng-container>

    <!-- Summary shown when labels are hidden -->
    <ng-template #selectedBlock> {{ selectedMessage }}</ng-template>
</div>

<!-- Select dropdown menu -->
<div class="menu"
     fuiDropdownMenu
     [menuTransition]="transition"
     [menuTransitionDuration]="transitionDuration"
     [menuAutoSelectFirst]="true">

    <ng-content></ng-content>
    <ng-container *ngIf="availableOptions.length == 0 ">
        <div *ngIf="!maxSelectedReached" class="message">{{ localeValues.noResultsMessage }}</div>
        <div *ngIf="maxSelectedReached" class="message">{{ maxSelectedMessage }}</div>
    </ng-container>
</div>
`,
                styles: [`
:host input.search {
    width: 12em !important;
}
`]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: FuiLocalizationService }]; }, { selectedOptionsChange: [{
            type: Output
        }], hasLabels: [{
            type: Input
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.multiple']
        }], showCountText: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], maxSelected: [{
            type: Input
        }] }); })();
// Value accessor directive for the select to support ngModel.
/**
 * @template T, U
 */
class FuiMultiSelectValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiMultiSelectValueAccessor.ɵfac = function FuiMultiSelectValueAccessor_Factory(t) { return new (t || FuiMultiSelectValueAccessor)(ɵngcc0.ɵɵdirectiveInject(FuiMultiSelect)); };
FuiMultiSelectValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiMultiSelectValueAccessor, selectors: [["fui-multi-select"]], hostBindings: function FuiMultiSelectValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("selectedOptionsChange", function FuiMultiSelectValueAccessor_selectedOptionsChange_HostBindingHandler($event) { return ctx.onChange($event); })("touched", function FuiMultiSelectValueAccessor_touched_HostBindingHandler() { return ctx.onTouched(); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([customValueAccessorFactory(FuiMultiSelectValueAccessor)]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FuiMultiSelectValueAccessor.ctorParameters = () => [
    { type: FuiMultiSelect }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiMultiSelectValueAccessor, [{
        type: Directive,
        args: [{
                selector: 'fui-multi-select',
                host: {
                    '(selectedOptionsChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiMultiSelectValueAccessor)]
            }]
    }], function () { return [{ type: FuiMultiSelect }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
class FuiSelect extends FuiSelectBase {
    /**
     * @param {?} element
     * @param {?} localizationService
     */
    constructor(element, localizationService) {
        super(element, localizationService);
        this.selectedOptionChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder || this.localeValues.single.placeholder;
    }
    /**
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = placeholder;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    selectOption(option) {
        // Choose and emit the selected option.
        this.selectedOption = option;
        this.selectedOptionChange.emit(this.valueGetter(option));
        this.dropdownService.setOpenState(false);
        this.resetQuery();
        this.drawSelectedOption();
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value != undefined) {
            if (this.searchService.options.length > 0) {
                // If the options have already been loaded, we can immediately match the ngModel value to an option.
                this.selectedOption = this.findOption(this.searchService.options, value);
                this.drawSelectedOption();
            }
            if (this.selectedOption == undefined) {
                if (this.valueField && this.searchService.hasItemLookup) {
                    // If the search service has a selected lookup function, make use of that to load the initial value.
                    this.searchService
                        .initialLookup(value)
                        .then((/**
                     * @param {?} i
                     * @return {?}
                     */
                    i => {
                        this.selectedOption = i;
                        this.drawSelectedOption();
                    }));
                }
                else {
                    // Otherwise, cache the written value for when options are set.
                    this._writtenOption = value;
                }
            }
        }
        else {
            this.selectedOption = undefined;
            this.drawSelectedOption();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onRemoveClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            this.selectedOption = undefined;
            this.selectedOptionChange.emit(undefined);
            this._renderedOptions.forEach((/**
             * @param {?} o
             * @return {?}
             */
            o => o.isActive = false));
        }
    }
    /**
     * @protected
     * @return {?}
     */
    optionsUpdateHook() {
        if (!this._writtenOption && this.selectedOption) {
            // We need to check the option still exists.
            this.writeValue(this.valueGetter(this.selectedOption));
        }
        if (this._writtenOption && this.searchService.options.length > 0) {
            // If there was an value written by ngModel before the options had been loaded, this runs to fix it.
            this.selectedOption = this.findOption(this.searchService.options, this._writtenOption);
            if (this.selectedOption) {
                this._writtenOption = undefined;
                this.drawSelectedOption();
            }
        }
    }
    /**
     * @protected
     * @return {?}
     */
    queryUpdateHook() {
        // When the query is updated, we just abandon the current selection.
        this.selectedOption = undefined;
    }
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    initialiseRenderedOption(option) {
        super.initialiseRenderedOption(option);
        // Boldens the item so it appears selected in the dropdown.
        option.isActive = option.value === this.selectedOption;
    }
    /**
     * @private
     * @return {?}
     */
    drawSelectedOption() {
        // Updates the active class on the newly selected option.
        if (this._renderedOptions) {
            this.onAvailableOptionsRendered();
        }
        if (this.selectedOption != undefined && this.optionTemplate) {
            this.drawTemplate(this._optionTemplateSibling, this.selectedOption);
        }
    }
}
FuiSelect.ɵfac = function FuiSelect_Factory(t) { return new (t || FuiSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(FuiLocalizationService)); };
FuiSelect.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiSelect, selectors: [["fui-select"]], viewQuery: function FuiSelect_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c10, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._optionTemplateSibling = _t.first);
    } }, inputs: { placeholder: "placeholder" }, outputs: { selectedOptionChange: "selectedOptionChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 11, vars: 11, consts: [["fuiSelectSearch", "", "type", "text", 3, "hidden"], ["class", "default text", 3, "filtered", 4, "ngIf"], [1, "text"], ["optionTemplateSibling", ""], [3, "innerHTML", 4, "ngIf"], ["class", "times icon", 3, "click", 4, "ngIf"], [3, "class", "click", 4, "ngIf"], ["fuiDropdownMenu", "", 1, "menu", 3, "menuTransition", "menuTransitionDuration", "menuAutoSelectFirst"], ["class", "message", 4, "ngIf"], [1, "default", "text"], [3, "innerHTML"], [1, "times", "icon", 3, "click"], [3, "click"], [1, "message"]], template: function FuiSelect_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "input", 0);
        ɵngcc0.ɵɵtemplate(1, FuiSelect_div_1_Template, 2, 3, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelement(3, "span", null, 3);
        ɵngcc0.ɵɵtemplate(5, FuiSelect_span_5_Template, 1, 1, "span", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, FuiSelect_i_6_Template, 1, 0, "i", 5);
        ɵngcc0.ɵɵtemplate(7, FuiSelect_i_7_Template, 1, 3, "i", 6);
        ɵngcc0.ɵɵelementStart(8, "div", 7);
        ɵngcc0.ɵɵprojection(9);
        ɵngcc0.ɵɵtemplate(10, FuiSelect_div_10_Template, 2, 1, "div", 8);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("hidden", !ctx.isSearchable || ctx.isSearchExternal);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selectedOption == undefined);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("filtered", ctx.query || ctx.selectedOption == undefined);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.optionTemplate && ctx.selectedOption != undefined);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selectedOption && !ctx.isSearching && ctx.isClearable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.selectedOption || !ctx.isClearable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("menuTransition", ctx.transition)("menuTransitionDuration", ctx.transitionDuration)("menuAutoSelectFirst", ctx.isSearchable);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isSearchable && ctx.availableOptions.length === 0);
    } }, directives: [FuiSelectSearch, ɵngcc1.NgIf, FuiDropdownMenu], styles: ["[_nghost-%COMP%]   .times.icon[_ngcontent-%COMP%] {\n                       position: absolute;\n                       width: auto;\n                       height: auto;\n                       line-height: 1.21428571em;\n                       top: .78571429em;\n                       right: 1em;\n                       margin: -.78571429em;\n                       opacity: .6;\n                       font-size: 1.07142857em;\n                       padding: .6em;\n                       -webkit-transition: opacity .1s ease;\n                       transition: opacity .1s ease;\n                       z-index: 3;\n                   }\n\n                   [_nghost-%COMP%]   .times.icon.larger[_ngcontent-%COMP%] {\n                       padding: .91666667em;\n                       font-size: .85714286em;\n                   }\n\n                   [_nghost-%COMP%]   .times.icon[_ngcontent-%COMP%]:hover {\n                       opacity: 1;\n                   }"] });
/** @nocollapse */
FuiSelect.ctorParameters = () => [
    { type: ElementRef },
    { type: FuiLocalizationService }
];
FuiSelect.propDecorators = {
    selectedOptionChange: [{ type: Output }],
    _optionTemplateSibling: [{ type: ViewChild, args: ['optionTemplateSibling', { read: ViewContainerRef, static: false },] }],
    placeholder: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSelect, [{
        type: Component,
        args: [{
                selector: 'fui-select',
                template: `
                   <!-- Query input -->
                   <input fuiSelectSearch
                          type="text"
                          [hidden]="!isSearchable || isSearchExternal">

                   <!-- Placeholder text -->
                   <div *ngIf="selectedOption == undefined" class="default text" [class.filtered]="query">{{ placeholder }}</div>
                   <!-- Selected item -->
                   <div class="text" [class.filtered]="query || selectedOption == undefined">
                       <span #optionTemplateSibling></span>
                       <span *ngIf="!optionTemplate && selectedOption != undefined"
                             [innerHTML]="configuredFormatter(selectedOption)"></span>
                   </div>
                   <!-- Dropdown icon -->
                   <i *ngIf="selectedOption && !isSearching && isClearable" class="times icon"
                      (click)="onRemoveClick($event)"></i>
                   <i *ngIf="!selectedOption || !isClearable" class="{{ icon }} icon" (click)="onCaretClick($event)"></i>
                   <!-- Select dropdown menu -->
                   <div class="menu"
                        fuiDropdownMenu
                        [menuTransition]="transition"
                        [menuTransitionDuration]="transitionDuration"
                        [menuAutoSelectFirst]="isSearchable">

                       <ng-content></ng-content>
                       <div *ngIf="isSearchable && availableOptions.length === 0" class="message">
                           {{ localeValues.noResultsMessage }}
                       </div>
                   </div>
               `,
                styles: [`
                   :host .times.icon {
                       position: absolute;
                       width: auto;
                       height: auto;
                       line-height: 1.21428571em;
                       top: .78571429em;
                       right: 1em;
                       margin: -.78571429em;
                       opacity: .6;
                       font-size: 1.07142857em;
                       padding: .6em;
                       -webkit-transition: opacity .1s ease;
                       transition: opacity .1s ease;
                       z-index: 3;
                   }

                   :host .times.icon.larger {
                       padding: .91666667em;
                       font-size: .85714286em;
                   }

                   :host .times.icon:hover {
                       opacity: 1;
                   }
               `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: FuiLocalizationService }]; }, { selectedOptionChange: [{
            type: Output
        }], placeholder: [{
            type: Input
        }], _optionTemplateSibling: [{
            type: ViewChild,
            args: ['optionTemplateSibling', { read: ViewContainerRef, static: false }]
        }] }); })();
// Value accessor directive for the select to support ngModel.
/**
 * @template T, U
 */
class FuiSelectValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiSelectValueAccessor.ɵfac = function FuiSelectValueAccessor_Factory(t) { return new (t || FuiSelectValueAccessor)(ɵngcc0.ɵɵdirectiveInject(FuiSelect)); };
FuiSelectValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiSelectValueAccessor, selectors: [["fui-select"]], hostBindings: function FuiSelectValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("selectedOptionChange", function FuiSelectValueAccessor_selectedOptionChange_HostBindingHandler($event) { return ctx.onChange($event); })("touched", function FuiSelectValueAccessor_touched_HostBindingHandler() { return ctx.onTouched(); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([customValueAccessorFactory(FuiSelectValueAccessor)]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FuiSelectValueAccessor.ctorParameters = () => [
    { type: FuiSelect }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSelectValueAccessor, [{
        type: Directive,
        args: [{
                selector: 'fui-select',
                host: {
                    '(selectedOptionChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiSelectValueAccessor)]
            }]
    }], function () { return [{ type: FuiSelect }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSelectModule {
}
FuiSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiSelectModule });
FuiSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiSelectModule_Factory(t) { return new (t || FuiSelectModule)(); }, imports: [[
            CommonModule,
            FormsModule,
            FuiDropdownModule,
            FuiUtilityModule,
            FuiLocalizationModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiSelectModule, { declarations: function () { return [FuiSelect,
        FuiSelectOption,
        FuiSelectSearch,
        FuiSelectValueAccessor,
        FuiMultiSelect,
        FuiMultiSelectLabel,
        FuiMultiSelectValueAccessor]; }, imports: function () { return [CommonModule,
        FormsModule,
        FuiDropdownModule,
        FuiUtilityModule,
        FuiLocalizationModule]; }, exports: function () { return [FuiSelect,
        FuiSelectOption,
        FuiSelectSearch,
        FuiSelectValueAccessor,
        FuiMultiSelect,
        FuiMultiSelectValueAccessor]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSelectModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FuiDropdownModule,
                    FuiUtilityModule,
                    FuiLocalizationModule
                ],
                declarations: [
                    FuiSelect,
                    FuiSelectOption,
                    FuiSelectSearch,
                    FuiSelectValueAccessor,
                    FuiMultiSelect,
                    FuiMultiSelectLabel,
                    FuiMultiSelectValueAccessor
                ],
                exports: [
                    FuiSelect,
                    FuiSelectOption,
                    FuiSelectSearch,
                    FuiSelectValueAccessor,
                    FuiMultiSelect,
                    FuiMultiSelectValueAccessor
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SidebarTransition = {
    Overlay: (/** @type {?} */ ('overlay')),
    Push: (/** @type {?} */ ('push')),
    ScaleDown: (/** @type {?} */ ('scale down')),
    Uncover: (/** @type {?} */ ('uncover')),
    SlideAlong: (/** @type {?} */ ('slide along')),
    SlideOut: (/** @type {?} */ ('slide out'))
};
/** @type {?} */
const SidebarDirection = {
    Left: (/** @type {?} */ ('left')),
    Right: (/** @type {?} */ ('right')),
    Top: (/** @type {?} */ ('top')),
    Bottom: (/** @type {?} */ ('bottom'))
};
class SidebarService {
    /**
     * @param {?=} isVisible
     */
    constructor(isVisible = false) {
        this.isVisible = isVisible;
        this.isAnimating = false;
        this.wasJustOpened = false;
        this.isVisibleChange = new EventEmitter();
        this.widthChange = new EventEmitter();
        this.heightChange = new EventEmitter();
        this.width = 260;
        this.height = 0;
        this.transition = SidebarTransition.Uncover;
    }
    /**
     * @return {?}
     */
    get width() {
        if (this.direction === SidebarDirection.Left) {
            return this._width;
        }
        if (this.direction === SidebarDirection.Right) {
            return -this._width;
        }
        return 0;
    }
    /**
     * @param {?} width
     * @return {?}
     */
    set width(width) {
        this._width = width;
        this.widthChange.emit();
    }
    /**
     * @return {?}
     */
    get height() {
        if (this.direction === SidebarDirection.Top) {
            return this._height;
        }
        if (this.direction === SidebarDirection.Bottom) {
            return -this._height;
        }
        return 0;
    }
    /**
     * @param {?} height
     * @return {?}
     */
    set height(height) {
        this._height = height;
        this.heightChange.emit();
    }
    /**
     * @param {?} isVisible
     * @return {?}
     */
    setVisibleState(isVisible) {
        if (this.isVisible !== isVisible) {
            this.isVisible = isVisible;
            this.isAnimating = true;
            this.wasJustOpened = true;
            this.isVisibleChange.emit(isVisible);
            setTimeout((/**
             * @return {?}
             */
            () => this.wasJustOpened = false));
            clearTimeout(this._isAnimatingTimeout);
            this._isAnimatingTimeout = window.setTimeout((/**
             * @return {?}
             */
            () => this.isAnimating = false), 500);
        }
    }
    /**
     * @return {?}
     */
    toggleVisibleState() {
        this.setVisibleState(!this.isVisible);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSidebar {
    /**
     * @param {?} _renderer
     * @param {?} _element
     */
    constructor(_renderer, _element) {
        this._renderer = _renderer;
        this._element = _element;
        this.service = new SidebarService();
        // We set the default here as well to force the classes to update.
        this.transition = SidebarTransition.Uncover;
        this.direction = SidebarDirection.Left;
        setTimeout((/**
         * @return {?}
         */
        () => this.updateDimensions()));
        this.service.isVisibleChange.subscribe((/**
         * @return {?}
         */
        () => this.updateDimensions()));
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get transition() {
        return this.service.transition;
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    set transition(transition) {
        this.service.transition.split(' ').forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this.setClass(c, false)));
        this.service.transition = transition;
        this.service.transition.split(' ').forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this.setClass(c, true)));
    }
    /**
     * @return {?}
     */
    get direction() {
        return this.service.direction;
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    set direction(direction) {
        this.setClass(this.service.direction, false);
        this.service.direction = direction;
        this.setClass(this.service.direction, true);
    }
    /**
     * @return {?}
     */
    get isVisible() {
        return this.service.isVisible;
    }
    /**
     * @param {?} isVisible
     * @return {?}
     */
    set isVisible(isVisible) {
        this.service.setVisibleState(isVisible);
    }
    /**
     * @return {?}
     */
    get isVisibleChange() {
        return this.service.isVisibleChange;
    }
    /**
     * @return {?}
     */
    get isAnimating() {
        return this.service.isAnimating;
    }
    /**
     * @return {?}
     */
    open() {
        this.service.setVisibleState(true);
    }
    /**
     * @return {?}
     */
    close() {
        this.service.setVisibleState(false);
    }
    /**
     * @return {?}
     */
    toggle() {
        this.service.toggleVisibleState();
    }
    /**
     * @private
     * @return {?}
     */
    updateDimensions() {
        this.service.width = this._element.nativeElement.offsetWidth;
        this.service.height = this._element.nativeElement.offsetHeight;
    }
    /**
     * @private
     * @param {?} className
     * @param {?=} isAdd
     * @return {?}
     */
    setClass(className, isAdd = true) {
        if (isAdd) {
            this._renderer.addClass(this._element.nativeElement, className);
        }
        else {
            this._renderer.removeClass(this._element.nativeElement, className);
        }
    }
}
FuiSidebar.ɵfac = function FuiSidebar_Factory(t) { return new (t || FuiSidebar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FuiSidebar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiSidebar, selectors: [["fui-sidebar"]], hostVars: 10, hostBindings: function FuiSidebar_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ui", ctx.hasClasses)("sidebar", ctx.hasClasses)("menu", ctx.hasClasses)("visible", ctx.isVisible)("animating", ctx.isAnimating);
    } }, inputs: { transition: "transition", direction: "direction", isVisible: "isVisible" }, outputs: { isVisibleChange: "isVisibleChange" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FuiSidebar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/** @nocollapse */
FuiSidebar.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FuiSidebar.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.sidebar',] }, { type: HostBinding, args: ['class.menu',] }],
    transition: [{ type: Input }],
    direction: [{ type: Input }],
    isVisible: [{ type: HostBinding, args: ['class.visible',] }, { type: Input }],
    isVisibleChange: [{ type: Output }],
    isAnimating: [{ type: HostBinding, args: ['class.animating',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSidebar, [{
        type: Component,
        args: [{
                selector: 'fui-sidebar',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { transition: [{
            type: Input
        }], direction: [{
            type: Input
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.ui']
        }, {
            type: HostBinding,
            args: ['class.sidebar']
        }, {
            type: HostBinding,
            args: ['class.menu']
        }], isVisible: [{
            type: HostBinding,
            args: ['class.visible']
        }, {
            type: Input
        }], isVisibleChange: [{
            type: Output
        }], isAnimating: [{
            type: HostBinding,
            args: ['class.animating']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSidebarSibling {
    /**
     * @param {?} _renderer
     * @param {?} _element
     */
    constructor(_renderer, _element) {
        this._renderer = _renderer;
        this._element = _element;
        this.canCloseSidebar = true;
        this.isDimmedWhenVisible = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get isVisible() {
        if (!this.service) {
            return false;
        }
        return this.service.isVisible;
    }
    /**
     * @return {?}
     */
    get isDimmed() {
        if (!this.service) {
            return false;
        }
        return this.service.isVisible && this.isDimmedWhenVisible;
    }
    /**
     * @return {?}
     */
    get service() {
        return this._service;
    }
    /**
     * @param {?} service
     * @return {?}
     */
    set service(service) {
        this._service = service;
        setTimeout((/**
         * @return {?}
         */
        () => this.updateTransform()));
        this._service.isVisibleChange.subscribe((/**
         * @return {?}
         */
        () => this.updateTransform()));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.canCloseSidebar && this.service.isVisible && !this.service.wasJustOpened) {
            this.service.setVisibleState(false);
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateTransform() {
        this._renderer.removeStyle(this._element.nativeElement, 'transform');
        this._renderer.removeStyle(this._element.nativeElement, '-webkit-transform');
        if (this.service.isVisible &&
            this.service.transition !== SidebarTransition.Overlay &&
            this.service.transition !== SidebarTransition.ScaleDown) {
            /** @type {?} */
            const translate = `translate3d(${this.service.width}px, ${this.service.height}px, 0)`;
            this._renderer.setStyle(this._element.nativeElement, 'transform', translate);
            this._renderer.setStyle(this._element.nativeElement, '-webkit-transform', translate);
        }
    }
}
FuiSidebarSibling.ɵfac = function FuiSidebarSibling_Factory(t) { return new (t || FuiSidebarSibling)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FuiSidebarSibling.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiSidebarSibling, selectors: [["fui-sidebar-sibling"]], hostVars: 6, hostBindings: function FuiSidebarSibling_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FuiSidebarSibling_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("pusher", ctx.hasClasses)("visible", ctx.isVisible)("dimmed", ctx.isDimmed);
    } }, inputs: { canCloseSidebar: "canCloseSidebar", isDimmedWhenVisible: "isDimmedWhenVisible" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FuiSidebarSibling_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] {\n                       display: block;\n                   }"] });
/** @nocollapse */
FuiSidebarSibling.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FuiSidebarSibling.propDecorators = {
    isDimmedWhenVisible: [{ type: Input }],
    hasClasses: [{ type: HostBinding, args: ['class.pusher',] }],
    canCloseSidebar: [{ type: Input }],
    isVisible: [{ type: HostBinding, args: ['class.visible',] }],
    isDimmed: [{ type: HostBinding, args: ['class.dimmed',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSidebarSibling, [{
        type: Component,
        args: [{
                selector: 'fui-sidebar-sibling',
                template: `
                   <ng-content></ng-content>`,
                styles: [`
                   :host {
                       display: block;
                   }
               `]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { canCloseSidebar: [{
            type: Input
        }], isDimmedWhenVisible: [{
            type: Input
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.pusher']
        }], isVisible: [{
            type: HostBinding,
            args: ['class.visible']
        }], isDimmed: [{
            type: HostBinding,
            args: ['class.dimmed']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSidebarContainer {
    constructor() {
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.sidebar) {
            throw new Error('You must include a <fui-sidebar> element within the container.');
        }
        this.service = this.sidebar.service;
        if (!this.sibling) {
            throw new Error('You must include a <fui-sidebar-sibling> element within the container.');
        }
        this.sibling.service = this.service;
    }
}
FuiSidebarContainer.ɵfac = function FuiSidebarContainer_Factory(t) { return new (t || FuiSidebarContainer)(); };
FuiSidebarContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiSidebarContainer, selectors: [["fui-sidebar-container"]], contentQueries: function FuiSidebarContainer_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiSidebar, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiSidebarSibling, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sidebar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sibling = _t.first);
    } }, hostVars: 2, hostBindings: function FuiSidebarContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("pushable", ctx.hasClasses);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FuiSidebarContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] {\n    display: block;\n}"] });
/** @nocollapse */
FuiSidebarContainer.ctorParameters = () => [];
FuiSidebarContainer.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.pushable',] }],
    sidebar: [{ type: ContentChild, args: [FuiSidebar, { static: false },] }],
    sibling: [{ type: ContentChild, args: [FuiSidebarSibling, { static: false },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSidebarContainer, [{
        type: Component,
        args: [{
                selector: 'fui-sidebar-container',
                template: `<ng-content></ng-content>`,
                styles: [`
:host {
    display: block;
}
`]
            }]
    }], function () { return []; }, { hasClasses: [{
            type: HostBinding,
            args: ['class.pushable']
        }], sidebar: [{
            type: ContentChild,
            args: [FuiSidebar, { static: false }]
        }], sibling: [{
            type: ContentChild,
            args: [FuiSidebarSibling, { static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSidebarModule {
}
FuiSidebarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiSidebarModule });
FuiSidebarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiSidebarModule_Factory(t) { return new (t || FuiSidebarModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiSidebarModule, { declarations: function () { return [FuiSidebar,
        FuiSidebarContainer,
        FuiSidebarSibling]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FuiSidebar,
        FuiSidebarContainer,
        FuiSidebarSibling]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiSidebarModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiSidebar,
                    FuiSidebarContainer,
                    FuiSidebarSibling
                ],
                exports: [
                    FuiSidebar,
                    FuiSidebarContainer,
                    FuiSidebarSibling
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Tab {
    /**
     * @param {?} header
     * @param {?} content
     */
    constructor(header, content) {
        this.id = header.id;
        this.header = header;
        this.content = content;
        // So that the header and content isActive properties are always in sync.
        this.header.isActiveChange
            .subscribe((/**
         * @return {?}
         */
        () => this.content.isActive = this.isActive));
    }
    // Saves accessing .header.isActive every time.
    /**
     * @return {?}
     */
    get isActive() {
        return this.header.isActive;
    }
    /**
     * @param {?} active
     * @return {?}
     */
    set isActive(active) {
        // Use `setActiveState` so as not to fire 'external changes' event.
        this.header.setActiveState(active);
    }
    // Saves accessing .header.isDisabled every time.
    /**
     * @return {?}
     */
    get isDisabled() {
        return this.header.isDisabled;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTabHeader {
    constructor() {
        this._isActive = false;
        this.isActiveChange = new EventEmitter();
        this.isActiveExternalChange = new EventEmitter();
        this.onActivate = new EventEmitter();
        this.onDeactivate = new EventEmitter();
        this.isDisabled = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this._isActive;
    }
    /**
     * @param {?} active
     * @return {?}
     */
    set isActive(active) {
        /** @type {?} */
        let isActive = active;
        // Only used by @Input(), runs whenever user input changes `isActive`.
        // Run in timeout because `isDisabled` can prohibit user from changing `isActive`.
        // so update is delayed to avoid 'changed after checked' error.
        setTimeout((/**
         * @return {?}
         */
        () => {
            // Only allow change if tab header is not disabled.
            isActive = !this.isDisabled ? active : false;
            this.setActiveState(isActive);
            // Fire 'external change' event as user input has occured.
            this.isActiveExternalChange.emit(isActive);
        }));
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        return this._isDisabled;
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    set isDisabled(disabled) {
        // Only update if value provided is different to current one.
        if (this._isDisabled !== disabled) {
            this._isDisabled = disabled;
            // If now disabled, then tab header must be deactivated.
            if (this.isDisabled) {
                this.isActive = false;
            }
        }
    }
    // Internally update active state.
    /**
     * @param {?} active
     * @return {?}
     */
    setActiveState(active) {
        // If (cast) active value has changed:
        if (!!this._isActive !== active) {
            // Update to the new value.
            this._isActive = active;
            // Fire the appropriate activation event.
            if (active) {
                this.onActivate.emit();
            }
            else {
                this.onDeactivate.emit();
            }
        }
        // Regardless, emit a change to `isActive`, so [(isActive)] works correctly.
        this.isActiveChange.emit(active);
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.isDisabled) {
            // Activate the tab when clicked, so long as it isn't disabled.
            this.isActive = true;
        }
    }
}
FuiTabHeader.ɵfac = function FuiTabHeader_Factory(t) { return new (t || FuiTabHeader)(); };
FuiTabHeader.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiTabHeader, selectors: [["", "fuiTabHeader", ""]], hostVars: 6, hostBindings: function FuiTabHeader_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FuiTabHeader_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("disabled", ctx.isDisabled)("item", ctx.hasClasses)("active", ctx.isActive);
    } }, inputs: { isDisabled: "isDisabled", isActive: "isActive", id: ["fuiTabHeader", "id"] }, outputs: { isActiveChange: "isActiveChange", onActivate: "activate", onDeactivate: "deactivate" } });
/** @nocollapse */
FuiTabHeader.ctorParameters = () => [];
FuiTabHeader.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.item',] }],
    id: [{ type: Input, args: ['fuiTabHeader',] }],
    isActiveChange: [{ type: Output }],
    onActivate: [{ type: Output, args: ['activate',] }],
    onDeactivate: [{ type: Output, args: ['deactivate',] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }, { type: Input }],
    isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiTabHeader, [{
        type: Directive,
        args: [{
                selector: '[fuiTabHeader]'
            }]
    }], function () { return []; }, { isActiveChange: [{
            type: Output
        }], onActivate: [{
            type: Output,
            args: ['activate']
        }], onDeactivate: [{
            type: Output,
            args: ['deactivate']
        }], isDisabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }, {
            type: Input
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.item']
        }], isActive: [{
            type: HostBinding,
            args: ['class.active']
        }, {
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], id: [{
            type: Input,
            args: ['fuiTabHeader']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTabContent {
    constructor() {
        this.isActive = false;
        this.hasClasses = true;
    }
}
FuiTabContent.ɵfac = function FuiTabContent_Factory(t) { return new (t || FuiTabContent)(); };
FuiTabContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiTabContent, selectors: [["", "fuiTabContent", ""]], hostVars: 4, hostBindings: function FuiTabContent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive)("tab", ctx.hasClasses);
    } }, inputs: { id: ["fuiTabContent", "id"] } });
/** @nocollapse */
FuiTabContent.ctorParameters = () => [];
FuiTabContent.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.tab',] }],
    id: [{ type: Input, args: ['fuiTabContent',] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiTabContent, [{
        type: Directive,
        args: [{
                selector: '[fuiTabContent]'
            }]
    }], function () { return []; }, { isActive: [{
            type: HostBinding,
            args: ['class.active']
        }], hasClasses: [{
            type: HostBinding,
            args: ['class.tab']
        }], id: [{
            type: Input,
            args: ['fuiTabContent']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTabset {
    constructor() {
        this.tabs = [];
        this._barrierCount = 0;
    }
    // When setting a tab as the currently active tab, it automatically gains
    /**
     * @return {?}
     */
    get activeTab() {
        return this._activeTab;
    }
    // `isActive` status (saves littering `isActive = true` everywhere).
    /**
     * @param {?} tab
     * @return {?}
     */
    set activeTab(tab) {
        this._activeTab = tab;
        tab.isActive = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Fire `internalComponentsUpdated` when the query lists change.
        this._tabHeaders.changes.subscribe((/**
         * @return {?}
         */
        () => this.internalComponentsUpdated()));
        this._tabContents.changes.subscribe((/**
         * @return {?}
         */
        () => this.internalComponentsUpdated()));
        // Initially load the tabs.
        this.loadTabs();
    }
    // Activate the first tab in the set.
    /**
     * @return {?}
     */
    activateFirstTab() {
        this.activeTab = this.tabs[0];
    }
    // Activates the closest available tab to a given one.
    /**
     * @param {?} tab
     * @return {?}
     */
    activateClosestTab(tab) {
        /** @type {?} */
        let nextAvailable;
        // When the exited tab's index is higher than all available tabs,
        if (tab.index >= this.tabs.length) {
            // Activate the last tab.
            nextAvailable = this.tabs[this.tabs.length - 1];
        }
        // If that didn't work, try the following cases:
        if (!nextAvailable) {
            if (!this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            t => t === tab))) { // When the exited tab no longer exists,
                // Replace it with a tab at the same index.
                nextAvailable = this.tabs[tab.index];
            }
            else { // Or if the exited tab still exists,
                // Go to the tab immediately to the left.
                nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];
            }
        }
        // However, if the chosen tab is disabled,
        if (nextAvailable.isDisabled) {
            // Activate the closest available tab to it.
            return this.activateClosestTab(nextAvailable);
        }
        this.activeTab = nextAvailable;
    }
    // Fires whenever either the tab headers or tab contents query lists update.
    /**
     * @private
     * @return {?}
     */
    internalComponentsUpdated() {
        // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.
        // This is so that both the headers and contents query lists can update before we run code that matches the two up.
        this._barrierCount++;
        if (this._barrierCount === 2) {
            // Reset the barrier so it can be called again.
            this._barrierCount = 0;
            // Update the tabs.
            this.loadTabs();
        }
    }
    // Connects tab headers to tab contents, and creates a tab instance for each pairing.
    /**
     * @private
     * @return {?}
     */
    loadTabs() {
        // Remove any tabs that no longer have an associated header.
        this.tabs = this.tabs.filter((/**
         * @param {?} t
         * @return {?}
         */
        t => !!this._tabHeaders.find((/**
         * @param {?} tH
         * @return {?}
         */
        tH => tH === t.header))));
        this._tabHeaders
            // Filter out the loaded headers with attached tab instances.
            .filter((/**
         * @param {?} tH
         * @return {?}
         */
        tH => !this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        t => t.header === tH))))
            .forEach((/**
         * @param {?} tH
         * @return {?}
         */
        tH => {
            /** @type {?} */
            const content = this._tabContents.find((/**
             * @param {?} tC
             * @return {?}
             */
            tC => tC.id === tH.id));
            if (!content) {
                // Error if an associated tab content cannot be found for the given header.
                throw new Error('A [fuiTabHeader] must have a related [fuiTabContent].');
            }
            // Create a new tab instance for this header & content combo.
            /** @type {?} */
            const tab = new Tab(tH, content);
            // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.
            tab.header.isActiveExternalChange.subscribe((/**
             * @return {?}
             */
            () => this.onHeaderActiveChanged(tab)));
            // Add the new instance to the list of tabs.
            this.tabs.push(tab);
        }));
        // Assign each tab an index (which denotes the order they physically appear in).
        this._tabHeaders
            .forEach((/**
         * @param {?} tH
         * @param {?} i
         * @return {?}
         */
        (tH, i) => {
            /** @type {?} */
            const tab = this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            t => t.header === tH));
            if (tab) {
                tab.index = i;
            }
        }));
        // Sort the tabs by their index.
        this.tabs.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => a.index - b.index));
        if (!this.activeTab) { // Check if there are no current existing active tabs.
            // If so, we must activate the first available tab.
            this.activateFirstTab();
        }
        else if (!this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        t => t === this.activeTab))) { // O'wise check if current active tab has been deleted.
            // If so, we must find the closest.
            // Use `setTimeout` as this causes a 'changed after checked' error o'wise.
            setTimeout((/**
             * @return {?}
             */
            () => this.activateClosestTab(this.activeTab)));
        }
        if (this.tabs.length === 0) {
            // Error if there aren't any tabs in the tabset.
            throw new Error('You cannot have no tabs!');
        }
    }
    // Fires whenever a tab header's active state is externally changed.
    /**
     * @private
     * @param {?} tab
     * @return {?}
     */
    onHeaderActiveChanged(tab) {
        // If the tab has become activated, but was not previously the active tab:
        if (tab.isActive && this.activeTab !== tab) {
            // Deactivate all of the tabs.
            this.tabs.filter((/**
             * @param {?} t
             * @return {?}
             */
            t => t !== tab)).forEach((/**
             * @param {?} t
             * @return {?}
             */
            t => t.isActive = false));
            // Set the currently active tab to this one.
            this.activeTab = tab;
        }
        // If the tab has become deactivated, but was previously the active tab:
        if (!tab.isActive && this.activeTab === tab) {
            // Activate the closest tab to it.
            this.activateClosestTab(tab);
        }
    }
}
FuiTabset.ɵfac = function FuiTabset_Factory(t) { return new (t || FuiTabset)(); };
FuiTabset.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiTabset, selectors: [["fui-tabset"]], contentQueries: function FuiTabset_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiTabHeader, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiTabContent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabHeaders = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabContents = _t);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FuiTabset_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/** @nocollapse */
FuiTabset.ctorParameters = () => [];
FuiTabset.propDecorators = {
    _tabHeaders: [{ type: ContentChildren, args: [FuiTabHeader,] }],
    _tabContents: [{ type: ContentChildren, args: [FuiTabContent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiTabset, [{
        type: Component,
        args: [{
                selector: 'fui-tabset',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return []; }, { _tabHeaders: [{
            type: ContentChildren,
            args: [FuiTabHeader]
        }], _tabContents: [{
            type: ContentChildren,
            args: [FuiTabContent]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTabsModule {
}
FuiTabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiTabsModule });
FuiTabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiTabsModule_Factory(t) { return new (t || FuiTabsModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiTabsModule, { declarations: function () { return [FuiTabset,
        FuiTabHeader,
        FuiTabContent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FuiTabset,
        FuiTabHeader,
        FuiTabContent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiTabsModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiTabset,
                    FuiTabHeader,
                    FuiTabContent
                ],
                exports: [
                    FuiTabset,
                    FuiTabHeader,
                    FuiTabContent
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastTitle {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FuiToastTitle.ɵfac = function FuiToastTitle_Factory(t) { return new (t || FuiToastTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
FuiToastTitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiToastTitle, selectors: [["ng-template", "fuiToastTitle", ""]] });
/** @nocollapse */
FuiToastTitle.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiToastTitle, [{
        type: Directive,
        args: [{ selector: 'ng-template[fuiToastTitle]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastMessage {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FuiToastMessage.ɵfac = function FuiToastMessage_Factory(t) { return new (t || FuiToastMessage)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
FuiToastMessage.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FuiToastMessage, selectors: [["ng-template", "fuiToastMessage", ""]] });
/** @nocollapse */
FuiToastMessage.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiToastMessage, [{
        type: Directive,
        args: [{ selector: 'ng-template[fuiToastMessage]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToast {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.closeEvent = new EventEmitter();
        this.icons = {
            info: 'info',
            success: 'checkmark',
            warning: 'warning',
            error: 'times'
        };
        this.dismissible = this.dismissible || true;
        this.title = this.title || '';
        this.message = this.message || '';
        this.class = this.class || 'info';
        if (typeof this.showIcon !== 'string') {
            if (this.showIcon === undefined || this.showIcon === null) {
                this.showIcon = this.icons[this.class];
            }
            else {
                this.showIcon = false;
            }
        }
        this.closeIcon = this.closeIcon || false;
        this.className = this.className || 'ui toast';
        this.progressUp = this.progressUp || true;
        this.displayTime = this.displayTime || 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.displayTime) {
            window.setTimeout((/**
             * @return {?}
             */
            () => this.close()), this.displayTime);
            if (this.showProgress) {
                this.progress = this.progressUp ? 0 : 100;
                window.setTimeout((/**
                 * @return {?}
                 */
                () => this.progress = this.progressUp ? 100 : 0), 300);
            }
        }
    }
    /**
     * @return {?}
     */
    close() {
        this.elementRef.nativeElement.remove();
        this.closeEvent.next(this.id);
    }
}
FuiToast.ɵfac = function FuiToast_Factory(t) { return new (t || FuiToast)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FuiToast.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiToast, selectors: [["fui-toast"]], contentQueries: function FuiToast_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiToastTitle, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FuiToastMessage, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.titleTpl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.messageTpl = _t.first);
    } }, inputs: { dismissible: "dismissible", title: "title", message: "message", class: "class", showIcon: "showIcon", closeIcon: "closeIcon", className: "className", progressUp: "progressUp", displayTime: "displayTime", showProgress: "showProgress", id: "id" }, outputs: { closeEvent: "close" }, exportAs: ["fuiToast"], decls: 11, vars: 15, consts: [[1, "toast-box", "compact", 3, "click"], [3, "class", 4, "ngIf"], [3, "ngClass"], ["class", "close icon", 3, "click", 4, "ngIf"], [1, "content"], [4, "ngIf"], ["class", "header", 4, "ngIf"], ["class", "body", 4, "ngIf"], [1, "bar", 2, "width", "100%", 3, "ngStyle"], [1, "close", "icon", 3, "click"], [1, "header"], [3, "ngTemplateOutlet"], [1, "body"]], template: function FuiToast_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function FuiToast_Template_div_click_0_listener() { return ctx.dismissible ? !ctx.closeIcon ? ctx.close() : null : null; });
        ɵngcc0.ɵɵtemplate(1, FuiToast_div_1_Template, 2, 8, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, FuiToast_i_3_Template, 1, 0, "i", 3);
        ɵngcc0.ɵɵtemplate(4, FuiToast_i_4_Template, 1, 3, "i", 1);
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵtemplate(6, FuiToast_ng_container_6_Template, 3, 1, "ng-container", 5);
        ɵngcc0.ɵɵtemplate(7, FuiToast_div_7_Template, 2, 1, "div", 6);
        ɵngcc0.ɵɵtemplate(8, FuiToast_ng_container_8_Template, 3, 1, "ng-container", 5);
        ɵngcc0.ɵɵtemplate(9, FuiToast_div_9_Template, 2, 1, "div", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, FuiToast_div_10_Template, 2, 8, "div", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showProgress && ctx.showProgress === "top");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate2("", ctx.class, " ", ctx.className, "");
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(13, _c12, ctx.showIcon));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.closeIcon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showIcon);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.titleTpl);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.messageTpl);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showProgress && ctx.showProgress === "bottom");
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ɵngcc1.NgStyle, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
FuiToast.ctorParameters = () => [
    { type: ElementRef }
];
FuiToast.propDecorators = {
    dismissible: [{ type: Input }],
    title: [{ type: Input }],
    message: [{ type: Input }],
    class: [{ type: Input }],
    showIcon: [{ type: Input }],
    closeIcon: [{ type: Input }],
    className: [{ type: Input }],
    progressUp: [{ type: Input }],
    showProgress: [{ type: Input }],
    displayTime: [{ type: Input }],
    id: [{ type: Input }],
    closeEvent: [{ type: Output, args: ['close',] }],
    titleTpl: [{ type: ContentChild, args: [FuiToastTitle, { static: false },] }],
    messageTpl: [{ type: ContentChild, args: [FuiToastMessage, { static: false },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiToast, [{
        type: Component,
        args: [{
                selector: 'fui-toast',
                exportAs: 'fuiToast',
                template: `
    <div class="toast-box compact" (click)="(dismissible ? (!closeIcon ? close() : null) : null)">
      <div *ngIf="showProgress && showProgress === 'top'" class="ui attached active progress {{class}} {{showProgress}}">
        <div class="bar" [ngStyle]="{'transition': 'width ' + (displayTime / 1000)  + 's', 'width': progress + '%'}"
             style="width: 100%;"></div>
      </div>
      <div class="{{class}} {{className}}" [ngClass]="{'icon': showIcon}">
        <i *ngIf="closeIcon" class="close icon" (click)="close()"></i>
        <i *ngIf="showIcon" class="{{showIcon}} icon"></i>
        <div class="content">
          <ng-container *ngIf="title">
            <div class="header">{{title}}</div>
          </ng-container>
          <div class="header" *ngIf="titleTpl">
            <ng-template [ngTemplateOutlet]="titleTpl.templateRef"></ng-template>
          </div>
          <ng-container *ngIf="message">
            <div class="body">{{message}}</div>
          </ng-container>
          <div *ngIf="messageTpl" class="body">
            <ng-template [ngTemplateOutlet]="messageTpl.templateRef"></ng-template>
          </div>
        </div>
      </div>
      <div *ngIf="showProgress && showProgress === 'bottom'" class="ui attached active progress {{class}} {{showProgress}}">
        <div class="bar" [ngStyle]="{'transition': 'width ' + (displayTime / 1000)  + 's', 'width': progress + '%'}"
             style="width: 100%;"></div>
      </div>
    </div>
  `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { closeEvent: [{
            type: Output,
            args: ['close']
        }], dismissible: [{
            type: Input
        }], title: [{
            type: Input
        }], message: [{
            type: Input
        }], class: [{
            type: Input
        }], showIcon: [{
            type: Input
        }], closeIcon: [{
            type: Input
        }], className: [{
            type: Input
        }], progressUp: [{
            type: Input
        }], displayTime: [{
            type: Input
        }], showProgress: [{
            type: Input
        }], id: [{
            type: Input
        }], titleTpl: [{
            type: ContentChild,
            args: [FuiToastTitle, { static: false }]
        }], messageTpl: [{
            type: ContentChild,
            args: [FuiToastMessage, { static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastContainer {
    constructor() {
        this.toastData = [];
        this.timeoutIds = {};
        this.maxId = 0;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    addToast(data) {
        data.id = data.id || ++this.maxId;
        data.showProgress = data.showProgress || 'bottom';
        data.class = data.class || 'info';
        data.displayTime = data.displayTime || 5000;
        this.toastData.unshift(data);
        this.timeoutIds[data.id] = window.setTimeout((/**
         * @return {?}
         */
        () => this.closeToast(data.id)), data.displayTime);
    }
    /**
     * @param {?} toastId
     * @return {?}
     */
    closeToast(toastId) {
        /** @type {?} */
        const x = this.toastData.findIndex((/**
         * @param {?} t
         * @return {?}
         */
        t => t.id === toastId));
        if (x > -1) {
            /** @type {?} */
            const id = this.toastData[x].id;
            window.clearTimeout(this.timeoutIds[id]);
            delete this.timeoutIds[id];
            this.toastData.splice(x, 1);
        }
    }
}
FuiToastContainer.ɵfac = function FuiToastContainer_Factory(t) { return new (t || FuiToastContainer)(); };
FuiToastContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FuiToastContainer, selectors: [["fui-toast-container"]], exportAs: ["fuiToastContainer"], decls: 1, vars: 1, consts: [[3, "id", "title", "message", "class", "showProgress", "displayTime", "showIcon", "closeIcon", "progressUp", "className", "close", 4, "ngFor", "ngForOf"], [3, "id", "title", "message", "showProgress", "displayTime", "showIcon", "closeIcon", "progressUp", "className", "close"]], template: function FuiToastContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FuiToastContainer_fui_toast_0_Template, 1, 11, "fui-toast", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.toastData);
    } }, directives: [ɵngcc1.NgForOf, FuiToast], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiToastContainer, [{
        type: Component,
        args: [{
                selector: 'fui-toast-container',
                exportAs: 'fuiToastContainer',
                template: `
    <fui-toast *ngFor="let toast of toastData"
               [id]="toast.id"
               [title]="toast.title"
               [message]="toast.message"
               [class]="toast.class"
               [showProgress]="toast.showProgress"
               [displayTime]="toast.displayTime"
               [showIcon]="toast.showIcon"
               [closeIcon]="toast.closeIcon"
               [progressUp]="toast.progressUp"
               [className]="toast.className"
               (close)="closeToast(toast.id)"></fui-toast>`
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastConfig {
}
FuiToastConfig.ɵfac = function FuiToastConfig_Factory(t) { return new (t || FuiToastConfig)(); };
FuiToastConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FuiToastConfig, factory: FuiToastConfig.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiToastConfig, [{
        type: Injectable
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastModule {
}
FuiToastModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FuiToastModule });
FuiToastModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FuiToastModule_Factory(t) { return new (t || FuiToastModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FuiToastModule, { declarations: function () { return [FuiToastTitle,
        FuiToastMessage,
        FuiToast,
        FuiToastContainer]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FuiToastTitle,
        FuiToastMessage,
        FuiToast,
        FuiToastContainer]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FuiToastModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiToastTitle,
                    FuiToastMessage,
                    FuiToast,
                    FuiToastContainer
                ],
                exports: [
                    FuiToastTitle,
                    FuiToastMessage,
                    FuiToast,
                    FuiToastContainer
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FomanticUIModule {
}
FomanticUIModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FomanticUIModule });
FomanticUIModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FomanticUIModule_Factory(t) { return new (t || FomanticUIModule)(); }, imports: [[],
        FuiMessageModule,
        FuiPaginationModule,
        FuiAccordionModule,
        FuiCheckboxModule,
        FuiCollapseModule,
        FuiDatepickerModule,
        FuiDimmerModule,
        FuiDropdownModule,
        FuiModalModule,
        FuiPopupModule,
        FuiProgressModule,
        FuiRatingModule,
        FuiSearchModule,
        FuiSelectModule,
        FuiSidebarModule,
        FuiTabsModule,
        FuiToastModule,
        FuiTransitionModule,
        FuiLocalizationModule,
        FuiUtilityModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FomanticUIModule, { exports: [FuiMessageModule,
        FuiPaginationModule,
        FuiAccordionModule,
        FuiCheckboxModule,
        FuiCollapseModule,
        FuiDatepickerModule,
        FuiDimmerModule,
        FuiDropdownModule,
        FuiModalModule,
        FuiPopupModule,
        FuiProgressModule,
        FuiRatingModule,
        FuiSearchModule,
        FuiSelectModule,
        FuiSidebarModule,
        FuiTabsModule,
        FuiToastModule,
        FuiTransitionModule,
        FuiLocalizationModule,
        FuiUtilityModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FomanticUIModule, [{
        type: NgModule,
        args: [{
                imports: [],
                exports: [
                    FuiMessageModule,
                    FuiPaginationModule,
                    FuiAccordionModule,
                    FuiCheckboxModule,
                    FuiCollapseModule,
                    FuiDatepickerModule,
                    FuiDimmerModule,
                    FuiDropdownModule,
                    FuiModalModule,
                    FuiPopupModule,
                    FuiProgressModule,
                    FuiRatingModule,
                    FuiSearchModule,
                    FuiSelectModule,
                    FuiSidebarModule,
                    FuiTabsModule,
                    FuiToastModule,
                    FuiTransitionModule,
                    FuiLocalizationModule,
                    FuiUtilityModule
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ComponentModalConfig, DatepickerMode, DropdownAutoCloseType, FomanticUIModule, FuiAccordionModule, FuiActiveMessage, ActiveModal as FuiActiveModal, FuiCheckboxModule, FuiCollapseModule, FuiDatepickerModule, FuiDimmerModule, FuiDropdownModule, FuiLocalizationModule, FuiLocalizationService, FuiMessageContainer, FuiMessageModule, FuiMessageService, Modal as FuiModal, FuiModalModule, FuiModalService, FuiPaginationModule, FuiPopupConfig, FuiPopupModule, FuiProgressModule, FuiRatingModule, FuiSearchModule, FuiSelectModule, FuiSidebarModule, FuiTabsModule, FuiToast, FuiToastConfig, FuiToastContainer, FuiToastMessage, FuiToastModule, FuiToastTitle, FuiTransition, FuiTransitionModule, FuiUtilityModule, MessageConfig, MessageController, MessagePosition, MessageState, ModalConfig, ModalControls, ModalSize, ModalTemplate, PositioningPlacement as PopupPlacement, PopupTrigger, SearchService, SidebarDirection, SidebarTransition, TemplateModalConfig, Transition, TransitionController, TransitionDirection, FuiLocalizationService as ɵa, FuiLocalizationModule as ɵb, FuiDatepickerInputDirective as ɵba, CalendarRangeService as ɵbb, CalendarView as ɵbc, FuiCalendarDateView as ɵbd, FuiCalendarHourView as ɵbe, FuiCalendarMinuteView as ɵbf, FuiCalendarMonthView as ɵbg, FuiCalendarYearView as ɵbh, FuiDatepickerModule as ɵbi, FuiDimmer as ɵbj, FuiDimmerModule as ɵbk, FuiDropdownMenuItem as ɵbl, FuiDropdownMenu as ɵbm, FuiDropdown as ɵbn, FuiDropdownModule as ɵbo, ModalConfig as ɵbp, ModalControls as ɵbq, ModalTemplate as ɵbr, FuiModal as ɵbs, FuiModalService as ɵbt, FuiModalModule as ɵbu, CustomValidator as ɵbv, customValidatorFactory as ɵbw, CustomValueAccessor as ɵbx, customValueAccessorFactory as ɵby, DatePrecision as ɵbz, FuiMessageContainer as ɵc, FuiComponentFactory as ɵca, FuiUtilityModule as ɵcb, FuiPopupComponentController as ɵcc, PopupConfig as ɵcd, FuiPopupController as ɵce, FuiPopupTemplateController as ɵcf, FuiPopupArrow as ɵcg, FuiPopup as ɵch, FuiPopupDirective as ɵci, FuiPopupConfig as ɵcj, FuiPopupModule as ɵck, FuiProgress as ɵcl, FuiProgressModule as ɵcm, FuiRating as ɵcn, FuiRatingValueAccessor as ɵco, FuiRatingModule as ɵcp, FuiSearchResult as ɵcq, FuiSearch as ɵcr, FuiSearchModule as ɵcs, FuiSelectBase as ɵct, FuiMultiSelectLabel as ɵcu, FuiMultiSelect as ɵcv, FuiMultiSelectValueAccessor as ɵcw, FuiSelectOption as ɵcx, FuiSelect as ɵcy, FuiSelectValueAccessor as ɵcz, FuiMessageGlobalContainer as ɵd, FuiSelectSearch as ɵda, FuiSelectModule as ɵdb, FuiSidebarContainer as ɵdc, FuiSidebarSibling as ɵdd, FuiSidebar as ɵde, FuiSidebarModule as ɵdf, FuiTabset as ɵdg, FuiTabContent as ɵdh, FuiTabHeader as ɵdi, FuiTabsModule as ɵdj, FuiToastModule as ɵdk, FuiTransition as ɵdl, FuiTransitionModule as ɵdm, FuiModalDimmer as ɵdn, FuiMessage as ɵe, FuiMessageService as ɵf, FuiMessageModule as ɵg, FuiPagination as ɵh, FuiPaginationModule as ɵi, FuiAccordionPanel as ɵj, FuiAccordion as ɵk, FuiAccordionModule as ɵl, FuiCheckbox as ɵm, FuiCheckboxValueAccessor as ɵn, FuiRadio as ɵo, FuiRadioValueAccessor as ɵp, FuiRadioManager as ɵq, FuiCheckboxModule as ɵr, FuiCollapse as ɵs, FuiCollapseModule as ɵt, FuiCalendarViewTitle as ɵu, FuiDatepicker as ɵv, FuiCalendarItem as ɵw, FuiDatepickerDirective as ɵx, FuiDatepickerDirectiveValueAccessor as ɵy, FuiDatepickerDirectiveValidator as ɵz };

//# sourceMappingURL=ngx-fomantic-ui.js.map