import { __read, __extends, __assign } from 'tslib';
import { Injectable, EventEmitter, NgModule, Directive, Renderer2, ElementRef, ChangeDetectorRef, HostBinding, Input, Component, Output, forwardRef, ReflectiveInjector, ApplicationRef, ComponentFactoryResolver, Injector, ViewChild, ViewContainerRef, HostListener, ContentChildren, ViewChildren, Host, ContentChild, TemplateRef } from '@angular/core';
import * as $extend from 'extend';
import $extend__default, {  } from 'extend';
import { CommonModule } from '@angular/common';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import Popper from 'popper.js';
import { format, parse } from 'date-fns';
import * as defaultLocale from 'date-fns/locale/en';
import 'element-closest';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var enGB = {
    datepicker: {
        months: [
            'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
        ],
        monthsShort: [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
        ],
        weekdays: [
            'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
        ],
        weekdaysShort: [
            'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
        ],
        weekdaysNarrow: [
            'S', 'M', 'T', 'W', 'T', 'F', 'S'
        ],
        timesOfDay: [
            'a.m.', 'p.m.'
        ],
        timesOfDayUppercase: [
            'AM', 'PM'
        ],
        timesOfDayLowercase: [
            'am', 'pm'
        ],
        formats: {
            time: 'h:mm A',
            datetime: 'D MMMM YYYY h:mm A',
            date: 'D MMMM YYYY',
            month: 'MMMM YYYY',
            year: 'YYYY'
        },
        firstDayOfWeek: 1
    },
    search: {
        placeholder: 'Search...',
        noResults: {
            header: 'No Results',
            message: 'Your search returned no results.'
        }
    },
    select: {
        noResultsMessage: 'No results',
        single: {
            placeholder: 'Select one'
        },
        multi: {
            placeholder: 'Select...',
            maxSelectedMessage: 'Max #{max} selections',
            selectedMessage: '#{count} selections'
        }
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} obj
 * @return {?}
 */
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 * @template T, U
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
function deepExtend(target, source) {
    // Rollup...
    /** @type {?} */
    var extend = $extend__default || $extend;
    return extend(true, target, source);
}
/**
 * @param {?} language
 * @return {?}
 */
function lang(language) {
    return language.toLowerCase().replace('-', '');
}
var FuiLocalizationService = /** @class */ (function () {
    function FuiLocalizationService() {
        this.onLanguageUpdate = new EventEmitter();
        this._fallbackValues = enGB;
        this._values = {};
        this._language = 'en-GB';
        this.load('en-GB', enGB);
    }
    Object.defineProperty(FuiLocalizationService.prototype, "language", {
        get: /**
         * @return {?}
         */
        function () {
            return this._language;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} language
     * @return {?}
     */
    FuiLocalizationService.prototype.setLanguage = /**
     * @param {?} language
     * @return {?}
     */
    function (language) {
        if (lang(this._language) !== lang(language)) {
            this._language = language;
            this.onLanguageUpdate.emit();
        }
    };
    /**
     * @param {?=} language
     * @return {?}
     */
    FuiLocalizationService.prototype.get = /**
     * @param {?=} language
     * @return {?}
     */
    function (language) {
        if (language === void 0) { language = this.language; }
        /** @type {?} */
        var values = deepClone(this._fallbackValues);
        if (!this._values[lang(language)]) {
            throw new Error("Locale " + language + " is not loaded");
        }
        deepExtend(values, this._values[lang(language)]);
        return deepClone(values);
    };
    /**
     * @template T
     * @param {?} values
     * @param {?} overrides
     * @return {?}
     */
    FuiLocalizationService.prototype.override = /**
     * @template T
     * @param {?} values
     * @param {?} overrides
     * @return {?}
     */
    function (values, overrides) {
        return deepExtend(deepClone(values), overrides);
    };
    /**
     * @param {?} language
     * @param {?} values
     * @return {?}
     */
    FuiLocalizationService.prototype.load = /**
     * @param {?} language
     * @param {?} values
     * @return {?}
     */
    function (language, values) {
        this._values[lang(language)] = deepClone(values);
        this.onLanguageUpdate.emit();
    };
    /**
     * @param {?} language
     * @param {?} values
     * @return {?}
     */
    FuiLocalizationService.prototype.patch = /**
     * @param {?} language
     * @param {?} values
     * @return {?}
     */
    function (language, values) {
        deepExtend(this._values[lang(language)], values);
    };
    /**
     * @param {?} value
     * @param {?} variables
     * @return {?}
     */
    FuiLocalizationService.prototype.interpolate = /**
     * @param {?} value
     * @param {?} variables
     * @return {?}
     */
    function (value, variables) {
        return variables.reduce((/**
         * @param {?} s
         * @param {?} __1
         * @return {?}
         */
        function (s, _a) {
            var _b = __read(_a, 2), k = _b[0], v = _b[1];
            return s.replace(new RegExp("#{" + k + "}", 'g'), v);
        }), value);
    };
    FuiLocalizationService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    FuiLocalizationService.ctorParameters = function () { return []; };
    return FuiLocalizationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiLocalizationModule = /** @class */ (function () {
    function FuiLocalizationModule() {
    }
    FuiLocalizationModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    providers: [FuiLocalizationService]
                },] }
    ];
    return FuiLocalizationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
FuiActiveMessage = /** @class */ (function () {
    function FuiActiveMessage() {
    }
    return FuiActiveMessage;
}());
var ActiveMessage = /** @class */ (function () {
    function ActiveMessage(config, componentRef) {
        var _this = this;
        this.config = config;
        this.componentRef = componentRef;
        this.component.onDismiss.subscribe((/**
         * @return {?}
         */
        function () { return _this.componentRef.destroy(); }));
    }
    Object.defineProperty(ActiveMessage.prototype, "component", {
        get: /**
         * @return {?}
         */
        function () {
            return this.componentRef.instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} callback
     * @return {?}
     */
    ActiveMessage.prototype.onClick = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        this.config.onClick.subscribe((/**
         * @return {?}
         */
        function () { return callback(); }));
        return this;
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    ActiveMessage.prototype.onDismiss = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        this.config.onDismiss.subscribe((/**
         * @return {?}
         */
        function () { return callback(); }));
        return this;
    };
    /**
     * @return {?}
     */
    ActiveMessage.prototype.dismiss = /**
     * @return {?}
     */
    function () {
        this.component.dismiss();
    };
    return ActiveMessage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var MessageState = {
    Default: (/** @type {?} */ ('')),
    Info: (/** @type {?} */ ('info')),
    Success: (/** @type {?} */ ('success')),
    Warning: (/** @type {?} */ ('warning')),
    Error: (/** @type {?} */ ('error'))
};
var MessageConfig = /** @class */ (function () {
    function MessageConfig(text, state, header) {
        if (state === void 0) { state = MessageState.Default; }
        this.text = text;
        this.state = state;
        this.header = header;
        this.timeout = 5000;
        this.extendedTimeout = 1000;
        this.hasDismissButton = true;
        this.hasProgress = false;
        this.transition = 'fade';
        this.transitionInDuration = 400;
        this.transitionOutDuration = 1000;
        this.onClick = new EventEmitter();
        this.onDismiss = new EventEmitter();
    }
    return MessageConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MessageController = /** @class */ (function () {
    function MessageController() {
        this.maxShown = 7;
        this.isNewestOnTop = true;
    }
    /**
     * @param {?} container
     * @return {?}
     */
    MessageController.prototype.registerContainer = /**
     * @param {?} container
     * @return {?}
     */
    function (container) {
        this._container = container;
    };
    /**
     * @param {?} config
     * @return {?}
     */
    MessageController.prototype.show = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this.throwContainerError();
        return this._container.show(config, this.maxShown, this.isNewestOnTop);
    };
    /**
     * @return {?}
     */
    MessageController.prototype.dismissAll = /**
     * @return {?}
     */
    function () {
        this.throwContainerError();
        return this._container.dismissAll();
    };
    /**
     * @private
     * @return {?}
     */
    MessageController.prototype.throwContainerError = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this._container) {
            throw new Error('You must pass this controller to a message container.');
        }
    };
    return MessageController;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var TransitionDirection = {
    In: 0,
    Out: 1,
    Either: 2,
    Static: 3,
};
TransitionDirection[TransitionDirection.In] = 'In';
TransitionDirection[TransitionDirection.Out] = 'Out';
TransitionDirection[TransitionDirection.Either] = 'Either';
TransitionDirection[TransitionDirection.Static] = 'Static';
var Transition = /** @class */ (function () {
    function Transition(name, duration, direction, onComplete) {
        if (duration === void 0) { duration = 250; }
        if (direction === void 0) { direction = TransitionDirection.Either; }
        if (onComplete === void 0) { onComplete = (/**
         * @return {?}
         */
        function () {
        }); }
        this.type = name;
        // We set a minimum duration of 1ms, to give the appearance of an immediate transition
        // whilst allowing positioning calculations to happen without a visible flicker.
        this.duration = Math.max(duration, 1);
        this.direction = direction;
        this.classes = this.type.split(' ');
        this.onComplete = onComplete;
    }
    Object.defineProperty(Transition.prototype, "directionClass", {
        // Converts TransitionDirection to class name.
        get: 
        // Converts TransitionDirection to class name.
        /**
         * @return {?}
         */
        function () {
            switch (this.direction) {
                case TransitionDirection.In:
                    return 'in';
                case TransitionDirection.Out:
                    return 'out';
            }
            return '';
        },
        enumerable: true,
        configurable: true
    });
    return Transition;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TransitionController = /** @class */ (function () {
    function TransitionController(isInitiallyVisible, display) {
        if (isInitiallyVisible === void 0) { isInitiallyVisible = true; }
        if (display === void 0) { display = 'block'; }
        // isInitiallyVisible sets whether the element starts out visible.
        this._isVisible = isInitiallyVisible;
        this._isHidden = !this._isVisible;
        this._display = display;
        this._queue = [];
        this._isAnimating = false;
    }
    Object.defineProperty(TransitionController.prototype, "isAnimating", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isAnimating;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransitionController.prototype, "isVisible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isVisible;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransitionController.prototype, "isHidden", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isHidden;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransitionController.prototype, "_isReady", {
        // Used to delay animations until we have an element to animate.
        get: 
        // Used to delay animations until we have an element to animate.
        /**
         * @private
         * @return {?}
         */
        function () {
            return this._renderer != undefined && this._element != undefined && this._changeDetector != undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransitionController.prototype, "_queueFirst", {
        // Gets the first transition in the queue.
        get: 
        // Gets the first transition in the queue.
        /**
         * @private
         * @return {?}
         */
        function () {
            return this._queue[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransitionController.prototype, "_queueLast", {
        // Gets the last transition in the queue.
        get: 
        // Gets the last transition in the queue.
        /**
         * @private
         * @return {?}
         */
        function () {
            return this._queue[this._queue.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    // Sets the renderer to be used for animating.
    // Sets the renderer to be used for animating.
    /**
     * @param {?} renderer
     * @return {?}
     */
    TransitionController.prototype.registerRenderer = 
    // Sets the renderer to be used for animating.
    /**
     * @param {?} renderer
     * @return {?}
     */
    function (renderer) {
        this._renderer = renderer;
        this.performTransition();
    };
    // Sets the element to perform the animations on.
    // Sets the element to perform the animations on.
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionController.prototype.registerElement = 
    // Sets the element to perform the animations on.
    /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this._element = element;
        this.performTransition();
    };
    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.
    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.
    /**
     * @param {?} changeDetector
     * @return {?}
     */
    TransitionController.prototype.registerChangeDetector = 
    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.
    /**
     * @param {?} changeDetector
     * @return {?}
     */
    function (changeDetector) {
        this._changeDetector = changeDetector;
        this.performTransition();
    };
    /**
     * @param {?} transition
     * @return {?}
     */
    TransitionController.prototype.animate = /**
     * @param {?} transition
     * @return {?}
     */
    function (transition) {
        // Test if transition is one of the list that doesn't change the visible state.
        // Should these eventually become classes?
        /** @type {?} */
        var isDirectionless = ['jiggle', 'flash', 'shake', 'pulse', 'tada', 'bounce'].indexOf(transition.type) !== -1;
        if (isDirectionless) {
            transition.direction = TransitionDirection.Static;
        }
        else if (transition.direction == undefined || transition.direction === TransitionDirection.Either) {
            // Set the direction to the opposite of the current visible state automatically if not set, or set to either direction.
            transition.direction = this._isVisible ? TransitionDirection.Out : TransitionDirection.In;
            if (this._queueLast) {
                // If there is an transition in the queue already, set the direction to the opposite of the direction of that transition.
                if (this._queueLast.direction === TransitionDirection.In) {
                    transition.direction = TransitionDirection.Out;
                }
                else if (this._queueLast.direction === TransitionDirection.Out) {
                    transition.direction = TransitionDirection.In;
                }
            }
        }
        // Store the transition in the queue before attempting to perform it.
        this._queue.push(transition);
        this.performTransition();
    };
    // Stops the current transition, leaves the rest of the queue intact.
    // Stops the current transition, leaves the rest of the queue intact.
    /**
     * @param {?=} transition
     * @return {?}
     */
    TransitionController.prototype.stop = 
    // Stops the current transition, leaves the rest of the queue intact.
    /**
     * @param {?=} transition
     * @return {?}
     */
    function (transition) {
        if (transition === void 0) { transition = this._queueFirst; }
        if (!transition || !this._isAnimating) {
            return;
        }
        this.finalizeTransition(transition);
    };
    // Cancels the current transition, leaves the rest of the queue intact.
    // Cancels the current transition, leaves the rest of the queue intact.
    /**
     * @param {?=} transition
     * @return {?}
     */
    TransitionController.prototype.cancel = 
    // Cancels the current transition, leaves the rest of the queue intact.
    /**
     * @param {?=} transition
     * @return {?}
     */
    function (transition) {
        if (transition === void 0) { transition = this._queueFirst; }
        if (!transition || !this._isAnimating) {
            return;
        }
        this.completeTransition(transition);
        if (transition.direction === TransitionDirection.In) {
            // Return hidden class if we were originally transitioning in.
            this._isHidden = true;
        }
    };
    // Stops the current transition, and empties the queue.
    // Stops the current transition, and empties the queue.
    /**
     * @return {?}
     */
    TransitionController.prototype.stopAll = 
    // Stops the current transition, and empties the queue.
    /**
     * @return {?}
     */
    function () {
        this.clearQueue();
        this.stop();
    };
    /**
     * @return {?}
     */
    TransitionController.prototype.cancelAll = /**
     * @return {?}
     */
    function () {
        this.clearQueue();
        this.cancel();
    };
    // Empties the transition queue but carries on with the current transition.
    // Empties the transition queue but carries on with the current transition.
    /**
     * @return {?}
     */
    TransitionController.prototype.clearQueue = 
    // Empties the transition queue but carries on with the current transition.
    /**
     * @return {?}
     */
    function () {
        if (this.isAnimating) {
            this._queue = [this._queueFirst];
            return;
        }
        this._queue = [];
    };
    /**
     * @private
     * @return {?}
     */
    TransitionController.prototype.performTransition = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._isReady || this._isAnimating || !this._queueFirst) {
            // Don't transition until we are ready, or if we are animating, or if there aren't any transitions in the queue.
            return;
        }
        this._isAnimating = true;
        /** @type {?} */
        var transition = this._queueFirst;
        // Set the Fomantic UI classes for transitioning.
        transition.classes.forEach((/**
         * @param {?} c
         * @return {?}
         */
        function (c) { return _this._renderer.addClass(_this._element, c); }));
        this._renderer.addClass(this._element, "animating");
        this._renderer.addClass(this._element, transition.directionClass);
        // Set the Fomantic UI styles for transitioning.
        this._renderer.setStyle(this._element, "animationDuration", transition.duration + "ms");
        this._renderer.setStyle(this._element, "display", this._display);
        if (transition.direction === TransitionDirection.In) {
            // Unset hidden if we are transitioning in.
            this._isHidden = false;
        }
        // Wait the length of the animation before calling the complete callback.
        this._animationTimeout = window.setTimeout((/**
         * @return {?}
         */
        function () { return _this.finalizeTransition(transition); }), transition.duration);
    };
    /**
     * @private
     * @param {?} transition
     * @return {?}
     */
    TransitionController.prototype.completeTransition = /**
     * @private
     * @param {?} transition
     * @return {?}
     */
    function (transition) {
        var _this = this;
        transition.classes.forEach((/**
         * @param {?} c
         * @return {?}
         */
        function (c) { return _this._renderer.removeClass(_this._element, c); }));
        this._renderer.removeClass(this._element, "animating");
        this._renderer.removeClass(this._element, transition.directionClass);
        this._renderer.removeStyle(this._element, "animationDuration");
        this._renderer.removeStyle(this._element, "display");
        // Delete the transition from the queue.
        this._queue.shift();
        this._isAnimating = false;
        this._changeDetector.markForCheck();
        clearTimeout(this._animationTimeout);
    };
    // Called when a transition has completed.
    // Called when a transition has completed.
    /**
     * @private
     * @param {?} transition
     * @return {?}
     */
    TransitionController.prototype.finalizeTransition = 
    // Called when a transition has completed.
    /**
     * @private
     * @param {?} transition
     * @return {?}
     */
    function (transition) {
        this.completeTransition(transition);
        if (transition.direction === TransitionDirection.In) {
            // If we have just animated in, we are now visible.
            this._isVisible = true;
        }
        else if (transition.direction === TransitionDirection.Out) {
            // If we have transitioned out, we should be invisible and hidden.
            this._isVisible = false;
            this._isHidden = true;
        }
        if (transition.onComplete) {
            // Call the user-defined transition callback.
            transition.onComplete();
        }
        // Immediately attempt to perform another transition.
        this.performTransition();
    };
    return TransitionController;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiTransition = /** @class */ (function () {
    function FuiTransition(_renderer, _element, _changeDetector) {
        this._renderer = _renderer;
        this._element = _element;
        this._changeDetector = _changeDetector;
        this.transitionClass = true;
    }
    Object.defineProperty(FuiTransition.prototype, "fuiTransition", {
        set: /**
         * @param {?} tC
         * @return {?}
         */
        function (tC) {
            // Set the transition controller (e.g. '<div [fuiTransition]="transitionController"></div>').
            this.setTransitionController(tC);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiTransition.prototype, "isVisible", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._controller) {
                return this._controller.isVisible;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiTransition.prototype, "isHidden", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._controller) {
                return this._controller.isHidden;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    // Initialises the controller with the injected renderer and elementRef.
    // Initialises the controller with the injected renderer and elementRef.
    /**
     * @param {?} transitionController
     * @return {?}
     */
    FuiTransition.prototype.setTransitionController = 
    // Initialises the controller with the injected renderer and elementRef.
    /**
     * @param {?} transitionController
     * @return {?}
     */
    function (transitionController) {
        this._controller = transitionController;
        this._controller.registerRenderer(this._renderer);
        this._controller.registerElement(this._element.nativeElement);
        this._controller.registerChangeDetector(this._changeDetector);
    };
    FuiTransition.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiTransition]',
                    exportAs: 'transition'
                },] }
    ];
    /** @nocollapse */
    FuiTransition.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    FuiTransition.propDecorators = {
        transitionClass: [{ type: HostBinding, args: ['class.transition',] }],
        fuiTransition: [{ type: Input }],
        isVisible: [{ type: HostBinding, args: ['class.visible',] }],
        isHidden: [{ type: HostBinding, args: ['class.hidden',] }]
    };
    return FuiTransition;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiTransitionModule = /** @class */ (function () {
    function FuiTransitionModule() {
    }
    FuiTransitionModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [
                        FuiTransition
                    ],
                    exports: [
                        FuiTransition
                    ],
                    providers: []
                },] }
    ];
    return FuiTransitionModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiMessage = /** @class */ (function () {
    function FuiMessage() {
        /** @type {?} */
        var config = new MessageConfig('');
        this.loadConfig(config);
        this.isDynamic = false;
        this.transitionOutDuration = 300;
        this.timeoutProgress = 100;
        this.transitionController = new TransitionController(false);
        this.show();
    }
    Object.defineProperty(FuiMessage.prototype, "dynamicClasses", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var classes = {};
            classes[this.state] = true;
            if (this.isDynamic && this.hasProgress) {
                classes.attached = true;
            }
            (this.classes || '')
                .split(' ')
                .forEach((/**
             * @param {?} c
             * @return {?}
             */
            function (c) { return classes[c] = true; }));
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} config
     * @return {?}
     */
    FuiMessage.prototype.loadConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this.isDynamic = true;
        this.text = config.text;
        this.header = config.header;
        this.state = config.state;
        this.timeout = config.timeout;
        this.extendedTimeout = config.extendedTimeout;
        this.hasDismissButton = config.hasDismissButton;
        this.hasProgress = config.hasProgress;
        this.transition = config.transition;
        this.transitionInDuration = config.transitionInDuration;
        this.transitionOutDuration = config.transitionOutDuration;
        this.onClick = config.onClick;
        this.onDismiss = config.onDismiss;
    };
    /**
     * @return {?}
     */
    FuiMessage.prototype.show = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.transitionController.stopAll();
        this.transitionController.animate(new Transition(this.transition, this.isDynamic ? this.transitionInDuration : 0, TransitionDirection.In, (/**
         * @return {?}
         */
        function () {
            if (_this.isDynamic) {
                _this.beginTimer(_this.timeout);
            }
        })));
    };
    /**
     * @return {?}
     */
    FuiMessage.prototype.dismiss = /**
     * @return {?}
     */
    function () {
        this.isDismissing = true;
        this.transitionOutDuration = this.transitionInDuration;
        this.hide();
    };
    /**
     * @return {?}
     */
    FuiMessage.prototype.hide = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.isClosing = true;
        this.transitionController.stopAll();
        this.transitionController.animate(new Transition(this.transition, this.transitionOutDuration, TransitionDirection.Out, (/**
         * @return {?}
         */
        function () {
            _this.isClosing = false;
            _this.onDismiss.emit();
        })));
    };
    /**
     * @param {?} timeout
     * @return {?}
     */
    FuiMessage.prototype.beginTimer = /**
     * @param {?} timeout
     * @return {?}
     */
    function (timeout) {
        var _this = this;
        if (this.isDynamic && !this.isDismissing) {
            this.timeoutProgress = 0;
            this.currentTimeout = timeout;
            this._displayTimeout = window.setTimeout((/**
             * @return {?}
             */
            function () { return _this.onTimedOut(); }), timeout);
        }
    };
    /**
     * @return {?}
     */
    FuiMessage.prototype.cancelTimer = /**
     * @return {?}
     */
    function () {
        if (this.isDynamic && !this.isDismissing) {
            this.timeoutProgress = 100;
            this.currentTimeout = 0;
            clearTimeout(this._displayTimeout);
            if (this.isClosing) {
                this.isClosing = false;
                this.transitionController.cancel();
            }
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiMessage.prototype.onClicked = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!e.eventHandled) {
            this.cancelTimer();
            this.onClick.emit();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiMessage.prototype.onDismissClicked = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.eventHandled = true;
        this.dismiss();
    };
    /**
     * @private
     * @return {?}
     */
    FuiMessage.prototype.onTimedOut = /**
     * @private
     * @return {?}
     */
    function () {
        this.hide();
    };
    FuiMessage.decorators = [
        { type: Component, args: [{
                    selector: 'fui-message',
                    template: "\n<div [fuiTransition]=\"transitionController\">\n    <div class=\"ui message\"\n         [ngClass]=\"dynamicClasses\"\n         (mousemove)=\"cancelTimer()\"\n         (mouseleave)=\"beginTimer(extendedTimeout)\"\n         (click)=\"onClicked($event)\">\n        <i class=\"close icon\" *ngIf=\"hasDismissButton\" (click)=\"onDismissClicked($event)\"></i>\n        <ng-content></ng-content>\n        <ng-container *ngIf=\"isDynamic\">\n            <div class=\"header\" *ngIf=\"header\">{{ header }}</div>\n            <p>{{ text }}</p>\n        </ng-container>\n    </div>\n    <fui-progress *ngIf=\"isDynamic && hasProgress\"\n                  class=\"bottom attached\"\n                  [value]=\"timeoutProgress\"\n                  [autoSuccess]=\"false\"\n                  transition=\"linear\"\n                  [transitionDuration]=\"currentTimeout\"\n                  [canCompletelyEmpty]=\"true\"></fui-progress>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    FuiMessage.ctorParameters = function () { return []; };
    FuiMessage.propDecorators = {
        hasDismissButton: [{ type: Input }],
        transition: [{ type: Input }],
        transitionOutDuration: [{ type: Input, args: ['transitionDuration',] }],
        onClick: [{ type: Output, args: ['click',] }],
        onDismiss: [{ type: Output, args: ['dismiss',] }],
        classes: [{ type: Input, args: ['class',] }]
    };
    return FuiMessage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
CustomValidator = /** @class */ (function () {
    function CustomValidator(_host) {
        this._host = _host;
        this.onValidatorChange = (/**
         * @return {?}
         */
        function () {
        });
    }
    /**
     * @param {?} c
     * @return {?}
     */
    CustomValidator.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this._host.validate(c);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    CustomValidator.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onValidatorChange = fn;
    };
    return CustomValidator;
}());
/**
 * @param {?} type
 * @return {?}
 */
function customValidatorFactory(type) {
    return {
        provide: NG_VALIDATORS,
        useExisting: forwardRef((/**
         * @return {?}
         */
        function () { return type; })),
        multi: true
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template U, T
 */
var  /**
 * @template U, T
 */
CustomValueAccessor = /** @class */ (function () {
    function CustomValueAccessor(_host) {
        this._host = _host;
        this.onChange = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
        });
        this.onTouched = (/**
         * @return {?}
         */
        function () {
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    CustomValueAccessor.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._host.writeValue(value);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    CustomValueAccessor.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    CustomValueAccessor.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    return CustomValueAccessor;
}());
/**
 * @param {?} type
 * @return {?}
 */
function customValueAccessorFactory(type) {
    return {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef((/**
         * @return {?}
         */
        function () { return type; })),
        multi: true
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var KeyCode = {
    Left: 37,
    Up: 38,
    Right: 39,
    Down: 40,
    Escape: 27,
    Enter: 13,
    Space: 32,
    Backspace: 8,
};
KeyCode[KeyCode.Left] = 'Left';
KeyCode[KeyCode.Up] = 'Up';
KeyCode[KeyCode.Right] = 'Right';
KeyCode[KeyCode.Down] = 'Down';
KeyCode[KeyCode.Escape] = 'Escape';
KeyCode[KeyCode.Enter] = 'Enter';
KeyCode[KeyCode.Space] = 'Space';
KeyCode[KeyCode.Backspace] = 'Backspace';
/** @type {?} */
var Util = {
    Array: {
        range: /**
         * @param {?} n
         * @param {?=} offset
         * @return {?}
         */
        function (n, offset) {
            if (offset === void 0) { offset = 0; }
            return Array(n).fill(0).map((/**
             * @param {?} z
             * @param {?} i
             * @return {?}
             */
            function (z, i) { return i + offset; }));
        },
        group: /**
         * @template T
         * @param {?} items
         * @param {?} groupLength
         * @return {?}
         */
        function (items, groupLength) {
            /** @type {?} */
            var mutable = items.slice(0);
            /** @type {?} */
            var groups = [];
            while (mutable.length > 0) {
                groups.push(mutable.splice(0, groupLength));
            }
            return groups;
        },
        groupBy: /**
         * @template T
         * @param {?} items
         * @param {?} field
         * @return {?}
         */
        function (items, field) {
            return items.reduce((/**
             * @param {?} groups
             * @param {?} i
             * @return {?}
             */
            function (groups, i) {
                /** @type {?} */
                var fieldValue = i[field].toString();
                groups[fieldValue] = groups[fieldValue] || [];
                groups[fieldValue].push(i);
                return groups;
            }), Object());
        },
        flatten: /**
         * @template T
         * @param {?} items
         * @return {?}
         */
        function (items) {
            return items.reduce((/**
             * @param {?} is
             * @param {?} i
             * @return {?}
             */
            function (is, i) { return is.concat(i); }), []);
        }
    },
    String: {
        padLeft: /**
         * @param {?} str
         * @param {?} length
         * @param {?} padding
         * @return {?}
         */
        function (str, length, padding) {
            /** @type {?} */
            var s = str;
            while (s.length < length) {
                s = padding + s;
            }
            return s;
        }
    },
    DOM: {
        parseBooleanAttribute: /**
         * @param {?} attributeValue
         * @return {?}
         */
        function (attributeValue) {
            /** @type {?} */
            var value = attributeValue;
            if (typeof attributeValue === 'string') {
                value = true;
            }
            return value;
        },
        getDocumentFontSize: /**
         * @return {?}
         */
        function () {
            return parseFloat(window
                .getComputedStyle(document.documentElement, undefined)
                .getPropertyValue('font-size'));
        }
    },
    Object: {
        readValue: /**
         * @template T, U
         * @param {?} object
         * @param {?=} path
         * @return {?}
         */
        function (object, path) {
            if (!path) {
                return (/** @type {?} */ ((/** @type {?} */ (object))));
            }
            /** @type {?} */
            var recursed = (/** @type {?} */ ((/** @type {?} */ (object))));
            for (var i = 0, p = path.split('.'), len = p.length; i < len; i++) {
                recursed = ((/** @type {?} */ ((/** @type {?} */ (recursed)))))[p[i]];
            }
            return (/** @type {?} */ ((/** @type {?} */ (recursed))));
        }
    },
    Math: {
        round: /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        function (r, n) {
            return Math.round(r / n) * n;
        },
        roundUp: /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        function (r, n) {
            return Math.ceil(r / n) * n;
        },
        roundDown: /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        function (r, n) {
            return Math.floor(r / n) * n;
        },
        mod: /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        function (r, n) {
            /** @type {?} */
            var rem = r % n;
            if (rem < 0) {
                return rem + n;
            }
            return rem;
        }
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var DatePrecision = {
    Decade: 0,
    Year: 1,
    Month: 2,
    Date: 3,
    Hour: 4,
    Minute: 5,
};
DatePrecision[DatePrecision.Decade] = 'Decade';
DatePrecision[DatePrecision.Year] = 'Year';
DatePrecision[DatePrecision.Month] = 'Month';
DatePrecision[DatePrecision.Date] = 'Date';
DatePrecision[DatePrecision.Hour] = 'Hour';
DatePrecision[DatePrecision.Minute] = 'Minute';
/** @type {?} */
var DateUtil = {
    startOf: /**
     * @param {?} precision
     * @param {?} date
     * @param {?=} resetAll
     * @return {?}
     */
    function (precision, date, resetAll) {
        if (resetAll === void 0) { resetAll = false; }
        switch (precision) {
            case DatePrecision.Decade:
                /** @type {?} */
                var start = Math.floor(date.getFullYear() / 10) * 10 + 1;
                date.setFullYear(start);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Year:
                date.setMonth(0);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Month:
                date.setDate(1);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Date:
                date.setHours(0);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Hour:
                date.setMinutes(0);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Minute:
                date.setSeconds(0, 0);
        }
        return date;
    },
    endOf: /**
     * @param {?} precision
     * @param {?} date
     * @return {?}
     */
    function (precision, date) {
        switch (precision) {
            case DatePrecision.Year:
                date.setMonth(12, 0);
            // falls through
            case DatePrecision.Month:
                date.setMonth(date.getMonth() + 1, 0);
            // falls through
            case DatePrecision.Date:
                date.setHours(23, 59, 59, 999);
                break;
            case DatePrecision.Hour:
                date.setMinutes(59, 59, 999);
                break;
            case DatePrecision.Minute:
                date.setSeconds(59, 999);
                break;
        }
        return date;
    },
    equal: /**
     * @param {?} precision
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (precision, a, b) {
        /** @type {?} */
        var equal = true;
        switch (precision) {
            case DatePrecision.Minute:
                equal = equal && a.getMinutes() === b.getMinutes();
            // falls through
            case DatePrecision.Hour:
                equal = equal && a.getHours() === b.getHours();
            // falls through
            case DatePrecision.Date:
                equal = equal && a.getDate() === b.getDate();
            // falls through
            case DatePrecision.Month:
                equal = equal && a.getMonth() === b.getMonth();
            // falls through
            case DatePrecision.Year:
                equal = equal && a.getFullYear() === b.getFullYear();
        }
        return equal;
    },
    next: /**
     * @param {?} precision
     * @param {?} date
     * @return {?}
     */
    function (precision, date) {
        return DateUtil.add(precision, date, 1);
    },
    add: /**
     * @param {?} precision
     * @param {?} date
     * @param {?} i
     * @return {?}
     */
    function (precision, date, i) {
        /** @type {?} */
        var year = date.getFullYear();
        /** @type {?} */
        var month = date.getMonth();
        /** @type {?} */
        var day = date.getDate();
        switch (precision) {
            case DatePrecision.Decade:
                date.setFullYear(year + i * 10);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Year:
                date.setFullYear(year + i);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Month:
                date.setMonth(month + i);
                if (date.getMonth() !== Util.Math.mod(month + i, 12)) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Date:
                date.setDate(day + i);
                break;
            case DatePrecision.Hour:
                date.setHours(date.getHours() + i);
                break;
            case DatePrecision.Minute:
                date.setMinutes(date.getMinutes() + i);
                break;
        }
        return date;
    },
    previous: /**
     * @param {?} precision
     * @param {?} date
     * @return {?}
     */
    function (precision, date) {
        /** @type {?} */
        var year = date.getFullYear();
        /** @type {?} */
        var month = date.getMonth();
        /** @type {?} */
        var day = date.getDate();
        switch (precision) {
            case DatePrecision.Decade:
                date.setFullYear(year - 10);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Year:
                date.setFullYear(year - 1);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Month:
                date.setMonth(month - 1);
                if (date.getMonth() !== Util.Math.mod(month - 1, 12)) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Date:
                date.setDate(day - 1);
                break;
            case DatePrecision.Hour:
                /** @type {?} */
                var hours = date.getHours();
                date.setHours(hours - 1);
                if (date.getHours() !== Util.Math.mod(hours - 1, 24)) {
                    date.setHours(hours - 2);
                }
                break;
            case DatePrecision.Minute:
                /** @type {?} */
                var minutes = date.getMinutes();
                date.setMinutes(minutes - 1);
        }
        return date;
    },
    clone: /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return new Date(date.getTime());
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiComponentFactory = /** @class */ (function () {
    function FuiComponentFactory(_applicationRef, _componentFactoryResolver, _injector) {
        this._applicationRef = _applicationRef;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._injector = _injector;
    }
    /**
     * @template T
     * @param {?} type
     * @param {?=} providers
     * @return {?}
     */
    FuiComponentFactory.prototype.createComponent = /**
     * @template T
     * @param {?} type
     * @param {?=} providers
     * @return {?}
     */
    function (type, providers) {
        if (providers === void 0) { providers = []; }
        // Resolve a factory for creating components of type `type`.
        /** @type {?} */
        var factory = this._componentFactoryResolver.resolveComponentFactory((/** @type {?} */ (type)));
        // Resolve and create an injector with the specified providers.
        /** @type {?} */
        var injector = ReflectiveInjector.resolveAndCreate(providers, this._injector);
        // Create a component using the previously resolved factory & injector.
        /** @type {?} */
        var componentRef = factory.create(injector);
        return componentRef;
    };
    /**
     * @template T, U
     * @param {?} viewContainer
     * @param {?} template
     * @param {?} context
     * @return {?}
     */
    FuiComponentFactory.prototype.createView = /**
     * @template T, U
     * @param {?} viewContainer
     * @param {?} template
     * @param {?} context
     * @return {?}
     */
    function (viewContainer, template, context) {
        viewContainer.createEmbeddedView(template, context);
    };
    // Inserts the component into the specified view container.
    // Inserts the component into the specified view container.
    /**
     * @template T
     * @param {?} componentRef
     * @param {?} viewContainer
     * @return {?}
     */
    FuiComponentFactory.prototype.attachToView = 
    // Inserts the component into the specified view container.
    /**
     * @template T
     * @param {?} componentRef
     * @param {?} viewContainer
     * @return {?}
     */
    function (componentRef, viewContainer) {
        viewContainer.insert(componentRef.hostView, 0);
    };
    // Inserts the component in the root application node.
    // Inserts the component in the root application node.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    FuiComponentFactory.prototype.attachToApplication = 
    // Inserts the component in the root application node.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    function (componentRef) {
        this._applicationRef.attachView(componentRef.hostView);
    };
    // Detaches the component from the root application node.
    // Detaches the component from the root application node.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    FuiComponentFactory.prototype.detachFromApplication = 
    // Detaches the component from the root application node.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    function (componentRef) {
        this._applicationRef.detachView(componentRef.hostView);
    };
    // Moves the component to the specified DOM element.
    // Moves the component to the specified DOM element.
    /**
     * @template T
     * @param {?} componentRef
     * @param {?} element
     * @return {?}
     */
    FuiComponentFactory.prototype.moveToElement = 
    // Moves the component to the specified DOM element.
    /**
     * @template T
     * @param {?} componentRef
     * @param {?} element
     * @return {?}
     */
    function (componentRef, element) {
        element.appendChild(componentRef.location.nativeElement);
    };
    // Moves the component to the document body.
    // Moves the component to the document body.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    FuiComponentFactory.prototype.moveToDocumentBody = 
    // Moves the component to the document body.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    function (componentRef) {
        this.moveToElement(componentRef, (/** @type {?} */ (document.querySelector('body'))));
    };
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    FuiComponentFactory.prototype.detachFromDocument = /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    function (componentRef) {
        /** @type {?} */
        var element = (/** @type {?} */ (componentRef.location.nativeElement));
        // We can't use `element.remove()` due to lack of IE11 support.
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
    };
    FuiComponentFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    FuiComponentFactory.ctorParameters = function () { return [
        { type: ApplicationRef },
        { type: ComponentFactoryResolver },
        { type: Injector }
    ]; };
    return FuiComponentFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var PositioningPlacement = {
    Auto: (/** @type {?} */ ('auto')),
    TopLeft: (/** @type {?} */ ('top left')),
    Top: (/** @type {?} */ ('top')),
    TopRight: (/** @type {?} */ ('top right')),
    LeftTop: (/** @type {?} */ ('left top')),
    Left: (/** @type {?} */ ('left')),
    LeftBottom: (/** @type {?} */ ('left bottom')),
    BottomLeft: (/** @type {?} */ ('bottom left')),
    Bottom: (/** @type {?} */ ('bottom')),
    BottomRight: (/** @type {?} */ ('bottom right')),
    RightTop: (/** @type {?} */ ('right top')),
    Right: (/** @type {?} */ ('right')),
    RightBottom: (/** @type {?} */ ('right bottom'))
};
/**
 * @param {?} placement
 * @return {?}
 */
function placementToPopper(placement) {
    if (!placement || placement === PositioningPlacement.Auto) {
        return 'auto';
    }
    // All placements of the format: `direction alignment`, e.g. `top left`.
    var _a = __read(placement.split(' '), 2), direction = _a[0], alignment = _a[1];
    // Direction alone covers case of just `top`, `left`, `bottom`, `right`.
    /** @type {?} */
    var chosenPlacement = [direction];
    // Add `start` / `end` to placement, depending on alignment direction.
    switch (alignment) {
        case 'top':
        case 'left':
            chosenPlacement.push('start');
            break;
        case 'bottom':
        case 'right':
            chosenPlacement.push('end');
            break;
    }
    // Join with hyphen to create Popper compatible placement.
    return (/** @type {?} */ (chosenPlacement.join('-')));
}
/**
 * @param {?} popper
 * @return {?}
 */
function popperToPlacement(popper) {
    if (!popper || popper === 'auto') {
        return 'auto';
    }
    var _a = __read(popper.split('-'), 2), direction = _a[0], alignment = _a[1];
    /** @type {?} */
    var chosenPlacement = [direction];
    switch (direction) {
        case 'top':
        case 'bottom':
            switch (alignment) {
                case 'start':
                    chosenPlacement.push('left');
                    break;
                case 'end':
                    chosenPlacement.push('right');
                    break;
            }
            break;
        case 'left':
        case 'right':
            switch (alignment) {
                case 'start':
                    chosenPlacement.push('top');
                    break;
                case 'end':
                    chosenPlacement.push('bottom');
                    break;
            }
            break;
    }
    return (/** @type {?} */ (chosenPlacement.join(' ')));
}
var PositioningService = /** @class */ (function () {
    function PositioningService(anchor, subject, placement, arrowSelector) {
        this.anchor = anchor;
        this.subject = subject;
        this._placement = placement;
        this._arrowSelector = arrowSelector;
        this.init();
    }
    Object.defineProperty(PositioningService.prototype, "actualPlacement", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this._popperState) {
                return PositioningPlacement.Auto;
            }
            return popperToPlacement(this._popperState.placement);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PositioningService.prototype, "state", {
        get: /**
         * @return {?}
         */
        function () {
            return this._popperState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PositioningService.prototype, "placement", {
        get: /**
         * @return {?}
         */
        function () {
            return this._placement;
        },
        set: /**
         * @param {?} placement
         * @return {?}
         */
        function (placement) {
            this._placement = placement;
            if (this._popper) {
                this._popper.options.placement = placementToPopper(placement);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PositioningService.prototype, "hasArrow", {
        set: /**
         * @param {?} hasArrow
         * @return {?}
         */
        function (hasArrow) {
            this._hasArrow = hasArrow;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PositioningService.prototype.init = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var modifiers = {
            computeStyle: {
                gpuAcceleration: false
            },
            preventOverflow: {
                escapeWithReference: true,
                boundariesElement: document.body
            },
            arrow: {
                element: this._arrowSelector
            },
            offset: {
                fn: (/**
                 * @param {?} data
                 * @return {?}
                 */
                function (data) {
                    if (_this._hasArrow) {
                        /** @type {?} */
                        var offsets = _this.calculateOffsets();
                        data.offsets.popper.left += offsets.left;
                        data.offsets.popper.top += offsets.top;
                    }
                    return data;
                })
            }
        };
        if (!this._arrowSelector) {
            delete modifiers.arrow;
        }
        this._popper = (/** @type {?} */ (new Popper(this.anchor.nativeElement, this.subject.nativeElement, {
            placement: placementToPopper(this._placement),
            modifiers: modifiers,
            onCreate: (/**
             * @param {?} initial
             * @return {?}
             */
            function (initial) { return _this._popperState = initial; }),
            onUpdate: (/**
             * @param {?} update
             * @return {?}
             */
            function (update) { return _this._popperState = update; })
        })));
    };
    /**
     * @return {?}
     */
    PositioningService.prototype.update = /**
     * @return {?}
     */
    function () {
        this._popper.update();
    };
    /**
     * @return {?}
     */
    PositioningService.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this._popper.destroy();
    };
    /**
     * @private
     * @return {?}
     */
    PositioningService.prototype.calculateOffsets = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var left = 0;
        /** @type {?} */
        var top = 0;
        // To support correct positioning for all popup sizes we should calculate offset using em
        /** @type {?} */
        var fontSize = parseFloat(window.getComputedStyle(this.subject.nativeElement).getPropertyValue('font-size'));
        // The Fomantic UI popup arrow width and height are 0.71428571em and the margin from the popup edge is 1em
        /** @type {?} */
        var arrowCenter = (0.71428571 / 2 + 1) * fontSize;
        if (this.anchor.nativeElement.offsetWidth <= arrowCenter * 2) {
            /** @type {?} */
            var anchorCenterWidth = this.anchor.nativeElement.offsetWidth / 2;
            if (this._placement === PositioningPlacement.TopLeft || this._placement === PositioningPlacement.BottomLeft) {
                left = anchorCenterWidth - arrowCenter;
            }
            if (this._placement === PositioningPlacement.TopRight || this._placement === PositioningPlacement.BottomRight) {
                left = arrowCenter - anchorCenterWidth;
            }
        }
        if (this.anchor.nativeElement.offsetHeight <= arrowCenter * 2) {
            /** @type {?} */
            var anchorCenterHeight = this.anchor.nativeElement.offsetHeight / 2;
            if (this._placement === PositioningPlacement.LeftTop || this._placement === PositioningPlacement.RightTop) {
                top = anchorCenterHeight - arrowCenter;
            }
            if (this._placement === PositioningPlacement.LeftBottom || this._placement === PositioningPlacement.RightBottom) {
                top = arrowCenter - anchorCenterHeight;
            }
        }
        return { top: top, left: left, width: 0, height: 0 };
    };
    return PositioningService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiUtilityModule = /** @class */ (function () {
    function FuiUtilityModule() {
    }
    FuiUtilityModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    providers: [
                        FuiComponentFactory
                    ]
                },] }
    ];
    return FuiUtilityModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiMessageContainer = /** @class */ (function () {
    function FuiMessageContainer(_componentFactory, _element) {
        this._componentFactory = _componentFactory;
        this._element = _element;
        this._messages = [];
        this._queue = [];
    }
    Object.defineProperty(FuiMessageContainer.prototype, "controller", {
        set: /**
         * @param {?} controller
         * @return {?}
         */
        function (controller) {
            controller.registerContainer(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} config
     * @param {?} maxShown
     * @param {?} showNewestFirst
     * @return {?}
     */
    FuiMessageContainer.prototype.show = /**
     * @param {?} config
     * @param {?} maxShown
     * @param {?} showNewestFirst
     * @return {?}
     */
    function (config, maxShown, showNewestFirst) {
        var _this = this;
        /** @type {?} */
        var componentRef = this._componentFactory.createComponent(FuiMessage);
        componentRef.instance.loadConfig(config);
        /** @type {?} */
        var active = new ActiveMessage(config, componentRef)
            .onDismiss((/**
         * @return {?}
         */
        function () { return _this.onMessageClose(active, showNewestFirst); }));
        if (this._messages.length < maxShown) {
            this.open(active, showNewestFirst);
        }
        else {
            this.queue(active);
        }
        return active;
    };
    /**
     * @return {?}
     */
    FuiMessageContainer.prototype.dismissAll = /**
     * @return {?}
     */
    function () {
        this._queue = [];
        this._messages.forEach((/**
         * @param {?} m
         * @return {?}
         */
        function (m) { return m.dismiss(); }));
    };
    /**
     * @private
     * @param {?} message
     * @param {?} showNewestFirst
     * @return {?}
     */
    FuiMessageContainer.prototype.open = /**
     * @private
     * @param {?} message
     * @param {?} showNewestFirst
     * @return {?}
     */
    function (message, showNewestFirst) {
        this._messages.push(message);
        this._componentFactory.attachToView(message.componentRef, this.containerSibling);
        if (!showNewestFirst) {
            this._componentFactory.moveToElement(message.componentRef, this._element.nativeElement);
        }
        message.component.show();
    };
    /**
     * @private
     * @param {?} message
     * @return {?}
     */
    FuiMessageContainer.prototype.queue = /**
     * @private
     * @param {?} message
     * @return {?}
     */
    function (message) {
        this._queue.push(message);
    };
    /**
     * @private
     * @param {?} message
     * @param {?} showNewestFirst
     * @return {?}
     */
    FuiMessageContainer.prototype.onMessageClose = /**
     * @private
     * @param {?} message
     * @param {?} showNewestFirst
     * @return {?}
     */
    function (message, showNewestFirst) {
        this._messages = this._messages.filter((/**
         * @param {?} m
         * @return {?}
         */
        function (m) { return m !== message; }));
        if (this._queue.length > 0) {
            var _a = __read(this._queue.slice(0, 1), 1), queued = _a[0];
            this.open(queued, showNewestFirst);
        }
    };
    FuiMessageContainer.decorators = [
        { type: Component, args: [{
                    selector: 'fui-message-container',
                    template: "\n<div #containerSibling></div>\n",
                    styles: ["\n:host {\n    display: block;\n}\n:host >>> fui-message {\n    display: block;\n    margin-bottom: 1rem;\n}\n:host >>> fui-message:last-of-type {\n    margin-bottom: 0;\n}\n:host >>> fui-message {\n    cursor: pointer;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiMessageContainer.ctorParameters = function () { return [
        { type: FuiComponentFactory },
        { type: ElementRef }
    ]; };
    FuiMessageContainer.propDecorators = {
        containerSibling: [{ type: ViewChild, args: ['containerSibling', { read: ViewContainerRef, static: false },] }],
        controller: [{ type: Input }]
    };
    return FuiMessageContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var MessagePosition = {
    Top: (/** @type {?} */ ('top')),
    TopLeft: (/** @type {?} */ ('top-left')),
    TopRight: (/** @type {?} */ ('top-right')),
    Bottom: (/** @type {?} */ ('bottom')),
    BottomLeft: (/** @type {?} */ ('bottom-left')),
    BottomRight: (/** @type {?} */ ('bottom-right'))
};
var FuiMessageGlobalContainer = /** @class */ (function () {
    function FuiMessageGlobalContainer() {
    }
    Object.defineProperty(FuiMessageGlobalContainer.prototype, "dynamicClasses", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var classes = {};
            this.position
                .split('-')
                .forEach((/**
             * @param {?} p
             * @return {?}
             */
            function (p) { return classes[p] = true; }));
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMessageGlobalContainer.prototype, "dynamicWidth", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var margin = Util.DOM.getDocumentFontSize();
            /** @type {?} */
            var width = this.width;
            if (this.position === MessagePosition.Top ||
                this.position === MessagePosition.Bottom ||
                window.innerWidth < width + margin * 2) {
                width = window.innerWidth - margin * 2;
            }
            return width;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiMessageGlobalContainer.prototype.onDocumentResize = /**
     * @return {?}
     */
    function () {
    };
    FuiMessageGlobalContainer.decorators = [
        { type: Component, args: [{
                    selector: 'fui-message-global-container',
                    template: "\n<div class=\"global container\" [ngClass]=\"dynamicClasses\" [style.width.px]=\"dynamicWidth\">\n    <fui-message-container [controller]=\"controller\"></fui-message-container>\n</div>\n",
                    styles: ["\n.global.container {\n    display: block;\n    position: fixed;\n}\n.global.container.top {\n    top: 1rem;\n}\n.global.container.bottom {\n    bottom: 1rem;\n}\n.global.container.left {\n    left: 1rem;\n}\n.global.container.right {\n    right: 1rem;\n}\n.global.container:not(.left):not(.right) {\n    left: 1rem;\n}\n"]
                }] }
    ];
    FuiMessageGlobalContainer.propDecorators = {
        onDocumentResize: [{ type: HostListener, args: ['window:resize',] }]
    };
    return FuiMessageGlobalContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiMessageService = /** @class */ (function () {
    function FuiMessageService(_componentFactory) {
        this._componentFactory = _componentFactory;
        this._controller = new MessageController();
        this._containerRef = this._componentFactory.createComponent(FuiMessageGlobalContainer);
        this._container.controller = this._controller;
        this._componentFactory.attachToApplication(this._containerRef);
        this._componentFactory.moveToDocumentBody(this._containerRef);
        this.position = MessagePosition.TopRight;
        this.width = 480;
    }
    Object.defineProperty(FuiMessageService.prototype, "position", {
        get: /**
         * @return {?}
         */
        function () {
            return this._container.position;
        },
        set: /**
         * @param {?} position
         * @return {?}
         */
        function (position) {
            this._container.position = position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMessageService.prototype, "width", {
        get: /**
         * @return {?}
         */
        function () {
            return this._container.width;
        },
        set: /**
         * @param {?} width
         * @return {?}
         */
        function (width) {
            this._container.width = width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMessageService.prototype, "maxShown", {
        get: /**
         * @return {?}
         */
        function () {
            return this._controller.maxShown;
        },
        set: /**
         * @param {?} max
         * @return {?}
         */
        function (max) {
            this._controller.maxShown = max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMessageService.prototype, "isNewestOnTop", {
        get: /**
         * @return {?}
         */
        function () {
            return this._controller.isNewestOnTop;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._controller.isNewestOnTop = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMessageService.prototype, "_container", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._containerRef.instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} config
     * @return {?}
     */
    FuiMessageService.prototype.show = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        return this._controller.show(config);
    };
    /**
     * @return {?}
     */
    FuiMessageService.prototype.dismissAll = /**
     * @return {?}
     */
    function () {
        return this._controller.dismissAll();
    };
    FuiMessageService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    FuiMessageService.ctorParameters = function () { return [
        { type: FuiComponentFactory }
    ]; };
    return FuiMessageService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiProgress = /** @class */ (function () {
    function FuiProgress() {
        this.value = 0;
        this.maximum = 100;
        this.precision = 0;
        this._overrideSuccess = false;
        this.autoSuccess = true;
        this.showProgress = true;
        this.hasClasses = true;
    }
    Object.defineProperty(FuiProgress.prototype, "reachedMaximum", {
        get: /**
         * @return {?}
         */
        function () {
            return this._overrideSuccess || ((this.value >= this.maximum) && this.autoSuccess);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiProgress.prototype, "percentage", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var boundedValue = Math.min(Math.max(this.value, 0), this.maximum);
            /** @type {?} */
            var percentage = (boundedValue / this.maximum) * 100;
            return percentage.toFixed(this.precision);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiProgress.prototype, "classValue", {
        set: /**
         * @param {?} classes
         * @return {?}
         */
        function (classes) {
            if (classes.includes('attached') || classes.includes('tiny')) {
                this.showProgress = false;
            }
            if (classes.includes('success')) {
                this._overrideSuccess = true;
            }
            this.transition = 'ease';
            this.transitionDuration = 350;
            this.canCompletelyEmpty = false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiProgress.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // Convert value from string to number where necessary.
            /** @type {?} */
            var converted = +value;
            if (Number.isNaN(converted)) {
                return;
            }
            this._value = converted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiProgress.prototype, "maximum", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maximum;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // Convert value from string to number where necessary.
            /** @type {?} */
            var converted = +value;
            if (Number.isNaN(converted)) {
                return;
            }
            this._maximum = converted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiProgress.prototype, "precision", {
        get: /**
         * @return {?}
         */
        function () {
            return this._precision;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // Convert value from string to number where necessary.
            /** @type {?} */
            var converted = +value;
            if (Number.isNaN(converted)) {
                return;
            }
            this._precision = Math.min(Math.max(converted, 0), 20);
        },
        enumerable: true,
        configurable: true
    });
    FuiProgress.decorators = [
        { type: Component, args: [{
                    selector: 'fui-progress',
                    template: "\n<div class=\"bar\"\n    [style.width.%]=\"percentage\"\n    [style.minWidth]=\"canCompletelyEmpty ? 0 : null\"\n    [style.transitionTimingFunction]=\"transition\"\n    [style.transitionDuration.ms]=\"transitionDuration\">\n    <div class=\"progress\" *ngIf=\"showProgress\">{{ percentage }}%</div>\n</div>\n<div class=\"label\">\n    <ng-content></ng-content>\n</div>\n",
                    styles: ["\n.bar {\n    transition-duration: 300ms !important;\n    z-index: 1;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiProgress.ctorParameters = function () { return []; };
    FuiProgress.propDecorators = {
        transition: [{ type: Input }],
        transitionDuration: [{ type: Input }],
        canCompletelyEmpty: [{ type: Input }],
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.progress',] }],
        autoSuccess: [{ type: Input }],
        showProgress: [{ type: Input }],
        reachedMaximum: [{ type: HostBinding, args: ['class.success',] }],
        percentage: [{ type: HostBinding, args: ['attr.data-percent',] }],
        classValue: [{ type: Input, args: ['class',] }],
        value: [{ type: Input }],
        maximum: [{ type: Input }],
        precision: [{ type: Input }]
    };
    return FuiProgress;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiProgressModule = /** @class */ (function () {
    function FuiProgressModule() {
    }
    FuiProgressModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        FuiProgress
                    ],
                    exports: [
                        FuiProgress
                    ]
                },] }
    ];
    return FuiProgressModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiMessageModule = /** @class */ (function () {
    function FuiMessageModule() {
    }
    FuiMessageModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FuiTransitionModule,
                        FuiProgressModule,
                        FuiUtilityModule
                    ],
                    declarations: [
                        FuiMessage,
                        FuiMessageContainer,
                        FuiMessageGlobalContainer
                    ],
                    exports: [
                        FuiMessage,
                        FuiMessageContainer
                    ],
                    providers: [
                        FuiMessageService
                    ],
                    entryComponents: [
                        FuiMessage,
                        FuiMessageGlobalContainer
                    ]
                },] }
    ];
    return FuiMessageModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiPagination = /** @class */ (function () {
    function FuiPagination() {
        this.hasClasses = true;
        this.pageChange = new EventEmitter();
        this.pageSize = 10;
        this._page = 1;
        this._pages = [];
        this.pageCount = 1;
        this.hasNavigationLinks = true;
        this.hasBoundaryLinks = false;
        this.canRotate = false;
        this.hasEllipses = true;
    }
    Object.defineProperty(FuiPagination.prototype, "maxSize", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maxSize;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._maxSize = (value != undefined) ? Math.max(value, 1) : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPagination.prototype, "collectionSize", {
        get: /**
         * @return {?}
         */
        function () {
            return this._collectionSize;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._collectionSize = Math.max(value, 0);
            this.pageCount = Math.max(1, Math.ceil(this._collectionSize / this.pageSize));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPagination.prototype, "page", {
        get: /**
         * @return {?}
         */
        function () {
            return this._page;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setPage(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPagination.prototype, "pages", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPagination.prototype, "hasNavigationLinks", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var maxSize = this._maxSize || this.pageCount;
            return this._hasNavigationLinks || maxSize < this.pageCount;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hasNavigationLinks = value;
        },
        enumerable: true,
        configurable: true
    });
    // Public methods
    // Public methods
    /**
     * @return {?}
     */
    FuiPagination.prototype.hasPrevious = 
    // Public methods
    /**
     * @return {?}
     */
    function () {
        return this.page > 1;
    };
    /**
     * @return {?}
     */
    FuiPagination.prototype.hasNext = /**
     * @return {?}
     */
    function () {
        return this.page < this.pageCount;
    };
    /**
     * @param {?} newPage
     * @return {?}
     */
    FuiPagination.prototype.setPage = /**
     * @param {?} newPage
     * @return {?}
     */
    function (newPage) {
        /** @type {?} */
        var value = (Number.isInteger(newPage)) ? Math.min(Math.max(newPage, 1), this.pageCount) : 1;
        if (value !== this._page) {
            this._page = value;
            this.pageChange.emit(this._page);
        }
    };
    // Lifecycle hooks
    // Lifecycle hooks
    /**
     * @return {?}
     */
    FuiPagination.prototype.ngOnChanges = 
    // Lifecycle hooks
    /**
     * @return {?}
     */
    function () {
        this.updatePages();
    };
    // Private methods
    // Private methods
    /**
     * @private
     * @return {?}
     */
    FuiPagination.prototype.updatePages = 
    // Private methods
    /**
     * @private
     * @return {?}
     */
    function () {
        this.pageCount = Math.max(1, Math.ceil(this._collectionSize / this.pageSize));
        var _a = __read(this.applyPagination(), 2), start = _a[0], end = _a[1];
        this._pages = Array(end - start)
            .fill(start + 1)
            .map((/**
         * @param {?} s
         * @param {?} i
         * @return {?}
         */
        function (s, i) { return s + i; }));
    };
    /**
     * @private
     * @return {?}
     */
    FuiPagination.prototype.applyPagination = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var maxSize = (this.maxSize != undefined) ? Math.min(this.maxSize, this.pageCount) : this.pageCount;
        /** @type {?} */
        var page = Math.ceil(this.page / maxSize) - 1;
        /** @type {?} */
        var start = 0;
        /** @type {?} */
        var end = this.pageCount;
        if (this.canRotate) {
            /** @type {?} */
            var leftOffset = Math.floor(maxSize / 2);
            /** @type {?} */
            var rightOffset = maxSize % 2 === 0 ? leftOffset - 1 : leftOffset;
            if (this.page <= leftOffset) {
                end = maxSize;
            }
            else if (this.pageCount - this.page < leftOffset) {
                start = this.pageCount - maxSize;
            }
            else {
                start = this.page - leftOffset - 1;
                end = this.page + rightOffset;
            }
        }
        else {
            start = page * maxSize;
            end = start + maxSize;
        }
        return [start, Math.min(end, this.pageCount)];
    };
    FuiPagination.decorators = [
        { type: Component, args: [{
                    selector: 'fui-pagination',
                    template: "\n<a *ngIf=\"hasBoundaryLinks\" class=\"item\"  (click)=\"setPage(1)\" [class.disabled]=\"page===1\">\n    <span><i class=\"angle double left icon\"></i></span>\n</a>\n<a *ngIf=\"hasNavigationLinks\" class=\"item\" (click)=\"setPage(page-1)\" [class.disabled]=\"!hasPrevious()\">\n    <span><i class=\"angle left icon\"></i></span>\n</a>\n<ng-container *ngIf=\"hasEllipses\">\n    <a class=\"item\" (click)=\"setPage(1)\" *ngIf=\"pages[0] !== 1\">\n        <span>1</span>\n    </a>\n    <a class=\"disabled item\" *ngIf=\"pages[0] > 2\">...</a>\n</ng-container>\n<a *ngFor=\"let p of pages\" class=\"item\" [class.active]=\"p===page\" (click)=\"setPage(p)\">\n    {{ p }}\n</a>\n<ng-container *ngIf=\"hasEllipses\">\n    <a class=\"disabled item\" *ngIf=\"pages[pages.length - 1] < pageCount - 1\">...</a>\n    <a class=\"item\" (click)=\"setPage(pageCount)\" *ngIf=\"pages[pages.length - 1] !== pageCount\">\n        <span>{{ pageCount }}</span>\n    </a>\n</ng-container>\n<a *ngIf=\"hasNavigationLinks\" class=\"item\" (click)=\"setPage(page+1)\" [class.disabled]=\"!hasNext()\">\n    <span><i class=\"angle right icon\"></i></span>\n</a>\n<a *ngIf=\"hasBoundaryLinks\" class=\"item\"  (click)=\"setPage(pageCount)\" [class.disabled]=\"page===pageCount\">\n    <span><i class=\"angle double right icon\"></i></span>\n</a>\n",
                    styles: ["\n:host .item {\n    transition: none;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiPagination.ctorParameters = function () { return []; };
    FuiPagination.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.pagination',] }, { type: HostBinding, args: ['class.menu',] }],
        pageChange: [{ type: Output }],
        pageSize: [{ type: Input }],
        hasBoundaryLinks: [{ type: Input }],
        canRotate: [{ type: Input }],
        hasEllipses: [{ type: Input }],
        maxSize: [{ type: Input }],
        collectionSize: [{ type: Input }],
        page: [{ type: Input }],
        hasNavigationLinks: [{ type: Input }]
    };
    return FuiPagination;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiPaginationModule = /** @class */ (function () {
    function FuiPaginationModule() {
    }
    FuiPaginationModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    exports: [FuiPagination],
                    declarations: [FuiPagination],
                    providers: []
                },] }
    ];
    return FuiPaginationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiAccordionPanel = /** @class */ (function () {
    function FuiAccordionPanel(_changeDetector) {
        this._changeDetector = _changeDetector;
        this.transitionController = new TransitionController(false);
        this._isOpen = false;
        this.isOpenChange = new EventEmitter(false);
    }
    Object.defineProperty(FuiAccordionPanel.prototype, "transition", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._service) {
                return this._service.transition;
            }
            return 'fade';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiAccordionPanel.prototype, "transitionDuration", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._service) {
                // Return the service defined transition duration.
                return this._service.transitionDuration;
            }
            // Revert to instantaneous if the service is not yet loaded.
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiAccordionPanel.prototype, "service", {
        set: /**
         * @param {?} service
         * @return {?}
         */
        function (service) {
            this._service = service;
            this._changeDetector.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiAccordionPanel.prototype, "isOpen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isOpen;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // Convert to boolean (fixes false != undefined)
            /** @type {?} */
            var isOpen = !!value;
            if (isOpen !== this.isOpen) {
                // Only update if the value has changed.
                this._isOpen = isOpen;
                if (isOpen && this._service) {
                    // If we are opening this panel, we must close the other ones.
                    this._service.closeOtherPanels(this);
                }
                this.isOpenChange.emit(this.isOpen);
                // Cancel all current animations, and fade the contents. The direction is automatic.
                this.transitionController.stopAll();
                this.transitionController.animate(new Transition(this.transition, this.transitionDuration));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiAccordionPanel.prototype.toggle = /**
     * @return {?}
     */
    function () {
        if (!this.isDisabled) {
            this.isOpen = !this.isOpen;
        }
    };
    FuiAccordionPanel.decorators = [
        { type: Component, args: [{
                    selector: 'fui-accordion-panel',
                    exportAs: 'fuiAccordionPanel',
                    template: "\n<!-- Title -->\n<div class=\"title\" [class.active]=\"isOpen\" (click)=\"toggle()\" >\n    <ng-content select=\"[title]\"></ng-content>\n</div>\n<!-- Content -->\n<div [fuiCollapse]=\"!isOpen\" [collapseDuration]=\"transitionDuration\">\n    <div class=\"content\" [class.active]=\"isOpen\" [fuiTransition]=\"transitionController\">\n        <ng-content select=\"[content]\"></ng-content>\n    </div>\n</div>\n",
                    styles: ["\n/* Manual style as Fomantic UI relies on > selector */\n.content {\n    padding: .5em 0 1em;\n}\n\n/* Another > selector fix */\n:host:first-child .title {\n    border-top: none;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiAccordionPanel.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    FuiAccordionPanel.propDecorators = {
        isDisabled: [{ type: Input }],
        isOpenChange: [{ type: Output }],
        isOpen: [{ type: Input }]
    };
    return FuiAccordionPanel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiAccordionService = /** @class */ (function () {
    function FuiAccordionService() {
        this.closeOthers = true;
        this.transition = 'fade';
        this.transitionDuration = 350;
        this.panels = [];
    }
    /**
     * @param {?} panel
     * @return {?}
     */
    FuiAccordionService.prototype.addPanel = /**
     * @param {?} panel
     * @return {?}
     */
    function (panel) {
        panel.service = this;
        this.panels.push(panel);
    };
    /**
     * @param {?} panel
     * @return {?}
     */
    FuiAccordionService.prototype.closeOtherPanels = /**
     * @param {?} panel
     * @return {?}
     */
    function (panel) {
        if (!this.closeOthers) {
            return;
        }
        this.panels.forEach((/**
         * @param {?} p
         * @return {?}
         */
        function (p) {
            if (p !== panel) {
                p.isOpen = false;
            }
        }));
    };
    return FuiAccordionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiAccordion = /** @class */ (function () {
    function FuiAccordion() {
        // Accordion service is unique to each set of panels.
        this._service = new FuiAccordionService();
        this.hasClasses = true;
    }
    Object.defineProperty(FuiAccordion.prototype, "closeOthers", {
        get: /**
         * @return {?}
         */
        function () {
            return this._service.closeOthers;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._service.closeOthers = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiAccordion.prototype, "transition", {
        set: /**
         * @param {?} transition
         * @return {?}
         */
        function (transition) {
            this._service.transition = transition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiAccordion.prototype, "transitionDuration", {
        set: /**
         * @param {?} duration
         * @return {?}
         */
        function (duration) {
            this._service.transitionDuration = duration;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiAccordion.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.updatePanels();
        // Reconnect panels after they have updated.
        this._panels.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.updatePanels(); }));
    };
    /**
     * @return {?}
     */
    FuiAccordion.prototype.updatePanels = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._panels.forEach((/**
         * @param {?} p
         * @return {?}
         */
        function (p) { return _this._service.addPanel(p); }));
    };
    FuiAccordion.decorators = [
        { type: Component, args: [{
                    selector: 'fui-accordion',
                    template: "\n<ng-content></ng-content>\n",
                    styles: ["\n/* Fix for general styling issues */\n:host {\n    display: block;\n}\n\n/* Fix for styled border issue */\n:host.styled fui-accordion-panel:first-child .title {\n    border-top: none\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiAccordion.ctorParameters = function () { return []; };
    FuiAccordion.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.accordion',] }],
        _panels: [{ type: ContentChildren, args: [FuiAccordionPanel,] }],
        closeOthers: [{ type: Input }],
        transition: [{ type: Input }],
        transitionDuration: [{ type: Input }]
    };
    return FuiAccordion;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiCollapse = /** @class */ (function () {
    function FuiCollapse(_element, _renderer) {
        this._element = _element;
        this._renderer = _renderer;
        this._pristine = true;
        // Collapse animation duration is 350ms by default.
        this.collapseDuration = 350;
        this._isExpanded = false;
        this._isCollapsing = false;
    }
    Object.defineProperty(FuiCollapse.prototype, "isCollapsed", {
        // Set when the collapse is closed, and not animating.
        get: 
        // Set when the collapse is closed, and not animating.
        /**
         * @return {?}
         */
        function () {
            return !this.isExpanded && !this.isCollapsing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiCollapse.prototype, "fuiCollapse", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isExpanded;
        },
        // Sets the state of the collapse, `true` is collapsed.
        set: 
        // Sets the state of the collapse, `true` is collapsed.
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.hide();
            }
            else {
                this.show();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiCollapse.prototype, "isExpanded", {
        // Set when the collapse is open, and not animating.
        get: 
        // Set when the collapse is open, and not animating.
        /**
         * @return {?}
         */
        function () {
            return this._isExpanded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiCollapse.prototype, "isCollapsing", {
        // Set when the collapse is animating.
        get: 
        // Set when the collapse is animating.
        /**
         * @return {?}
         */
        function () {
            return this._isCollapsing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiCollapse.prototype, "_animationDuration", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._pristine ? 0 : this.collapseDuration;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiCollapse.prototype.hide = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._isCollapsing = true;
        this._isExpanded = false;
        // Forcibly hide the overflow so that content is not visible past the boundaries of its container.
        this._renderer.setStyle(this._element.nativeElement, 'overflow', 'hidden');
        // Animate the host element from its scroll height to 0.
        this.animate(this._element.nativeElement.scrollHeight, 0, false, (/**
         * @return {?}
         */
        function () {
            _this._isCollapsing = false;
        }));
    };
    /**
     * @return {?}
     */
    FuiCollapse.prototype.show = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._isCollapsing = true;
        // Animate the host element from its offset height to its scroll height.
        this.animate(this._element.nativeElement.offsetHeight, this._element.nativeElement.scrollHeight, true, (/**
         * @return {?}
         */
        function () {
            // Remove the overflow override to enable user styling once again.
            _this._renderer.removeStyle(_this._element.nativeElement, 'overflow');
            _this._isCollapsing = false;
            _this._isExpanded = true;
        }));
    };
    /**
     * @private
     * @param {?} startHeight
     * @param {?} endHeight
     * @param {?=} removeOnComplete
     * @param {?=} callback
     * @return {?}
     */
    FuiCollapse.prototype.animate = /**
     * @private
     * @param {?} startHeight
     * @param {?} endHeight
     * @param {?=} removeOnComplete
     * @param {?=} callback
     * @return {?}
     */
    function (startHeight, endHeight, removeOnComplete, callback) {
        if (removeOnComplete === void 0) { removeOnComplete = false; }
        if (callback === void 0) { callback = (/**
         * @return {?}
         */
        function () {
        }); }
        /** @type {?} */
        var heightFrames = [
            {
                offset: 0,
                height: startHeight + "px"
            },
            {
                offset: 1,
                height: endHeight + "px"
            }
        ];
        if (removeOnComplete) {
            heightFrames.push({
                offset: 1,
                height: "auto"
            });
        }
        // Animate the collapse using the web animations API.
        // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
        this._element.nativeElement.animate(heightFrames, {
            delay: 0,
            // Disable animation on 1st collapse / expansion.
            duration: this._animationDuration,
            iterations: 1,
            easing: 'ease',
            fill: 'both'
        });
        if (this._pristine) {
            // Remove pristine flag when first hit.
            this._pristine = false;
        }
        setTimeout((/**
         * @return {?}
         */
        function () { return callback(); }), this.collapseDuration);
    };
    FuiCollapse.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiCollapse]'
                },] }
    ];
    /** @nocollapse */
    FuiCollapse.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    FuiCollapse.propDecorators = {
        collapseDuration: [{ type: Input }],
        isCollapsed: [{ type: HostBinding, args: ['class.collapsed',] }],
        fuiCollapse: [{ type: Input }],
        isExpanded: [{ type: HostBinding, args: ['class.expanded',] }],
        isCollapsing: [{ type: HostBinding, args: ['class.collapsing',] }]
    };
    return FuiCollapse;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiCollapseModule = /** @class */ (function () {
    function FuiCollapseModule() {
    }
    FuiCollapseModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        FuiCollapse
                    ],
                    exports: [
                        FuiCollapse
                    ]
                },] }
    ];
    return FuiCollapseModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiAccordionModule = /** @class */ (function () {
    function FuiAccordionModule() {
    }
    FuiAccordionModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FuiCollapseModule,
                        FuiTransitionModule
                    ],
                    declarations: [
                        FuiAccordion,
                        FuiAccordionPanel
                    ],
                    exports: [
                        FuiAccordion,
                        FuiAccordionPanel
                    ],
                    providers: []
                },] }
    ];
    return FuiAccordionModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiCheckbox = /** @class */ (function () {
    function FuiCheckbox() {
        this.isChecked = false;
        this.onCheckChange = new EventEmitter();
        this.onTouched = new EventEmitter();
        this.isDisabled = false;
        this.isReadonly = false;
        this.hasClasses = true;
    }
    Object.defineProperty(FuiCheckbox.prototype, "checkedAttribute", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isChecked ? '' : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiCheckbox.prototype, "isDisabledAttribute", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isDisabled ? 'disabled' : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @return {?}
     */
    FuiCheckbox.prototype.onMouseDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.preventDefault();
    };
    /**
     * @return {?}
     */
    FuiCheckbox.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (!this.isDisabled && !this.isReadonly) {
            this.toggle();
            this.focusCheckbox();
        }
    };
    /**
     * @return {?}
     */
    FuiCheckbox.prototype.onFocusOut = /**
     * @return {?}
     */
    function () {
        this.onTouched.emit();
    };
    /**
     * @return {?}
     */
    FuiCheckbox.prototype.toggle = /**
     * @return {?}
     */
    function () {
        this.isChecked = !this.isChecked;
        this.onCheckChange.emit(this.isChecked);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    FuiCheckbox.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.isChecked = value;
    };
    /**
     * @private
     * @return {?}
     */
    FuiCheckbox.prototype.focusCheckbox = /**
     * @private
     * @return {?}
     */
    function () {
        this._checkboxElement.nativeElement.focus();
    };
    FuiCheckbox.decorators = [
        { type: Component, args: [{
                    selector: 'fui-checkbox',
                    exportAs: 'fuiCheckbox',
                    template: "\n<input class=\"hidden\"\n       type=\"checkbox\"\n       [attr.name]=\"name\"\n       [attr.checked]=\"checkedAttribute\"\n       [attr.disabled]=\"isDisabledAttribute\"\n       [(ngModel)]=\"isChecked\"\n       #checkbox>\n<label>\n    <ng-content></ng-content>\n</label>\n"
                }] }
    ];
    /** @nocollapse */
    FuiCheckbox.ctorParameters = function () { return []; };
    FuiCheckbox.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.checkbox',] }],
        name: [{ type: Input }],
        isChecked: [{ type: HostBinding, args: ['class.checked',] }],
        onCheckChange: [{ type: Output, args: ['checkChange',] }],
        onTouched: [{ type: Output, args: ['touched',] }],
        isDisabled: [{ type: Input }],
        isReadonly: [{ type: HostBinding, args: ['class.read-only',] }, { type: Input }],
        _checkboxElement: [{ type: ViewChild, args: ['checkbox', { static: false },] }],
        onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
        onClick: [{ type: HostListener, args: ['click',] }],
        onFocusOut: [{ type: HostListener, args: ['focusout',] }]
    };
    return FuiCheckbox;
}());
var FuiCheckboxValueAccessor = /** @class */ (function (_super) {
    __extends(FuiCheckboxValueAccessor, _super);
    function FuiCheckboxValueAccessor(host) {
        return _super.call(this, host) || this;
    }
    FuiCheckboxValueAccessor.decorators = [
        { type: Directive, args: [{
                    selector: 'fui-checkbox',
                    host: {
                        '(checkChange)': 'onChange($event)',
                        '(touched)': 'onTouched()'
                    },
                    providers: [customValueAccessorFactory(FuiCheckboxValueAccessor)]
                },] }
    ];
    /** @nocollapse */
    FuiCheckboxValueAccessor.ctorParameters = function () { return [
        { type: FuiCheckbox }
    ]; };
    return FuiCheckboxValueAccessor;
}(CustomValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var FuiRadio = /** @class */ (function () {
    function FuiRadio() {
        this.isChecked = false;
        this.onCurrentValueChange = new EventEmitter();
        this.onTouched = new EventEmitter();
        this.isDisabled = false;
        this.isReadonly = false;
        this.hasClasses = true;
    }
    Object.defineProperty(FuiRadio.prototype, "checkedAttribute", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isChecked ? '' : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiRadio.prototype, "isDisabledAttribute", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isDisabled ? 'disabled' : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @return {?}
     */
    FuiRadio.prototype.onMouseDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.preventDefault();
    };
    /**
     * @return {?}
     */
    FuiRadio.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (!this.isDisabled && !this.isReadonly) {
            this.currentValue = this.value;
            this.onCurrentValueChange.emit(this.currentValue);
            this.update();
            this.focusRadio();
        }
    };
    /**
     * @return {?}
     */
    FuiRadio.prototype.onFocusOut = /**
     * @return {?}
     */
    function () {
        this.onTouched.emit();
    };
    /**
     * @return {?}
     */
    FuiRadio.prototype.update = /**
     * @return {?}
     */
    function () {
        this.isChecked = this.currentValue === this.value;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    FuiRadio.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.currentValue = value;
        this.update();
    };
    /**
     * @private
     * @return {?}
     */
    FuiRadio.prototype.focusRadio = /**
     * @private
     * @return {?}
     */
    function () {
        this._radioElement.nativeElement.focus();
    };
    FuiRadio.decorators = [
        { type: Component, args: [{
                    selector: 'fui-radio-button',
                    template: "\n<input class=\"hidden\"\n       type=\"checkbox\"\n       [attr.name]=\"name\"\n       [attr.checked]=\"checkedAttribute\"\n       [attr.disabled]=\"isDisabledAttribute\"\n       [ngModel]=\"isChecked\"\n       (ngModel)=\"currentValue = value\"\n       #radio>\n<label>\n    <ng-content></ng-content>\n</label>\n"
                }] }
    ];
    /** @nocollapse */
    FuiRadio.ctorParameters = function () { return []; };
    FuiRadio.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.radio',] }, { type: HostBinding, args: ['class.checkbox',] }],
        name: [{ type: Input }],
        value: [{ type: Input }],
        isChecked: [{ type: HostBinding, args: ['class.checked',] }],
        onCurrentValueChange: [{ type: Output, args: ['currentValueChange',] }],
        onTouched: [{ type: Output, args: ['touched',] }],
        isDisabled: [{ type: Input }],
        isReadonly: [{ type: HostBinding, args: ['class.read-only',] }, { type: Input }],
        _radioElement: [{ type: ViewChild, args: ['radio', { static: false },] }],
        onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
        onClick: [{ type: HostListener, args: ['click',] }],
        onFocusOut: [{ type: HostListener, args: ['focusout',] }]
    };
    return FuiRadio;
}());
/**
 * @template T
 */
var FuiRadioValueAccessor = /** @class */ (function (_super) {
    __extends(FuiRadioValueAccessor, _super);
    function FuiRadioValueAccessor(host) {
        return _super.call(this, host) || this;
    }
    FuiRadioValueAccessor.decorators = [
        { type: Directive, args: [{
                    selector: 'fui-radio-button',
                    host: {
                        '(currentValueChange)': 'onChange($event)',
                        '(touched)': 'onTouched()'
                    },
                    providers: [customValueAccessorFactory(FuiRadioValueAccessor)]
                },] }
    ];
    /** @nocollapse */
    FuiRadioValueAccessor.ctorParameters = function () { return [
        { type: FuiRadio }
    ]; };
    return FuiRadioValueAccessor;
}(CustomValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var FuiRadioManager = /** @class */ (function () {
    function FuiRadioManager(element) {
        this.element = element;
        this.isNested = false;
        this._radioSubs = [];
    }
    /**
     * @return {?}
     */
    FuiRadioManager.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.updateNesting();
        this._subManagers.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.updateNesting(); }));
        this.updateRadios();
        this._renderedRadios.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.updateRadios(); }));
    };
    /**
     * @private
     * @return {?}
     */
    FuiRadioManager.prototype.updateNesting = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._subManagers
            .filter((/**
         * @param {?} m
         * @return {?}
         */
        function (m) { return m !== _this; }))
            .forEach((/**
         * @param {?} m
         * @return {?}
         */
        function (m) { return m.isNested = true; }));
    };
    /**
     * @private
     * @return {?}
     */
    FuiRadioManager.prototype.updateRadios = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._radioSubs.forEach((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return s.unsubscribe(); }));
        this._radioSubs = [];
        /** @type {?} */
        var groups = Util.Array.groupBy(this._renderedRadios.toArray(), 'name');
        Object
            .keys(groups)
            .map((/**
         * @param {?} k
         * @return {?}
         */
        function (k) { return groups[k]; }))
            .forEach((/**
         * @param {?} g
         * @return {?}
         */
        function (g) { return g
            .forEach((/**
         * @param {?} r
         * @return {?}
         */
        function (r) { return _this._radioSubs
            .push(r.onCurrentValueChange
            .subscribe((/**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (!_this.isNested) {
                g.forEach((/**
                 * @param {?} radio
                 * @return {?}
                 */
                function (radio) { return radio.writeValue(v); }));
            }
        }))); })); }));
    };
    FuiRadioManager.decorators = [
        { type: Directive, args: [{
                    selector: 'form:not([ngForm]):not([[ngForm]]),ngForm,[ngForm]'
                },] }
    ];
    /** @nocollapse */
    FuiRadioManager.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    FuiRadioManager.propDecorators = {
        _subManagers: [{ type: ContentChildren, args: [FuiRadioManager, { descendants: true },] }],
        _renderedRadios: [{ type: ContentChildren, args: [FuiRadio, { descendants: true },] }]
    };
    return FuiRadioManager;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiCheckboxModule = /** @class */ (function () {
    function FuiCheckboxModule() {
    }
    FuiCheckboxModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule
                    ],
                    declarations: [
                        FuiCheckbox,
                        FuiCheckboxValueAccessor,
                        FuiRadio,
                        FuiRadioValueAccessor,
                        FuiRadioManager
                    ],
                    exports: [
                        FuiCheckbox,
                        FuiCheckboxValueAccessor,
                        FuiRadio,
                        FuiRadioValueAccessor,
                        FuiRadioManager
                    ]
                },] }
    ];
    return FuiCheckboxModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var CalendarMode = {
    DateOnly: 0,
    TimeOnly: 1,
    Both: 2,
};
CalendarMode[CalendarMode.DateOnly] = 'DateOnly';
CalendarMode[CalendarMode.TimeOnly] = 'TimeOnly';
CalendarMode[CalendarMode.Both] = 'Both';
var CalendarService = /** @class */ (function () {
    function CalendarService(config, localeValues) {
        this.localeValues = localeValues;
        this.onManualUpdate = (/**
         * @return {?}
         */
        function () {
        });
        this.config = config;
        this.currentDate = new Date();
        this.firstDayOfWeek = this.localeValues.firstDayOfWeek;
        this.onDateChange = new EventEmitter();
        this.reset();
    }
    Object.defineProperty(CalendarService.prototype, "inFinalView", {
        get: /**
         * @return {?}
         */
        function () {
            return this.currentView === this.config.mappings.finalView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarService.prototype, "config", {
        get: /**
         * @return {?}
         */
        function () {
            return this._config;
        },
        set: /**
         * @param {?} config
         * @return {?}
         */
        function (config) {
            this._config = config;
            config.updateBounds(this._selectedDate || this.currentDate);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarService.prototype, "selectedDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectedDate;
        },
        set: /**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            if (date) {
                this._selectedDate = DateUtil.clone(date);
                this.currentDate = DateUtil.clone(date);
            }
            else {
                this._selectedDate = undefined;
            }
            this.config.updateBounds(this._selectedDate || this.currentDate);
            this.onManualUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarService.prototype, "minDate", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._minDate && this.config.dateMinBound) {
                return this._minDate > this.config.dateMinBound ? this._minDate : this.config.dateMinBound;
            }
            return this._minDate || this.config.dateMinBound;
        },
        set: /**
         * @param {?} min
         * @return {?}
         */
        function (min) {
            this._minDate = min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarService.prototype, "maxDate", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._maxDate && this.config.dateMaxBound) {
                return this._maxDate < this.config.dateMaxBound ? this._maxDate : this.config.dateMaxBound;
            }
            return this._maxDate || this.config.dateMaxBound;
        },
        set: /**
         * @param {?} max
         * @return {?}
         */
        function (max) {
            this._maxDate = max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarService.prototype, "firstDayOfWeek", {
        get: /**
         * @return {?}
         */
        function () {
            return this._firstDayOfWeek;
        },
        set: /**
         * @param {?} firstDayOfWeek
         * @return {?}
         */
        function (firstDayOfWeek) {
            if (firstDayOfWeek != undefined) {
                this._firstDayOfWeek = Math.max(0, Math.min(6, firstDayOfWeek));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CalendarService.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.currentView = this.config.mappings.finalView;
        if (!this._selectedDate) {
            /** @type {?} */
            var current = this.currentDate.getTime();
            if (this._minDate) {
                current = Math.max(current, this._minDate.getTime());
            }
            if (this._maxDate) {
                current = Math.min(current, this._maxDate.getTime());
            }
            this.currentDate = new Date(current);
            this.config.updateBounds(this.currentDate);
            this.currentView = this.config.mappings.initialView;
        }
    };
    /**
     * @param {?} date
     * @param {?} fromView
     * @return {?}
     */
    CalendarService.prototype.changeDate = /**
     * @param {?} date
     * @param {?} fromView
     * @return {?}
     */
    function (date, fromView) {
        this.currentDate = date;
        if (fromView === this.config.mappings.finalView) {
            this.selectedDate = date;
            return this.onDateChange.emit(date);
        }
        this.updateView(this.config.mappings.changed, fromView);
    };
    /**
     * @param {?} fromView
     * @return {?}
     */
    CalendarService.prototype.zoomOut = /**
     * @param {?} fromView
     * @return {?}
     */
    function (fromView) {
        this.updateView(this.config.mappings.zoom, fromView);
    };
    /**
     * @private
     * @param {?} mappings
     * @param {?} fromView
     * @return {?}
     */
    CalendarService.prototype.updateView = /**
     * @private
     * @param {?} mappings
     * @param {?} fromView
     * @return {?}
     */
    function (mappings, fromView) {
        /** @type {?} */
        var mapping = mappings.get(fromView);
        if (mapping == undefined) {
            throw new Error('Unknown view type.');
        }
        this.currentView = mapping;
    };
    return CalendarService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CalendarItem = /** @class */ (function () {
    function CalendarItem(date) {
        this.date = date;
    }
    return CalendarItem;
}());
var FuiCalendarItem = /** @class */ (function () {
    function FuiCalendarItem(changeDetector) {
        this.changeDetector = changeDetector;
        this.hasFocus = false;
        this.onFocussed = new EventEmitter();
    }
    Object.defineProperty(FuiCalendarItem.prototype, "isSelectable", {
        get: /**
         * @return {?}
         */
        function () {
            return this.item.isSelectable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiCalendarItem.prototype, "isActive", {
        get: /**
         * @return {?}
         */
        function () {
            return this.item.isActive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiCalendarItem.prototype, "isToday", {
        get: /**
         * @return {?}
         */
        function () {
            return this.item.isToday;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiCalendarItem.prototype.onMouseMove = /**
     * @return {?}
     */
    function () {
        if (!this.hasFocus) {
            this.hasFocus = true;
            this.onFocussed.emit(this.hasFocus);
        }
    };
    /**
     * @return {?}
     */
    FuiCalendarItem.prototype.onMouseLeave = /**
     * @return {?}
     */
    function () {
        this.hasFocus = false;
        this.onFocussed.emit(this.hasFocus);
    };
    FuiCalendarItem.decorators = [
        { type: Directive, args: [{
                    selector: '[calendarItem]'
                },] }
    ];
    /** @nocollapse */
    FuiCalendarItem.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    FuiCalendarItem.propDecorators = {
        item: [{ type: Input, args: ['calendarItem',] }],
        hasFocus: [{ type: HostBinding, args: ['class.focus',] }],
        isSelectable: [{ type: HostBinding, args: ['class.disabled',] }],
        isActive: [{ type: HostBinding, args: ['class.active',] }],
        isToday: [{ type: HostBinding, args: ['class.today',] }],
        onMouseMove: [{ type: HostListener, args: ['mousemove',] }],
        onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }]
    };
    return FuiCalendarItem;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var CalendarViewType = {
    Year: 0,
    Month: 1,
    Date: 2,
    Hour: 3,
    Minute: 4,
};
CalendarViewType[CalendarViewType.Year] = 'Year';
CalendarViewType[CalendarViewType.Month] = 'Month';
CalendarViewType[CalendarViewType.Date] = 'Date';
CalendarViewType[CalendarViewType.Hour] = 'Hour';
CalendarViewType[CalendarViewType.Minute] = 'Minute';
/**
 * @abstract
 */
var CalendarView = /** @class */ (function () {
    function CalendarView(renderer, viewType, ranges) {
        var _this = this;
        this._type = viewType;
        this.ranges = ranges;
        this._documentKeyDownListener = renderer.listen('document', 'keydown', (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.onDocumentKeyDown(e); }));
    }
    Object.defineProperty(CalendarView.prototype, "currentDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.currentDate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarView.prototype, "selectedDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.selectedDate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarView.prototype, "service", {
        get: /**
         * @return {?}
         */
        function () {
            return this._service;
        },
        set: /**
         * @param {?} service
         * @return {?}
         */
        function (service) {
            var _this = this;
            this._service = service;
            this.ranges.loadService(service);
            this.service.onManualUpdate = (/**
             * @return {?}
             */
            function () {
                _this.ranges.refresh();
                delete _this._highlightedItem;
                _this.autoHighlight();
            });
        },
        enumerable: true,
        configurable: true
    });
    // Template Methods
    // Template Methods
    /**
     * @param {?} item
     * @return {?}
     */
    CalendarView.prototype.setDate = 
    // Template Methods
    /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.service.changeDate(item.date, this._type);
    };
    /**
     * @return {?}
     */
    CalendarView.prototype.zoomOut = /**
     * @return {?}
     */
    function () {
        this.service.zoomOut(this._type);
    };
    // Keyboard Control
    // Keyboard Control
    /**
     * @return {?}
     */
    CalendarView.prototype.ngAfterViewInit = 
    // Keyboard Control
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._renderedItems.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.onRenderedItemsChanged(); }));
        this.onRenderedItemsChanged();
    };
    /**
     * @return {?}
     */
    CalendarView.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._documentKeyDownListener();
    };
    /**
     * @private
     * @return {?}
     */
    CalendarView.prototype.onRenderedItemsChanged = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._renderedItems.forEach((/**
         * @param {?} i
         * @return {?}
         */
        function (i) {
            return i.onFocussed.subscribe((/**
             * @param {?} hasFocus
             * @return {?}
             */
            function (hasFocus) {
                if (hasFocus) {
                    _this.highlightItem(i.item);
                }
            }));
        }));
        this.autoHighlight();
        this.highlightItem(this._highlightedItem);
    };
    /**
     * @private
     * @return {?}
     */
    CalendarView.prototype.autoHighlight = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var date = this.selectedDate && this.ranges.current.containsDate(this.selectedDate) ? this.selectedDate : this.currentDate;
        if (this._highlightedItem && this.ranges.current.containsDate(this._highlightedItem.date)) {
            date = this._highlightedItem.date;
        }
        /** @type {?} */
        var initiallyHighlighted = this.ranges.current.items.find((/**
         * @param {?} i
         * @return {?}
         */
        function (i) { return _this.ranges.dateComparer.equal(i.date, date); }));
        if (initiallyHighlighted && !initiallyHighlighted.isDisabled) {
            this._highlightedItem = initiallyHighlighted;
        }
    };
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    CalendarView.prototype.highlightItem = /**
     * @private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item) {
            this._renderedItems.forEach((/**
             * @param {?} i
             * @return {?}
             */
            function (i) { return i.hasFocus = false; }));
            /** @type {?} */
            var rendered = this._renderedItems.find((/**
             * @param {?} ri
             * @return {?}
             */
            function (ri) { return ri.item === item; }));
            if (rendered && !rendered.hasFocus) {
                rendered.hasFocus = true;
                rendered.changeDetector.detectChanges();
            }
            this._highlightedItem = item;
        }
    };
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    CalendarView.prototype.onDocumentKeyDown = /**
     * @private
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (this._highlightedItem && e.keyCode === KeyCode.Enter) {
            this.setDate(this._highlightedItem);
            return;
        }
        if (!this._highlightedItem) {
            this.autoHighlight();
        }
        /** @type {?} */
        var index = this.ranges.current.findIndex(this._highlightedItem);
        /** @type {?} */
        var isMovingForward = true;
        /** @type {?} */
        var delta = 0;
        switch (e.keyCode) {
            case KeyCode.Right:
                delta += 1;
                break;
            case KeyCode.Left:
                delta -= 1;
                isMovingForward = false;
                break;
            case KeyCode.Down:
                delta += this.ranges.columns;
                break;
            case KeyCode.Up:
                delta -= this.ranges.columns;
                isMovingForward = false;
                break;
            default:
                return;
        }
        // Stop these keypresses being captured elsewhere.
        e.preventDefault();
        /** @type {?} */
        var nextItem = this.ranges.current.items[index + delta];
        if (nextItem && nextItem.isDisabled) {
            return;
        }
        if (nextItem && !nextItem.isOutsideRange) {
            return this.highlightItem(nextItem);
        }
        if (nextItem && nextItem.isOutsideRange) {
            if (index + delta >= this.ranges.current.inRange.length) {
                isMovingForward = true;
            }
        }
        if (!nextItem) {
            /** @type {?} */
            var adjustedIndex = this.ranges.current.findIndex(this._highlightedItem);
            /** @type {?} */
            var nextItems = this.ranges.calc(isMovingForward).inRange;
            if (isMovingForward) {
                adjustedIndex -= this.ranges.current.inRange.length;
            }
            else {
                adjustedIndex += nextItems.length;
            }
            nextItem = nextItems[adjustedIndex + delta];
            if (nextItem.isDisabled) {
                return;
            }
        }
        this.ranges.move(isMovingForward);
        this._highlightedItem = this.ranges.current.find(nextItem);
    };
    CalendarView.propDecorators = {
        _renderedItems: [{ type: ViewChildren, args: [FuiCalendarItem,] }],
        service: [{ type: Input }]
    };
    return CalendarView;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var /**
 * @abstract
 */
CalendarMappings = /** @class */ (function () {
    function CalendarMappings() {
    }
    return CalendarMappings;
}());
var DateMappings = /** @class */ (function (_super) {
    __extends(DateMappings, _super);
    function DateMappings() {
        var _this = _super.call(this) || this;
        _this.initialView = CalendarViewType.Date;
        _this.finalView = CalendarViewType.Date;
        _this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Date],
            [CalendarViewType.Date, CalendarViewType.Date]
        ]);
        _this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Date],
            [CalendarViewType.Month, CalendarViewType.Year],
            [CalendarViewType.Date, CalendarViewType.Month]
        ]);
        return _this;
    }
    return DateMappings;
}(CalendarMappings));
var TimeMappings = /** @class */ (function (_super) {
    __extends(TimeMappings, _super);
    function TimeMappings() {
        var _this = _super.call(this) || this;
        _this.initialView = CalendarViewType.Hour;
        _this.finalView = CalendarViewType.Minute;
        _this.changed = new Map([
            [CalendarViewType.Hour, CalendarViewType.Minute],
            [CalendarViewType.Minute, CalendarViewType.Minute]
        ]);
        _this.zoom = new Map([
            [CalendarViewType.Hour, CalendarViewType.Minute],
            [CalendarViewType.Minute, CalendarViewType.Hour]
        ]);
        return _this;
    }
    return TimeMappings;
}(CalendarMappings));
var DatetimeMappings = /** @class */ (function (_super) {
    __extends(DatetimeMappings, _super);
    function DatetimeMappings() {
        var _this = _super.call(this) || this;
        _this.initialView = CalendarViewType.Date;
        _this.finalView = CalendarViewType.Minute;
        _this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Date],
            [CalendarViewType.Date, CalendarViewType.Hour],
            [CalendarViewType.Hour, CalendarViewType.Minute],
            [CalendarViewType.Minute, CalendarViewType.Minute]
        ]);
        _this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Date],
            [CalendarViewType.Month, CalendarViewType.Year],
            [CalendarViewType.Date, CalendarViewType.Month],
            [CalendarViewType.Hour, CalendarViewType.Date],
            [CalendarViewType.Minute, CalendarViewType.Hour]
        ]);
        return _this;
    }
    return DatetimeMappings;
}(CalendarMappings));
var MonthMappings = /** @class */ (function (_super) {
    __extends(MonthMappings, _super);
    function MonthMappings() {
        var _this = _super.call(this) || this;
        _this.initialView = CalendarViewType.Month;
        _this.finalView = CalendarViewType.Month;
        _this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Month]
        ]);
        _this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Year]
        ]);
        return _this;
    }
    return MonthMappings;
}(CalendarMappings));
var YearMappings = /** @class */ (function (_super) {
    __extends(YearMappings, _super);
    function YearMappings() {
        var _this = _super.call(this) || this;
        _this.initialView = CalendarViewType.Year;
        _this.finalView = CalendarViewType.Year;
        _this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Year]
        ]);
        _this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Year]
        ]);
        return _this;
    }
    return YearMappings;
}(CalendarMappings));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var /**
 * @abstract
 */
CalendarConfig = /** @class */ (function () {
    function CalendarConfig(mode, precision, mappings, fallback) {
        this.mode = mode;
        this.precision = precision;
        this.mappings = mappings;
        this.fallback = fallback;
    }
    /**
     * @param {?} providedDate
     * @return {?}
     */
    CalendarConfig.prototype.updateBounds = /**
     * @param {?} providedDate
     * @return {?}
     */
    function (providedDate) {
        this.dateMinBound = DateUtil.startOf(DatePrecision.Year, new Date(), true);
        this.dateMinBound.setFullYear(0);
    };
    return CalendarConfig;
}());
var DateConfigBase = /** @class */ (function (_super) {
    __extends(DateConfigBase, _super);
    function DateConfigBase(precision, mappings, fallback) {
        return _super.call(this, CalendarMode.DateOnly, precision, mappings, fallback) || this;
    }
    return DateConfigBase;
}(CalendarConfig));
var YearConfig = /** @class */ (function (_super) {
    __extends(YearConfig, _super);
    function YearConfig() {
        return _super.call(this, DatePrecision.Year, new YearMappings(), 'number') || this;
    }
    return YearConfig;
}(DateConfigBase));
var MonthConfig = /** @class */ (function (_super) {
    __extends(MonthConfig, _super);
    function MonthConfig() {
        return _super.call(this, DatePrecision.Month, new MonthMappings(), 'month') || this;
    }
    return MonthConfig;
}(DateConfigBase));
var DateConfig = /** @class */ (function (_super) {
    __extends(DateConfig, _super);
    function DateConfig() {
        return _super.call(this, DatePrecision.Date, new DateMappings(), 'date') || this;
    }
    return DateConfig;
}(DateConfigBase));
var DatetimeConfig = /** @class */ (function (_super) {
    __extends(DatetimeConfig, _super);
    function DatetimeConfig() {
        return _super.call(this, CalendarMode.Both, DatePrecision.Minute, new DatetimeMappings(), 'datetime-local') || this;
    }
    return DatetimeConfig;
}(CalendarConfig));
var TimeConfig = /** @class */ (function (_super) {
    __extends(TimeConfig, _super);
    function TimeConfig() {
        return _super.call(this, CalendarMode.TimeOnly, DatePrecision.Minute, new TimeMappings(), 'time') || this;
    }
    /**
     * @param {?} providedDate
     * @return {?}
     */
    TimeConfig.prototype.updateBounds = /**
     * @param {?} providedDate
     * @return {?}
     */
    function (providedDate) {
        this.dateMaxBound = DateUtil.endOf(DatePrecision.Date, DateUtil.clone(providedDate));
        this.dateMinBound = DateUtil.previous(DatePrecision.Date, DateUtil.clone(this.dateMaxBound));
    };
    return TimeConfig;
}(CalendarConfig));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DateComparer = /** @class */ (function () {
    function DateComparer(precision, isSmallest) {
        this._precision = precision;
        this._isSmallest = isSmallest;
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    DateComparer.prototype.equal = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        if (this._precision === DatePrecision.Minute) {
            return !!b &&
                DateUtil.equal(DatePrecision.Hour, b, a) &&
                Util.Math.roundDown(b.getMinutes(), 5) === Util.Math.roundDown(a.getMinutes(), 5);
        }
        return !!b && DateUtil.equal(this._precision, a, b);
    };
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    DateComparer.prototype.lessThan = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        if (this._isSmallest) {
            return !b || (b >= a);
        }
        return !b || (DateUtil.endOf(this._precision, DateUtil.clone(b)) >= a);
    };
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    DateComparer.prototype.greaterThan = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        if (this._isSmallest) {
            return !b || (b <= a);
        }
        return !b || (DateUtil.startOf(this._precision, DateUtil.clone(b)) <= a);
    };
    /**
     * @param {?} date
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    DateComparer.prototype.between = /**
     * @param {?} date
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    function (date, left, right) {
        return this.greaterThan(date, left) && this.lessThan(date, right);
    };
    return DateComparer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} values
 * @param {?} defaultType
 * @param {?=} indexCallback
 * @return {?}
 */
function buildLocalizeFn(values, defaultType, indexCallback) {
    return (/**
     * @param {?} dirtyIndex
     * @param {?=} __1
     * @return {?}
     */
    function (dirtyIndex, _a) {
        var type = (_a === void 0 ? { type: defaultType } : _a).type;
        /** @type {?} */
        var index = indexCallback ? indexCallback(dirtyIndex) : dirtyIndex;
        return values["" + type][index];
    });
}
/**
 * @param {?} values
 * @param {?} defaultType
 * @return {?}
 */
function buildLocalizeArrayFn(values, defaultType) {
    return (/**
     * @param {?=} __0
     * @return {?}
     */
    function (_a) {
        var type = (_a === void 0 ? { type: defaultType } : _a).type;
        return values["" + type];
    });
}
/**
 * @param {?} patterns
 * @param {?} defaultType
 * @return {?}
 */
function buildMatchFn(patterns, defaultType) {
    return (/**
     * @param {?} dirtyString
     * @param {?=} __1
     * @return {?}
     */
    function (dirtyString, _a) {
        var type = (_a === void 0 ? { type: defaultType } : _a).type;
        return dirtyString.match("^(" + patterns["" + type].join('|') + ")");
    });
}
/**
 * @param {?} patterns
 * @param {?} defaultType
 * @return {?}
 */
function buildParseFn(patterns, defaultType) {
    return (/**
     * @param {?} __0
     * @param {?=} __1
     * @return {?}
     */
    function (_a, _b) {
        var _c = __read(_a, 2), result = _c[1];
        var type = (_b === void 0 ? { type: defaultType } : _b).type;
        return (patterns["" + type] || patterns[defaultType])
            .map((/**
         * @param {?} p
         * @return {?}
         */
        function (p) { return new RegExp("^" + p); }))
            .findIndex((/**
         * @param {?} pattern
         * @return {?}
         */
        function (pattern) { return pattern.test(result); }));
    });
}
var DateFnsParser = /** @class */ (function () {
    function DateFnsParser(locale) {
        this._weekStartsOn = (/** @type {?} */ (locale.firstDayOfWeek));
        /** @type {?} */
        var weekdayValues = {
            long: locale.weekdays,
            short: locale.weekdaysShort,
            narrow: locale.weekdaysNarrow
        };
        /** @type {?} */
        var monthValues = {
            long: locale.months,
            short: locale.monthsShort
        };
        /** @type {?} */
        var timeOfDayValues = {
            long: locale.timesOfDay,
            uppercase: locale.timesOfDayUppercase,
            lowercase: locale.timesOfDayLowercase
        };
        /** @type {?} */
        var timeOfDayMatchValues = {
            long: locale.timesOfDay,
            short: locale.timesOfDayUppercase.concat(locale.timesOfDayLowercase)
        };
        this._locale = (/** @type {?} */ (defaultLocale));
        this._locale.localize = __assign({}, this._locale.localize, {
            weekday: buildLocalizeFn(weekdayValues, 'long'),
            weekdays: buildLocalizeArrayFn(weekdayValues, 'long'),
            month: buildLocalizeFn(monthValues, 'long'),
            months: buildLocalizeArrayFn(monthValues, 'long'),
            timeOfDay: buildLocalizeFn(timeOfDayValues, 'long', (/**
             * @param {?} hours
             * @return {?}
             */
            function (hours) {
                return hours / 12 >= 1 ? 1 : 0;
            })),
            timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'long')
        });
        this._locale.match = __assign({}, this._locale.match, {
            weekdays: buildMatchFn(weekdayValues, 'long'),
            weekday: buildParseFn(weekdayValues, 'long'),
            months: buildMatchFn(monthValues, 'long'),
            month: buildParseFn(monthValues, 'long'),
            timesOfDay: buildMatchFn(timeOfDayMatchValues, 'long'),
            timeOfDay: buildParseFn(timeOfDayMatchValues, 'long')
        });
    }
    Object.defineProperty(DateFnsParser.prototype, "_config", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return {
                weekStartsOn: this._weekStartsOn,
                locale: this._locale
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} d
     * @param {?} f
     * @return {?}
     */
    DateFnsParser.prototype.format = /**
     * @param {?} d
     * @param {?} f
     * @return {?}
     */
    function (d, f) {
        return format(d, f, this._config);
    };
    /**
     * @param {?} dS
     * @param {?} f
     * @param {?} bD
     * @return {?}
     */
    DateFnsParser.prototype.parse = /**
     * @param {?} dS
     * @param {?} f
     * @param {?} bD
     * @return {?}
     */
    function (dS, f, bD) {
        return parse(dS, this._config);
    };
    return DateFnsParser;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DateParser = /** @class */ (function () {
    function DateParser(format, locale) {
        this._format = format;
        this._parser = new DateFnsParser(locale);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    DateParser.prototype.format = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this._parser.format(date, this._format);
    };
    /**
     * @param {?} dateString
     * @param {?=} baseDate
     * @return {?}
     */
    DateParser.prototype.parse = /**
     * @param {?} dateString
     * @param {?=} baseDate
     * @return {?}
     */
    function (dateString, baseDate) {
        if (baseDate === void 0) { baseDate = new Date(); }
        return this._parser.parse(dateString, this._format, baseDate);
    };
    return DateParser;
}());
var InternalDateParser = /** @class */ (function (_super) {
    __extends(InternalDateParser, _super);
    function InternalDateParser(mode, locale) {
        var _this = this;
        /** @type {?} */
        var internalFormats = {
            time: 'HH:mm',
            datetime: 'YYYY-MM-DDTHH:mm',
            date: 'YYYY-MM-DD',
            month: 'YYYY-MM',
            year: 'YYYY'
        };
        _this = _super.call(this, internalFormats[mode], locale) || this;
        return _this;
    }
    return InternalDateParser;
}(DateParser));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CalendarRange = /** @class */ (function () {
    function CalendarRange(start, dates, items, grouped, comparer) {
        this.start = start;
        this.dates = dates;
        this.items = items;
        this.groupedItems = grouped;
        this._comparer = comparer;
    }
    Object.defineProperty(CalendarRange.prototype, "inRange", {
        get: /**
         * @return {?}
         */
        function () {
            return this.items.filter((/**
             * @param {?} i
             * @return {?}
             */
            function (i) { return !i.isOutsideRange; }));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} item
     * @return {?}
     */
    CalendarRange.prototype.find = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var _this = this;
        return this.items.find((/**
         * @param {?} i
         * @return {?}
         */
        function (i) { return _this._comparer.equal(i.date, item.date); }));
    };
    /**
     * @param {?} item
     * @return {?}
     */
    CalendarRange.prototype.findIndex = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var _this = this;
        if (!item) {
            return -1;
        }
        return this.items.findIndex((/**
         * @param {?} i
         * @return {?}
         */
        function (i) { return _this._comparer.equal(i.date, item.date); }));
    };
    /**
     * @param {?} date
     * @return {?}
     */
    CalendarRange.prototype.containsDate = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        var _this = this;
        return !!this.inRange.find((/**
         * @param {?} i
         * @return {?}
         */
        function (i) { return _this._comparer.equal(i.date, date); }));
    };
    return CalendarRange;
}());
/**
 * @abstract
 */
var  /**
 * @abstract
 */
CalendarRangeService = /** @class */ (function () {
    function CalendarRangeService(interval, rows, columns) {
        this.interval = interval;
        this.marginal = (/** @type {?} */ (interval)) + 1;
        this.rows = rows;
        this.columns = columns;
    }
    Object.defineProperty(CalendarRangeService.prototype, "dateComparer", {
        get: /**
         * @return {?}
         */
        function () {
            return new DateComparer(this.marginal, this.service.inFinalView);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarRangeService.prototype, "length", {
        get: /**
         * @return {?}
         */
        function () {
            return this.rows * this.columns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarRangeService.prototype, "canMoveNext", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var firstItem = this.next.inRange[0];
            if (firstItem && this.service.maxDate) {
                return firstItem.date <= this.service.maxDate;
            }
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarRangeService.prototype, "canMovePrevious", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var lastItem = this.previous.inRange.slice(-1).pop();
            if (lastItem && this.service.minDate) {
                return lastItem.date >= this.service.minDate;
            }
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} service
     * @return {?}
     */
    CalendarRangeService.prototype.loadService = /**
     * @param {?} service
     * @return {?}
     */
    function (service) {
        this.service = service;
        this.refresh();
    };
    /**
     * @return {?}
     */
    CalendarRangeService.prototype.refresh = /**
     * @return {?}
     */
    function () {
        this.current = this.calcRange(this.service.currentDate);
        this.next = this.calcRange(DateUtil.next(this.interval, DateUtil.clone(this.service.currentDate)));
        this.previous = this.calcRange(DateUtil.previous(this.interval, DateUtil.clone(this.service.currentDate)));
    };
    /**
     * @param {?} forwards
     * @return {?}
     */
    CalendarRangeService.prototype.move = /**
     * @param {?} forwards
     * @return {?}
     */
    function (forwards) {
        if (forwards) {
            return this.moveNext();
        }
        return this.movePrevious();
    };
    /**
     * @return {?}
     */
    CalendarRangeService.prototype.moveNext = /**
     * @return {?}
     */
    function () {
        DateUtil.next(this.interval, this.service.currentDate);
        this.previous = this.current;
        this.current = this.next;
        this.next = this.calcRange(DateUtil.next(this.interval, DateUtil.clone(this.service.currentDate)));
    };
    /**
     * @return {?}
     */
    CalendarRangeService.prototype.movePrevious = /**
     * @return {?}
     */
    function () {
        DateUtil.previous(this.interval, this.service.currentDate);
        this.next = this.current;
        this.current = this.previous;
        this.previous = this.calcRange(DateUtil.previous(this.interval, DateUtil.clone(this.service.currentDate)));
    };
    /**
     * @param {?} forwards
     * @return {?}
     */
    CalendarRangeService.prototype.calc = /**
     * @param {?} forwards
     * @return {?}
     */
    function (forwards) {
        if (forwards) {
            return this.next;
        }
        return this.previous;
    };
    /**
     * @protected
     * @param {?} date
     * @return {?}
     */
    CalendarRangeService.prototype.calcStart = /**
     * @protected
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return DateUtil.startOf(this.interval, DateUtil.clone(date));
    };
    /**
     * @protected
     * @param {?} rangeStart
     * @return {?}
     */
    CalendarRangeService.prototype.calcDates = /**
     * @protected
     * @param {?} rangeStart
     * @return {?}
     */
    function (rangeStart) {
        var _this = this;
        return Util.Array
            .range(this.length)
            .map((/**
         * @param {?} i
         * @return {?}
         */
        function (i) { return DateUtil.add(_this.marginal, DateUtil.clone(rangeStart), i); }));
    };
    /**
     * @protected
     * @param {?} dateRange
     * @param {?} baseDate
     * @return {?}
     */
    CalendarRangeService.prototype.calcItems = /**
     * @protected
     * @param {?} dateRange
     * @param {?} baseDate
     * @return {?}
     */
    function (dateRange, baseDate) {
        var _this = this;
        return dateRange.map((/**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            /** @type {?} */
            var item = new CalendarItem(date);
            item.isDisabled = !_this.dateComparer.between(item.date, _this.service.minDate, _this.service.maxDate);
            item.isActive = _this.dateComparer.equal(item.date, _this.service.selectedDate);
            item.isToday = _this.dateComparer.equal(item.date, new Date());
            item.isSelectable = item.isDisabled;
            _this.configureItem(item, baseDate);
            return item;
        }));
    };
    /**
     * @private
     * @param {?} startDate
     * @return {?}
     */
    CalendarRangeService.prototype.calcRange = /**
     * @private
     * @param {?} startDate
     * @return {?}
     */
    function (startDate) {
        /** @type {?} */
        var start = this.calcStart(startDate);
        if (this.service.inFinalView) {
            DateUtil.startOf(this.marginal, start, true);
        }
        /** @type {?} */
        var dates = this.calcDates(start);
        /** @type {?} */
        var items = this.calcItems(dates, startDate);
        return new CalendarRange(start, dates, items, Util.Array.group(items, this.columns), this.dateComparer);
    };
    return CalendarRangeService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiCalendarViewTitle = /** @class */ (function () {
    function FuiCalendarViewTitle() {
        this.onZoomOut = new EventEmitter();
    }
    FuiCalendarViewTitle.decorators = [
        { type: Component, args: [{
                    selector: 'fui-calendar-view-title',
                    template: "\n<span class=\"title link\" (click)=\"onZoomOut.emit()\">\n    <ng-content></ng-content>\n</span>\n<span class=\"prev link\" [class.disabled]=\"!ranges?.canMovePrevious\" (click)=\"ranges?.movePrevious()\">\n    <i class=\"chevron left icon\"></i>\n</span>\n<span class=\"next link\" [class.disabled]=\"!ranges?.canMoveNext\" (click)=\"ranges?.moveNext()\">\n    <i class=\"chevron right icon\"></i>\n</span>\n",
                    styles: ["\n.title.link {\n    display: inline-block;\n    margin-left: 2rem;\n    margin-right: 2rem;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiCalendarViewTitle.ctorParameters = function () { return []; };
    FuiCalendarViewTitle.propDecorators = {
        ranges: [{ type: Input }],
        onZoomOut: [{ type: Output, args: ['zoomOut',] }]
    };
    return FuiCalendarViewTitle;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DatepickerMode = {
    Year: (/** @type {?} */ ('year')),
    Month: (/** @type {?} */ ('month')),
    Date: (/** @type {?} */ ('date')),
    Datetime: (/** @type {?} */ ('datetime')),
    Time: (/** @type {?} */ ('time'))
};
var FuiDatepicker = /** @class */ (function () {
    function FuiDatepicker(localizationService) {
        this.service = new CalendarService(new DatetimeConfig(), localizationService.get().datepicker);
        this.hasClasses = true;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    FuiDatepicker.prototype.onMouseDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.preventDefault();
    };
    FuiDatepicker.decorators = [
        { type: Component, args: [{
                    selector: 'fui-datepicker',
                    template: "\n<ng-container [ngSwitch]=\"service.currentView\">\n    <fui-calendar-year-view [service]=\"service\" *ngSwitchCase=\"0\"></fui-calendar-year-view>\n    <fui-calendar-month-view [service]=\"service\" *ngSwitchCase=\"1\"></fui-calendar-month-view>\n    <fui-calendar-date-view [service]=\"service\" *ngSwitchCase=\"2\"></fui-calendar-date-view>\n    <fui-calendar-hour-view [service]=\"service\" *ngSwitchCase=\"3\"></fui-calendar-hour-view>\n    <fui-calendar-minute-view [service]=\"service\" *ngSwitchCase=\"4\"></fui-calendar-minute-view>\n</ng-container>\n",
                    styles: ["\n:host {\n    user-select: none;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiDatepicker.ctorParameters = function () { return [
        { type: FuiLocalizationService }
    ]; };
    FuiDatepicker.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.active',] }, { type: HostBinding, args: ['class.calendar',] }],
        onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
    };
    return FuiDatepicker;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var PopupTrigger = {
    Hover: (/** @type {?} */ ('hover')),
    Click: (/** @type {?} */ ('click')),
    OutsideClick: (/** @type {?} */ ('outsideClick')),
    Focus: (/** @type {?} */ ('focus')),
    Manual: (/** @type {?} */ ('manual'))
};
var PopupConfig = /** @class */ (function () {
    function PopupConfig(defaults) {
        if (defaults === void 0) { defaults = {}; }
        this.placement = PositioningPlacement.TopLeft;
        this.trigger = PopupTrigger.Hover;
        this.isInverted = false;
        this.delay = 0;
        this.isBasic = false;
        this.transition = 'scale';
        this.transitionDuration = 200;
        this.isFlowing = false;
        this.isInline = false;
        Object.assign(this, defaults);
    }
    return PopupConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiPopup = /** @class */ (function () {
    function FuiPopup(elementRef) {
        this.elementRef = elementRef;
        this.transitionController = new TransitionController(false);
        this._isOpen = false;
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this.tabindex = 0;
    }
    Object.defineProperty(FuiPopup.prototype, "direction", {
        // Returns the direction (`top`, `left`, `right`, `bottom`) of the current placement.
        get: 
        // Returns the direction (`top`, `left`, `right`, `bottom`) of the current placement.
        /**
         * @return {?}
         */
        function () {
            // We need to set direction attribute before popper init to allow correct positioning
            return this.config.placement.split(' ').shift();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopup.prototype, "alignment", {
        // Returns the alignment (`top`, `left`, `right`, `bottom`) of the current placement.
        get: 
        // Returns the alignment (`top`, `left`, `right`, `bottom`) of the current placement.
        /**
         * @return {?}
         */
        function () {
            return this.config.placement.split(' ').pop();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopup.prototype, "dynamicClasses", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var classes = {};
            if (this.direction) {
                classes[this.direction] = true;
            }
            if (this.alignment) {
                classes[this.alignment] = true;
            }
            if (this.config.isInverted) {
                classes.inverted = true;
            }
            if (this.config.isBasic) {
                classes.basic = true;
            }
            if (this.config.isFlowing) {
                classes.flowing = true;
            }
            if (this.config.size) {
                classes[this.config.size] = true;
            }
            if (this.config.width) {
                classes[this.config.width] = true;
            }
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopup.prototype, "anchor", {
        set: /**
         * @param {?} anchor
         * @return {?}
         */
        function (anchor) {
            this._anchor = anchor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopup.prototype, "isOpen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isOpen;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiPopup.prototype.open = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Only attempt to open if currently closed.
        if (!this.isOpen) {
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Create positioning service after a brief delay.
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this.positioningService = new PositioningService(_this._anchor, _this._container.element, _this.config.placement, '.dynamic.arrow');
                _this.positioningService.hasArrow = !_this.config.isBasic;
            }));
            // Cancel all other transitions, and initiate the opening transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.In, (/**
             * @return {?}
             */
            function () {
                // Focus any element with [autofocus] attribute.
                /** @type {?} */
                var autoFocus = (/** @type {?} */ (_this.elementRef.nativeElement.querySelector('[autofocus]')));
                if (autoFocus) {
                    // Autofocus after the browser has had time to process other event handlers.
                    setTimeout((/**
                     * @return {?}
                     */
                    function () { return autoFocus.focus(); }), 10);
                    // Try to focus again when the modal has opened so that autofocus works in IE11.
                    setTimeout((/**
                     * @return {?}
                     */
                    function () { return autoFocus.focus(); }), _this.config.transitionDuration);
                }
            })));
            // Finally, set the popup to be open.
            this._isOpen = true;
            this.onOpen.emit();
        }
    };
    /**
     * @return {?}
     */
    FuiPopup.prototype.toggle = /**
     * @return {?}
     */
    function () {
        if (!this.isOpen) {
            return this.open();
        }
        return this.close();
    };
    /**
     * @return {?}
     */
    FuiPopup.prototype.close = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Only attempt to close if currently open.
        if (this.isOpen) {
            // Cancel all other transitions, and initiate the closing transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.Out));
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Start the closing timer, that fires the `onClose` event after the transition duration number of milliseconds.
            this.closingTimeout = window.setTimeout((/**
             * @return {?}
             */
            function () { return _this.onClose.emit(); }), this.config.transitionDuration);
            // Finally, set the popup to be closed.
            this._isOpen = false;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    FuiPopup.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Makes sense here, as the popup shouldn't be attached to any DOM element.
        event.stopPropagation();
    };
    FuiPopup.decorators = [
        { type: Component, args: [{
                    selector: 'fui-popup',
                    template: "\n<div class=\"ui popup\"\n     [ngClass]=\"dynamicClasses\"\n     [fuiTransition]=\"transitionController\"\n     [attr.direction]=\"direction\"\n     #container>\n\n    <ng-container *ngIf=\"!config.template && (!!config.header || !!config.text)\">\n        <div class=\"header\" *ngIf=\"config.header\">{{ config.header }}</div>\n        <div class=\"content\">{{ config.text }}</div>\n    </ng-container>\n    <div #templateSibling></div>\n\n    <fui-popup-arrow *ngIf=\"!config.isBasic\"\n                     [placement]=\"config.placement\"\n                     [inverted]=\"config.isInverted\"></fui-popup-arrow>\n</div>\n",
                    styles: ["\n.ui.popup {\n    /* Autofit popup to the contents. */\n    right: auto;\n    margin: 0;\n}\n\n.ui.animating.popup {\n    /* When the popup is animating, it may not initially be in the correct position.\n       This fires a mouse event, causing the anchor's mouseleave to fire - making the popup flicker.\n       Setting pointer-events to none while animating fixes this bug. */\n    pointer-events: none;\n}\n\n.ui.popup::before {\n    /* Hide the Fomantic UI CSS arrow. */\n    display: none;\n}\n\n/* Offset popup by 0.75em above and below when placed 'vertically'. */\n.ui.popup[direction=\"top\"],\n.ui.popup[direction=\"bottom\"] {\n    margin-top: 0.75em;\n    margin-bottom: 0.75em;\n}\n\n/* Offset popup by 0.75em either side when placed 'horizontally'. */\n.ui.popup[direction=\"left\"],\n.ui.popup[direction=\"right\"] {\n    margin-left: 0.75em;\n    margin-right: 0.75em;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiPopup.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    FuiPopup.propDecorators = {
        templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: true },] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        _container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: false },] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return FuiPopup;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var FuiPopupController = /** @class */ (function () {
    function FuiPopupController(_renderer, _element, _componentFactory, config) {
        var _this = this;
        this._renderer = _renderer;
        this._element = _element;
        this._componentFactory = _componentFactory;
        // Generate a new FuiPopup component and attach it to the application view.
        this._componentRef = this._componentFactory.createComponent(FuiPopup);
        // Configure popup with provided config.
        this.popup.config = config;
        // When the popup is closed (onClose fires on animation complete),
        this.popup.onClose.subscribe((/**
         * @return {?}
         */
        function () { return _this.cleanup(); }));
    }
    Object.defineProperty(FuiPopupController.prototype, "popup", {
        // Returns generated popup instance.
        get: 
        // Returns generated popup instance.
        /**
         * @return {?}
         */
        function () {
            // Use non-null assertion as we only access this when a popup exists.
            return this._componentRef.instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} config
     * @return {?}
     */
    FuiPopupController.prototype.configure = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        if (config) {
            Object.assign(this.popup.config, config);
        }
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.openDelayed = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Cancel the opening timer.
        clearTimeout(this._openingTimeout);
        // Start the popup opening after the specified delay interval.
        this._openingTimeout = window.setTimeout((/**
         * @return {?}
         */
        function () { return _this.open(); }), this.popup.config.delay);
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.open = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Attach the generated component to the current application.
        this._componentFactory.attachToApplication(this._componentRef);
        if (this.popup.config.isInline) {
            this._componentFactory.moveToElement(this._componentRef, this._element.nativeElement.parentElement);
        }
        else {
            // Move the generated element to the body to avoid any positioning issues.
            this._componentFactory.moveToDocumentBody(this._componentRef);
        }
        // Attach a reference to the anchor element. We do it here because IE11 loves to complain.
        this.popup.anchor = this._element;
        // Add a listener to the document body to handle closing.
        this._documentListener = this._renderer
            .listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            return _this.onDocumentClick(e);
        }));
        // Start popup open transition.
        this.popup.open();
        // Call lifecyle hook
        /** @type {?} */
        var lifecycle = ((/** @type {?} */ (this))).popupOnOpen;
        if (lifecycle) {
            lifecycle.call(this);
        }
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.close = /**
     * @return {?}
     */
    function () {
        // Cancel the opening timer to stop the popup opening after close has been called.
        clearTimeout(this._openingTimeout);
        if (this._componentRef) {
            // Start popup close transition.
            this.popup.close();
        }
        // Call lifecyle hook
        /** @type {?} */
        var lifecycle = ((/** @type {?} */ (this))).popupOnClose;
        if (lifecycle) {
            lifecycle.call(this);
        }
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.toggleDelayed = /**
     * @return {?}
     */
    function () {
        // If the popup hasn't been created, or it has but it isn't currently open, open the popup.
        if (!this._componentRef || (this._componentRef && !this.popup.isOpen)) {
            return this.openDelayed();
        }
        // O'wise, close it.
        return this.close();
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.toggle = /**
     * @return {?}
     */
    function () {
        // If the popup hasn't been created, or it has but it isn't currently open, open the popup.
        if (!this._componentRef || (this._componentRef && !this.popup.isOpen)) {
            return this.open();
        }
        // O'wise, close it.
        return this.close();
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.onMouseEnter = /**
     * @return {?}
     */
    function () {
        if (this.popup.config.trigger === PopupTrigger.Hover) {
            this.openDelayed();
        }
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.onMouseLeave = /**
     * @return {?}
     */
    function () {
        if (this.popup.config.trigger === PopupTrigger.Hover) {
            this.close();
        }
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (this.popup.config.trigger === PopupTrigger.Click ||
            this.popup.config.trigger === PopupTrigger.OutsideClick) {
            // Repeated clicks require a toggle, rather than just opening the popup each time.
            this.toggleDelayed();
        }
        else if (this.popup.config.trigger === PopupTrigger.Focus &&
            (!this._componentRef || (this._componentRef && !this.popup.isOpen))) {
            // Repeated clicks with a focus trigger requires an open (as focus isn't ever lost on repeated click).
            this.openDelayed();
        }
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.onFocusIn = /**
     * @return {?}
     */
    function () {
        if (this.popup.config.trigger === PopupTrigger.Focus) {
            this.openDelayed();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiPopupController.prototype.onFocusOut = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this._element.nativeElement.contains(e.relatedTarget) &&
            !this.popup.elementRef.nativeElement.contains(e.relatedTarget) &&
            this.popup.config.trigger === PopupTrigger.Focus) {
            this.close();
        }
    };
    /**
     * @return {?}
     */
    FuiPopupController.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.cleanup();
    };
    /**
     * @protected
     * @return {?}
     */
    FuiPopupController.prototype.cleanup = /**
     * @protected
     * @return {?}
     */
    function () {
        clearTimeout(this._openingTimeout);
        if (this._componentRef.instance && this._componentRef.instance.positioningService) {
            this._componentRef.instance.positioningService.destroy();
        }
        this._componentFactory.detachFromApplication(this._componentRef);
        if (this._documentListener) {
            this._documentListener();
        }
    };
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    FuiPopupController.prototype.onDocumentClick = /**
     * @private
     * @param {?} e
     * @return {?}
     */
    function (e) {
        // If the popup trigger is outside click,
        if (this._componentRef && this.popup.config.trigger === PopupTrigger.OutsideClick) {
            /** @type {?} */
            var target = (/** @type {?} */ (e.target));
            // Close the popup if the click is outside of the popup element.
            if (!((/** @type {?} */ (this._element.nativeElement))).contains(target)) {
                this.close();
            }
        }
    };
    FuiPopupController.propDecorators = {
        onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
        onClick: [{ type: HostListener, args: ['click',] }],
        onFocusIn: [{ type: HostListener, args: ['focusin',] }],
        onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }]
    };
    return FuiPopupController;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
FuiPopupComponentController = /** @class */ (function (_super) {
    __extends(FuiPopupComponentController, _super);
    function FuiPopupComponentController(renderer, element, componentFactory, _component, config) {
        var _this = _super.call(this, renderer, element, componentFactory, config) || this;
        _this._component = _component;
        return _this;
    }
    Object.defineProperty(FuiPopupComponentController.prototype, "componentInstance", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._contentComponentRef) {
                return this._contentComponentRef.instance;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiPopupComponentController.prototype.open = /**
     * @return {?}
     */
    function () {
        if (!this._contentComponentRef) {
            this._contentComponentRef = this._componentFactory.createComponent((/** @type {?} */ (this._component)));
            this._componentFactory.attachToView(this._contentComponentRef, this.popup.templateSibling);
        }
        _super.prototype.open.call(this);
    };
    /**
     * @protected
     * @return {?}
     */
    FuiPopupComponentController.prototype.cleanup = /**
     * @protected
     * @return {?}
     */
    function () {
        _super.prototype.cleanup.call(this);
        if (this._contentComponentRef) {
            this._contentComponentRef.destroy();
            this._contentComponentRef = undefined;
        }
    };
    return FuiPopupComponentController;
}(FuiPopupController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var /**
 * @template T
 */
TemplatePopupConfig = /** @class */ (function (_super) {
    __extends(TemplatePopupConfig, _super);
    function TemplatePopupConfig() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TemplatePopupConfig;
}(PopupConfig));
/**
 * @template T
 */
var  /**
 * @template T
 */
FuiPopupTemplateController = /** @class */ (function (_super) {
    __extends(FuiPopupTemplateController, _super);
    function FuiPopupTemplateController(renderer, element, componentFactory, config) {
        return _super.call(this, renderer, element, componentFactory, config) || this;
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    FuiPopupTemplateController.prototype.configure = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        _super.prototype.configure.call(this, config);
        if (config) {
            this.template = config.template;
            this.context = config.context;
        }
    };
    /**
     * @return {?}
     */
    FuiPopupTemplateController.prototype.open = /**
     * @return {?}
     */
    function () {
        // If there is a template, inject it into the view.
        if (this.template) {
            this.popup.templateSibling.clear();
            this._componentFactory.createView(this.popup.templateSibling, this.template, {
                $implicit: this.popup,
                context: this.context
            });
        }
        _super.prototype.open.call(this);
    };
    return FuiPopupTemplateController;
}(FuiPopupController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiPopupArrow = /** @class */ (function () {
    function FuiPopupArrow() {
    }
    Object.defineProperty(FuiPopupArrow.prototype, "direction", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.placement) {
                return this.placement.split(' ').shift();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupArrow.prototype, "alignment", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.placement) {
                /** @type {?} */
                var alignment = this.placement.split(' ').pop();
                if (alignment === this.direction) {
                    return 'center';
                }
                return alignment;
            }
        },
        enumerable: true,
        configurable: true
    });
    FuiPopupArrow.decorators = [
        { type: Component, args: [{
                    selector: 'fui-popup-arrow',
                    template: "\n<div class=\"dynamic arrow\" [attr.direction]=\"direction\" *ngIf=\"alignment == 'center'\"></div>\n<div class=\"static arrow\" [attr.direction]=\"direction\" [attr.alignment]=\"alignment\" *ngIf=\"alignment != 'center'\"></div>\n",
                    styles: ["\n.arrow {\n    position: absolute;\n    width: 0.71428571em;\n    height: 0.71428571em;\n    background: #ffffff;\n    -webkit-transform: rotate(45deg);\n    -ms-transform: rotate(45deg);\n    transform: rotate(45deg);\n    z-index: 2;\n}\n\n:host.inverted .arrow {\n    background: #1b1c1d;\n}\n\n.arrow[direction=\"top\"] {\n    bottom: -0.30714286em;\n    box-shadow: 1px 1px 0 0 #bababc;\n}\n\n.arrow[direction=\"left\"] {\n    right: -0.30714286em;\n    box-shadow: 1px -1px 1px 0 #bababc;\n}\n\n.arrow[direction=\"bottom\"] {\n    top: -0.30714286em;\n    box-shadow: -1px -1px 0 0 #bababc;\n}\n\n.arrow[direction=\"right\"] {\n    left: -0.30714286em;\n    box-shadow: -1px 1px 1px 0 #bababc;\n}\n\n.static.arrow[direction=\"bottom\"][alignment=\"left\"],\n.static.arrow[direction=\"top\"][alignment=\"left\"] {\n    left: 1em;\n    right: auto;\n}\n\n.static.arrow[direction=\"left\"][alignment=\"top\"],\n.static.arrow[direction=\"right\"][alignment=\"top\"] {\n    top: 1em;\n    bottom: auto;\n}\n\n.static.arrow[direction=\"bottom\"][alignment=\"right\"],\n.static.arrow[direction=\"top\"][alignment=\"right\"] {\n    left: auto;\n    right: 1em;\n}\n\n.static.arrow[direction=\"left\"][alignment=\"bottom\"],\n.static.arrow[direction=\"right\"][alignment=\"bottom\"] {\n    top: auto;\n    bottom: 1em;\n}\n"]
                }] }
    ];
    FuiPopupArrow.propDecorators = {
        placement: [{ type: Input }],
        inverted: [{ type: HostBinding, args: ['class.inverted',] }, { type: Input }]
    };
    return FuiPopupArrow;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiPopupConfig = /** @class */ (function (_super) {
    __extends(FuiPopupConfig, _super);
    function FuiPopupConfig() {
        // We use an empty constructor to ensure Angular DI works correctly.
        return _super.call(this) || this;
    }
    FuiPopupConfig.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    FuiPopupConfig.ctorParameters = function () { return []; };
    return FuiPopupConfig;
}(PopupConfig));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var FuiPopupDirective = /** @class */ (function (_super) {
    __extends(FuiPopupDirective, _super);
    function FuiPopupDirective(renderer, element, componentFactory, popupDefaults) {
        return _super.call(this, renderer, element, componentFactory, new PopupConfig(popupDefaults)) || this;
    }
    Object.defineProperty(FuiPopupDirective.prototype, "popupHeader", {
        set: /**
         * @param {?} header
         * @return {?}
         */
        function (header) {
            this.popup.config.header = header;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupText", {
        set: /**
         * @param {?} text
         * @return {?}
         */
        function (text) {
            this.popup.config.text = text;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupInverted", {
        set: /**
         * @param {?} inverted
         * @return {?}
         */
        function (inverted) {
            this.popup.config.isInverted = Util.DOM.parseBooleanAttribute(inverted);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupBasic", {
        set: /**
         * @param {?} basic
         * @return {?}
         */
        function (basic) {
            this.popup.config.isBasic = Util.DOM.parseBooleanAttribute(basic);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupInline", {
        set: /**
         * @param {?} inline
         * @return {?}
         */
        function (inline) {
            this.popup.config.isInline = Util.DOM.parseBooleanAttribute(inline);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupFlowing", {
        set: /**
         * @param {?} flowing
         * @return {?}
         */
        function (flowing) {
            this.popup.config.isFlowing = Util.DOM.parseBooleanAttribute(flowing);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupTransition", {
        set: /**
         * @param {?} transition
         * @return {?}
         */
        function (transition) {
            this.popup.config.transition = transition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupTransitionDuration", {
        set: /**
         * @param {?} duration
         * @return {?}
         */
        function (duration) {
            this.popup.config.transitionDuration = duration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupPlacement", {
        set: /**
         * @param {?} placement
         * @return {?}
         */
        function (placement) {
            this.popup.config.placement = placement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupWidth", {
        set: /**
         * @param {?} width
         * @return {?}
         */
        function (width) {
            this.popup.config.width = width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupSize", {
        set: /**
         * @param {?} size
         * @return {?}
         */
        function (size) {
            this.popup.config.size = size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupDelay", {
        set: /**
         * @param {?} delay
         * @return {?}
         */
        function (delay) {
            this.popup.config.delay = delay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupTrigger", {
        get: /**
         * @return {?}
         */
        function () {
            return this.popup.config.trigger;
        },
        set: /**
         * @param {?} trigger
         * @return {?}
         */
        function (trigger) {
            this.popup.config.trigger = trigger;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupTemplate", {
        set: /**
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this.template = template;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupTemplateContext", {
        set: /**
         * @param {?} context
         * @return {?}
         */
        function (context) {
            this.context = context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopupDirective.prototype, "popupConfig", {
        set: /**
         * @param {?} config
         * @return {?}
         */
        function (config) {
            this.configure(config);
        },
        enumerable: true,
        configurable: true
    });
    FuiPopupDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiPopup]',
                    exportAs: 'fuiPopup'
                },] }
    ];
    /** @nocollapse */
    FuiPopupDirective.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: FuiComponentFactory },
        { type: FuiPopupConfig }
    ]; };
    FuiPopupDirective.propDecorators = {
        popupHeader: [{ type: Input }],
        popupText: [{ type: Input }],
        popupInverted: [{ type: Input }],
        popupBasic: [{ type: Input }],
        popupInline: [{ type: Input }],
        popupFlowing: [{ type: Input }],
        popupTransition: [{ type: Input }],
        popupTransitionDuration: [{ type: Input }],
        popupPlacement: [{ type: Input }],
        popupWidth: [{ type: Input }],
        popupSize: [{ type: Input }],
        popupDelay: [{ type: Input }],
        popupTrigger: [{ type: Input }],
        popupTemplate: [{ type: Input }],
        popupTemplateContext: [{ type: Input }],
        popupConfig: [{ type: Input }]
    };
    return FuiPopupDirective;
}(FuiPopupTemplateController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiPopupModule = /** @class */ (function () {
    function FuiPopupModule() {
    }
    FuiPopupModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FuiTransitionModule,
                        FuiUtilityModule
                    ],
                    declarations: [
                        FuiPopupDirective,
                        FuiPopupArrow,
                        FuiPopup
                    ],
                    exports: [
                        FuiPopupDirective,
                        FuiPopup
                    ],
                    providers: [
                        FuiPopupConfig
                    ],
                    entryComponents: [
                        FuiPopup
                    ]
                },] }
    ];
    return FuiPopupModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiDatepickerDirective = /** @class */ (function (_super) {
    __extends(FuiDatepickerDirective, _super);
    function FuiDatepickerDirective(renderer, element, componentFactory, localizationService) {
        var _this = _super.call(this, renderer, element, componentFactory, FuiDatepicker, new PopupConfig({
            trigger: PopupTrigger.Focus,
            placement: PositioningPlacement.BottomLeft,
            transition: 'scale',
            transitionDuration: 200
        })) || this;
        _this.localizationService = localizationService;
        // This ensures the popup is drawn correctly (i.e. no border).
        _this._renderer.addClass(_this.popup.elementRef.nativeElement, 'ui');
        _this._renderer.addClass(_this.popup.elementRef.nativeElement, 'calendar');
        _this.onLocaleUpdate();
        _this.localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        function () { return _this.onLocaleUpdate(); }));
        _this.onSelectedDateChange = new EventEmitter();
        _this.onValidatorChange = new EventEmitter();
        _this.mode = DatepickerMode.Datetime;
        return _this;
    }
    Object.defineProperty(FuiDatepickerDirective.prototype, "placement", {
        set: /**
         * @param {?} placement
         * @return {?}
         */
        function (placement) {
            this.popup.config.placement = placement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerDirective.prototype, "transition", {
        set: /**
         * @param {?} transition
         * @return {?}
         */
        function (transition) {
            this.popup.config.transition = transition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerDirective.prototype, "transitionDuration", {
        set: /**
         * @param {?} duration
         * @return {?}
         */
        function (duration) {
            this.popup.config.transitionDuration = duration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerDirective.prototype, "selectedDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectedDate;
        },
        set: /**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            this._selectedDate = date;
            this.onSelectedDateChange.emit(date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerDirective.prototype, "mode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mode;
        },
        set: /**
         * @param {?} mode
         * @return {?}
         */
        function (mode) {
            this._mode = mode || DatepickerMode.Datetime;
            switch (this._mode) {
                case DatepickerMode.Year:
                    this.config = new YearConfig();
                    break;
                case DatepickerMode.Month:
                    this.config = new MonthConfig();
                    break;
                case DatepickerMode.Date:
                default:
                    this.config = new DateConfig();
                    break;
                case DatepickerMode.Datetime:
                    this.config = new DatetimeConfig();
                    break;
                case DatepickerMode.Time:
                    this.config = new TimeConfig();
                    break;
            }
            this.writeValue(this.selectedDate);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerDirective.prototype, "localeValues", {
        get: /**
         * @return {?}
         */
        function () {
            return this.localizationService.override(this._localeValues, this.localeOverrides);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiDatepickerDirective.prototype.popupOnOpen = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.componentInstance) {
            this.componentInstance.service.config = this.config;
            this.componentInstance.service.localeValues = this.localeValues;
            this.componentInstance.service.currentDate = this.initialDate || new Date();
            this.componentInstance.service.selectedDate = this.selectedDate;
            this.componentInstance.service.maxDate = this.maxDate;
            this.componentInstance.service.minDate = this.minDate;
            if (this.firstDayOfWeek != undefined) {
                this.componentInstance.service.firstDayOfWeek = this.firstDayOfWeek;
            }
            this.componentInstance.service.reset();
            this.componentInstance.service.onDateChange.subscribe((/**
             * @param {?} d
             * @return {?}
             */
            function (d) {
                _this.selectedDate = d;
                _this.close();
            }));
        }
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    FuiDatepickerDirective.prototype.ngOnChanges = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var maxDate = _a.maxDate, minDate = _a.minDate, mode = _a.mode;
        if (maxDate || minDate || mode) {
            this.onValidatorChange.emit();
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    FuiDatepickerDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        /** @type {?} */
        var value = c.value;
        if (value != undefined) {
            // We post process the min & max date because sometimes this puts the date outside of the allowed range.
            if (this.minDate && value < this.minDate) {
                return { fuiMinDate: { required: this.minDate, actual: value } };
            }
            if (this.maxDate && value > this.maxDate) {
                return { fuiMaxDate: { required: this.maxDate, actual: value } };
            }
        }
        // Angular expects null
        // tslint:disable-next-line:no-null-keyword
        return null;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    FuiDatepickerDirective.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.selectedDate = value;
        if (this.componentInstance) {
            this.componentInstance.service.selectedDate = value;
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiDatepickerDirective.prototype.onKeyDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (e.keyCode === KeyCode.Escape) {
            this.close();
        }
    };
    /**
     * @private
     * @return {?}
     */
    FuiDatepickerDirective.prototype.onLocaleUpdate = /**
     * @private
     * @return {?}
     */
    function () {
        this._localeValues = this.localizationService.get().datepicker;
    };
    FuiDatepickerDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiDatepicker]',
                    providers: [customValidatorFactory(FuiDatepickerDirective)]
                },] }
    ];
    /** @nocollapse */
    FuiDatepickerDirective.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: FuiComponentFactory },
        { type: FuiLocalizationService }
    ]; };
    FuiDatepickerDirective.propDecorators = {
        initialDate: [{ type: Input, args: ['pickerInitialDate',] }],
        maxDate: [{ type: Input, args: ['pickerMaxDate',] }],
        minDate: [{ type: Input, args: ['pickerMinDate',] }],
        firstDayOfWeek: [{ type: Input, args: ['pickerFirstDayOfWeek',] }],
        localeOverrides: [{ type: Input, args: ['pickerLocaleOverrides',] }],
        onSelectedDateChange: [{ type: Output, args: ['pickerSelectedDateChange',] }],
        onValidatorChange: [{ type: Output, args: ['pickerValidatorChange',] }],
        placement: [{ type: Input, args: ['pickerPlacement',] }],
        transition: [{ type: Input, args: ['pickerTransition',] }],
        transitionDuration: [{ type: Input, args: ['pickerTransitionDuration',] }],
        mode: [{ type: Input, args: ['pickerMode',] }],
        onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return FuiDatepickerDirective;
}(FuiPopupComponentController));
var FuiDatepickerDirectiveValueAccessor = /** @class */ (function (_super) {
    __extends(FuiDatepickerDirectiveValueAccessor, _super);
    function FuiDatepickerDirectiveValueAccessor(host) {
        var _this = _super.call(this, host) || this;
        _this.host = host;
        return _this;
    }
    FuiDatepickerDirectiveValueAccessor.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiDatepicker]',
                    host: { '(pickerSelectedDateChange)': 'onChange($event)' },
                    providers: [customValueAccessorFactory(FuiDatepickerDirectiveValueAccessor)]
                },] }
    ];
    /** @nocollapse */
    FuiDatepickerDirectiveValueAccessor.ctorParameters = function () { return [
        { type: FuiDatepickerDirective }
    ]; };
    return FuiDatepickerDirectiveValueAccessor;
}(CustomValueAccessor));
var FuiDatepickerDirectiveValidator = /** @class */ (function (_super) {
    __extends(FuiDatepickerDirectiveValidator, _super);
    function FuiDatepickerDirectiveValidator(host) {
        var _this = _super.call(this, host) || this;
        _this.host = host;
        return _this;
    }
    FuiDatepickerDirectiveValidator.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiDatepicker]',
                    host: { '(pickerValidatorChange)': 'onValidatorChange()' },
                    providers: [customValidatorFactory(FuiDatepickerDirectiveValidator)]
                },] }
    ];
    /** @nocollapse */
    FuiDatepickerDirectiveValidator.ctorParameters = function () { return [
        { type: FuiDatepickerDirective }
    ]; };
    return FuiDatepickerDirectiveValidator;
}(CustomValidator));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiDatepickerInputDirective = /** @class */ (function () {
    function FuiDatepickerInputDirective(datepicker, valueAccessor, _renderer, _element, localizationService) {
        var _this = this;
        this.datepicker = datepicker;
        this.valueAccessor = valueAccessor;
        this._renderer = _renderer;
        this._element = _element;
        this.useNativeOnMobile = true;
        this.fallbackActive = false;
        // Whenever the datepicker value updates, update the input text alongside it.
        this.datepicker.onSelectedDateChange.subscribe((/**
         * @return {?}
         */
        function () {
            return _this.updateValue(_this.selectedDateString);
        }));
        localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        function () {
            return _this.updateValue(_this.selectedDateString);
        }));
    }
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "parser", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.fallbackActive) {
                return new InternalDateParser(this.datepicker.mode, this.datepicker.localeValues);
            }
            return new DateParser(this.datepicker.localeValues.formats[this.datepicker.mode], this.datepicker.localeValues);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "selectedDateString", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.datepicker.selectedDate) {
                return this.parser.format(this.datepicker.selectedDate);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.fallbackActive) {
                return this.datepicker.config.fallback;
            }
            return 'text';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "max", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.fallbackActive && this.datepicker.maxDate) {
                // Since HTML doesn't use a date object max is somewhat tricky.
                // Our Datepicker will always choose the 1st date on the provided precision,
                // meaning anything below the maxDate will work, hence endOf.
                /** @type {?} */
                var max = DateUtil.endOf(this.datepicker.config.precision, DateUtil.clone(this.datepicker.maxDate));
                return this.parser.format(max);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "min", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.fallbackActive && this.datepicker.minDate) {
                // Since HTML doesn't use a date object min is somewhat tricky.
                // We use 1 minute before the next date at the configured precision since
                // our Datepicker picks the first available date at that precision.
                /** @type {?} */
                var min = DateUtil.clone(this.datepicker.minDate);
                return this.parser.format(min);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "useNativeOnMobile", {
        get: /**
         * @return {?}
         */
        function () {
            return this._useNativeOnMobile;
        },
        set: /**
         * @param {?} fallback
         * @return {?}
         */
        function (fallback) {
            this._useNativeOnMobile = fallback;
            /** @type {?} */
            var isOnMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(navigator.userAgent);
            this.fallbackActive = this.useNativeOnMobile && isOnMobile;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "fallbackActive", {
        get: /**
         * @return {?}
         */
        function () {
            return this._fallbackActive;
        },
        set: /**
         * @param {?} active
         * @return {?}
         */
        function (active) {
            this._fallbackActive = active;
            // If the fallback is active, then the trigger must be manual so the datepicker never opens.
            this.datepicker.popup.config.trigger = this.fallbackActive ? PopupTrigger.Manual : PopupTrigger.Focus;
            // Update the input value (this will insert the `T` as required).
            this.updateValue(this.selectedDateString);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    FuiDatepickerInputDirective.prototype.typeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._lastUpdateTyped = true;
        this._currentInputValue = value;
        if (!value) {
            // Delete the selected date if no date was entered manually.
            return this.datepicker.writeValue(undefined);
        }
        /** @type {?} */
        var parsed = this.parser.parse(value, this.datepicker.selectedDate);
        if (!isNaN(parsed.getTime()) && value === this.parser.format(parsed)) {
            return this.datepicker.writeValue(parsed);
        }
        return this.datepicker.writeValue(undefined);
    };
    /**
     * @return {?}
     */
    FuiDatepickerInputDirective.prototype.onFocusOut = /**
     * @return {?}
     */
    function () {
        this.valueAccessor.onTouched();
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    FuiDatepickerInputDirective.prototype.updateValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // Only update the current value if it is different to what it's being updated to.
        // This is so that the editing position isn't changed when manually typing the date.
        if (!this._lastUpdateTyped) {
            this._renderer.setProperty(this._element.nativeElement, 'value', value || '');
        }
        this._lastUpdateTyped = false;
    };
    FuiDatepickerInputDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[fuiDatepicker]'
                },] }
    ];
    /** @nocollapse */
    FuiDatepickerInputDirective.ctorParameters = function () { return [
        { type: FuiDatepickerDirective, decorators: [{ type: Host }] },
        { type: FuiDatepickerDirectiveValueAccessor, decorators: [{ type: Host }] },
        { type: Renderer2 },
        { type: ElementRef },
        { type: FuiLocalizationService }
    ]; };
    FuiDatepickerInputDirective.propDecorators = {
        type: [{ type: HostBinding, args: ['attr.type',] }],
        max: [{ type: HostBinding, args: ['attr.max',] }],
        min: [{ type: HostBinding, args: ['attr.min',] }],
        useNativeOnMobile: [{ type: Input, args: ['pickerUseNativeOnMobile',] }],
        typeValue: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
        onFocusOut: [{ type: HostListener, args: ['focusout',] }]
    };
    return FuiDatepickerInputDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CalendarRangeDateService = /** @class */ (function (_super) {
    __extends(CalendarRangeDateService, _super);
    function CalendarRangeDateService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} start
     * @return {?}
     */
    CalendarRangeDateService.prototype.calcStart = /**
     * @param {?} start
     * @return {?}
     */
    function (start) {
        /** @type {?} */
        var monthStart = DateUtil.startOf(DatePrecision.Month, DateUtil.clone(start));
        monthStart.setDate((1 - monthStart.getDay() + this.service.firstDayOfWeek - 7) % 7);
        return monthStart;
    };
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    CalendarRangeDateService.prototype.configureItem = /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    function (item, baseDate) {
        item.humanReadable = item.date.getDate().toString();
        item.isOutsideRange = item.date.getMonth() !== baseDate.getMonth();
        item.isSelectable = item.isDisabled;
    };
    return CalendarRangeDateService;
}(CalendarRangeService));
var FuiCalendarDateView = /** @class */ (function (_super) {
    __extends(FuiCalendarDateView, _super);
    function FuiCalendarDateView(renderer) {
        return _super.call(this, renderer, CalendarViewType.Date, new CalendarRangeDateService(DatePrecision.Month, 6, 7)) || this;
    }
    Object.defineProperty(FuiCalendarDateView.prototype, "days", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var days = this.service.localeValues.weekdaysNarrow;
            return days.map((/**
             * @param {?} d
             * @param {?} i
             * @return {?}
             */
            function (d, i) { return days[(i + _this.service.firstDayOfWeek) % days.length]; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiCalendarDateView.prototype, "date", {
        get: /**
         * @return {?}
         */
        function () {
            return new DateParser(this.service.localeValues.formats.month, this.service.localeValues).format(this.currentDate);
        },
        enumerable: true,
        configurable: true
    });
    FuiCalendarDateView.decorators = [
        { type: Component, args: [{
                    selector: 'fui-calendar-date-view',
                    template: "\n<table class=\"ui celled center aligned unstackable table seven column day\">\n<thead>\n    <tr>\n        <th colspan=\"7\">\n            <fui-calendar-view-title [ranges]=\"ranges\" (zoomOut)=\"zoomOut()\">\n                {{ date }}\n            </fui-calendar-view-title>\n        </th>\n    </tr>\n    <tr>\n        <th *ngFor=\"let day of days\">{{ day }}</th>\n    </tr>\n</thead>\n<tbody>\n    <tr *ngFor=\"let group of ranges.current.groupedItems\">\n        <td class=\"link\"\n            *ngFor=\"let item of group\"\n            [calendarItem]=\"item\"\n            (click)=\"setDate(item)\">{{ item.humanReadable }}\n        </td>\n    </tr>\n</tbody>\n</table>\n"
                }] }
    ];
    /** @nocollapse */
    FuiCalendarDateView.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    return FuiCalendarDateView;
}(CalendarView));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CalendarRangeHourService = /** @class */ (function (_super) {
    __extends(CalendarRangeHourService, _super);
    function CalendarRangeHourService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    CalendarRangeHourService.prototype.configureItem = /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    function (item, baseDate) {
        // Set minutes and seconds to 0
        /** @type {?} */
        var customFormat = this.service.localeValues.formats.time.replace(/[ms]/g, '0');
        item.humanReadable = new DateParser(customFormat, this.service.localeValues).format(item.date);
        item.isOutsideRange = false;
    };
    return CalendarRangeHourService;
}(CalendarRangeService));
var FuiCalendarHourView = /** @class */ (function (_super) {
    __extends(FuiCalendarHourView, _super);
    function FuiCalendarHourView(renderer) {
        return _super.call(this, renderer, CalendarViewType.Hour, new CalendarRangeHourService(DatePrecision.Date, 6, 4)) || this;
    }
    Object.defineProperty(FuiCalendarHourView.prototype, "date", {
        get: /**
         * @return {?}
         */
        function () {
            return new DateParser(this.service.localeValues.formats.date, this.service.localeValues).format(this.currentDate);
        },
        enumerable: true,
        configurable: true
    });
    FuiCalendarHourView.decorators = [
        { type: Component, args: [{
                    selector: 'fui-calendar-hour-view',
                    template: "\n<table class=\"ui celled center aligned unstackable table four column hour\">\n<thead *ngIf=\"service.config.mode != 1\">\n    <tr>\n        <th colspan=\"4\">\n            <fui-calendar-view-title [ranges]=\"ranges\" (zoomOut)=\"zoomOut()\">\n                {{ date }}\n            </fui-calendar-view-title>\n        </th>\n    </tr>\n</thead>\n<tbody>\n    <tr *ngFor=\"let group of ranges.current.groupedItems\">\n        <td class=\"link\"\n            *ngFor=\"let item of group\"\n            [calendarItem]=\"item\"\n            (click)=\"setDate(item)\">{{ item.humanReadable }}\n        </td>\n    </tr>\n</tbody>\n</table>\n"
                }] }
    ];
    /** @nocollapse */
    FuiCalendarHourView.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    return FuiCalendarHourView;
}(CalendarView));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CalendarRangeMinuteService = /** @class */ (function (_super) {
    __extends(CalendarRangeMinuteService, _super);
    function CalendarRangeMinuteService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} start
     * @return {?}
     */
    CalendarRangeMinuteService.prototype.calcStart = /**
     * @param {?} start
     * @return {?}
     */
    function (start) {
        return DateUtil.startOf(DatePrecision.Hour, DateUtil.clone(start), true);
    };
    /**
     * @param {?} start
     * @return {?}
     */
    CalendarRangeMinuteService.prototype.calcDates = /**
     * @param {?} start
     * @return {?}
     */
    function (start) {
        return Util.Array
            .range(this.length)
            .map((/**
         * @param {?} i
         * @return {?}
         */
        function (i) { return DateUtil.add(DatePrecision.Minute, DateUtil.clone(start), i * 5); }));
    };
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    CalendarRangeMinuteService.prototype.configureItem = /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    function (item, baseDate) {
        item.humanReadable = new DateParser(this.service.localeValues.formats.time, this.service.localeValues).format(item.date);
        item.isOutsideRange = false;
    };
    return CalendarRangeMinuteService;
}(CalendarRangeService));
var FuiCalendarMinuteView = /** @class */ (function (_super) {
    __extends(FuiCalendarMinuteView, _super);
    function FuiCalendarMinuteView(renderer) {
        return _super.call(this, renderer, CalendarViewType.Minute, new CalendarRangeMinuteService(DatePrecision.Hour, 4, 3)) || this;
    }
    Object.defineProperty(FuiCalendarMinuteView.prototype, "date", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.service.config.mode !== CalendarMode.TimeOnly) {
                // Set minutes and seconds to 0
                /** @type {?} */
                var dateTimeFormat = this.service.localeValues.formats.datetime.replace(/[ms]/g, '0');
                return new DateParser(dateTimeFormat, this.service.localeValues).format(this.currentDate);
            }
            else {
                // Set minutes and seconds to 0
                /** @type {?} */
                var timeFormat = this.service.localeValues.formats.time.replace(/[ms]/g, '0');
                return new DateParser(timeFormat, this.service.localeValues).format(this.currentDate);
            }
        },
        enumerable: true,
        configurable: true
    });
    FuiCalendarMinuteView.decorators = [
        { type: Component, args: [{
                    selector: 'fui-calendar-minute-view',
                    template: "\n<table class=\"ui celled center aligned unstackable table three column minute\">\n<thead>\n    <tr>\n        <th colspan=\"4\">\n            <fui-calendar-view-title [ranges]=\"ranges\" (zoomOut)=\"zoomOut()\">\n                {{ date }}\n            </fui-calendar-view-title>\n        </th>\n    </tr>\n</thead>\n<tbody>\n    <tr *ngFor=\"let group of ranges.current.groupedItems\">\n        <td class=\"link\"\n            *ngFor=\"let item of group\"\n            [calendarItem]=\"item\"\n            (click)=\"setDate(item)\">{{ item.humanReadable }}\n        </td>\n    </tr>\n</tbody>\n</table>\n"
                }] }
    ];
    /** @nocollapse */
    FuiCalendarMinuteView.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    return FuiCalendarMinuteView;
}(CalendarView));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CalendarRangeMonthService = /** @class */ (function (_super) {
    __extends(CalendarRangeMonthService, _super);
    function CalendarRangeMonthService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    CalendarRangeMonthService.prototype.configureItem = /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    function (item, baseDate) {
        item.humanReadable = this.service.localeValues.monthsShort[item.date.getMonth()];
        item.isOutsideRange = false;
    };
    return CalendarRangeMonthService;
}(CalendarRangeService));
var FuiCalendarMonthView = /** @class */ (function (_super) {
    __extends(FuiCalendarMonthView, _super);
    function FuiCalendarMonthView(renderer) {
        return _super.call(this, renderer, CalendarViewType.Month, new CalendarRangeMonthService(DatePrecision.Year, 4, 3)) || this;
    }
    Object.defineProperty(FuiCalendarMonthView.prototype, "year", {
        get: /**
         * @return {?}
         */
        function () {
            return new DateParser(this.service.localeValues.formats.year, this.service.localeValues).format(this.currentDate);
        },
        enumerable: true,
        configurable: true
    });
    FuiCalendarMonthView.decorators = [
        { type: Component, args: [{
                    selector: 'fui-calendar-month-view',
                    template: "\n<table class=\"ui celled center aligned unstackable table three column month\">\n<thead>\n    <tr>\n        <th colspan=\"3\">\n            <fui-calendar-view-title [ranges]=\"ranges\" (zoomOut)=\"zoomOut()\">\n                {{ year }}\n            </fui-calendar-view-title>\n        </th>\n    </tr>\n</thead>\n<tbody>\n    <tr *ngFor=\"let group of ranges.current.groupedItems\">\n        <td class=\"link\"\n            *ngFor=\"let item of group\"\n            [calendarItem]=\"item\"\n            (click)=\"setDate(item)\">{{ item.humanReadable }}\n        </td>\n    </tr>\n</tbody>\n</table>\n"
                }] }
    ];
    /** @nocollapse */
    FuiCalendarMonthView.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    return FuiCalendarMonthView;
}(CalendarView));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CalendarRangeYearService = /** @class */ (function (_super) {
    __extends(CalendarRangeYearService, _super);
    function CalendarRangeYearService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    CalendarRangeYearService.prototype.configureItem = /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    function (item, baseDate) {
        item.humanReadable = Util.String.padLeft(item.date.getFullYear().toString(), 4, '0');
        item.isOutsideRange = item.date.getFullYear() >= this.calcStart(baseDate).getFullYear() + 10;
    };
    return CalendarRangeYearService;
}(CalendarRangeService));
var FuiCalendarYearView = /** @class */ (function (_super) {
    __extends(FuiCalendarYearView, _super);
    function FuiCalendarYearView(renderer) {
        return _super.call(this, renderer, CalendarViewType.Year, new CalendarRangeYearService(DatePrecision.Decade, 4, 3)) || this;
    }
    Object.defineProperty(FuiCalendarYearView.prototype, "decadeStart", {
        get: /**
         * @return {?}
         */
        function () {
            return DateUtil
                .startOf(DatePrecision.Decade, DateUtil.clone(this.service.currentDate))
                .getFullYear();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} year
     * @return {?}
     */
    FuiCalendarYearView.prototype.pad = /**
     * @param {?} year
     * @return {?}
     */
    function (year) {
        return Util.String.padLeft(year.toString(), 4, '0');
    };
    FuiCalendarYearView.decorators = [
        { type: Component, args: [{
                    selector: 'fui-calendar-year-view',
                    template: "\n<table class=\"ui celled center aligned unstackable table three column year\">\n<thead>\n    <tr>\n        <th colspan=\"3\">\n            <fui-calendar-view-title [ranges]=\"ranges\" (zoomOut)=\"zoomOut()\">\n                {{ pad(decadeStart) }} - {{ pad(decadeStart + 10) }}\n            </fui-calendar-view-title>\n        </th>\n    </tr>\n</thead>\n<tbody>\n    <tr *ngFor=\"let group of ranges.current.groupedItems\">\n        <td class=\"link\"\n            *ngFor=\"let item of group\"\n            [calendarItem]=\"item\"\n            (click)=\"setDate(item)\">{{ item.humanReadable }}\n        </td>\n    </tr>\n</tbody>\n</table>\n"
                }] }
    ];
    /** @nocollapse */
    FuiCalendarYearView.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    return FuiCalendarYearView;
}(CalendarView));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiDatepickerModule = /** @class */ (function () {
    function FuiDatepickerModule() {
    }
    FuiDatepickerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        FuiPopupModule,
                        FuiLocalizationModule,
                        FuiUtilityModule
                    ],
                    declarations: [
                        FuiCalendarItem,
                        FuiCalendarViewTitle,
                        FuiCalendarYearView,
                        FuiCalendarMonthView,
                        FuiCalendarDateView,
                        FuiCalendarHourView,
                        FuiCalendarMinuteView,
                        FuiDatepicker,
                        FuiDatepickerDirective,
                        FuiDatepickerDirectiveValueAccessor,
                        FuiDatepickerDirectiveValidator,
                        FuiDatepickerInputDirective
                    ],
                    exports: [
                        FuiDatepickerDirective,
                        FuiDatepickerDirectiveValueAccessor,
                        FuiDatepickerDirectiveValidator,
                        FuiDatepickerInputDirective
                    ],
                    entryComponents: [
                        FuiDatepicker
                    ]
                },] }
    ];
    return FuiDatepickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiDimmer = /** @class */ (function (_super) {
    __extends(FuiDimmer, _super);
    function FuiDimmer(renderer, element, changeDetector) {
        var _this = _super.call(this, renderer, element, changeDetector) || this;
        _this._isDimmed = false;
        _this.isDimmedChange = new EventEmitter();
        _this.isClickable = true;
        _this.wrapContent = true;
        _this.hasClasses = true;
        return _this;
    }
    Object.defineProperty(FuiDimmer.prototype, "isDimmed", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isDimmed;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var isDimmed = !!value;
            if (!this._transitionController) {
                // Initialise transition functionality when first setting dimmed, to ensure initial state doesn't transition.
                this._transitionController = new TransitionController(isDimmed, 'block');
                this.setTransitionController(this._transitionController);
                this._isDimmed = isDimmed;
            }
            else if (this._isDimmed !== isDimmed) {
                this._isDimmed = isDimmed;
                this._transitionController.stopAll();
                this._transitionController.animate(new Transition('fade', this.transitionDuration, isDimmed ? TransitionDirection.In : TransitionDirection.Out));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiDimmer.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (this.isClickable) {
            this.isDimmed = false;
            this.isDimmedChange.emit(this.isDimmed);
        }
    };
    FuiDimmer.decorators = [
        { type: Component, args: [{
                    selector: 'fui-dimmer',
                    template: "\n<div [class.content]=\"wrapContent\">\n    <ng-content></ng-content>\n</div>\n",
                    styles: ["\n:host.dimmer:not(.hidden) {\n    transition: none;\n    display: flex !important;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiDimmer.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    FuiDimmer.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.dimmer',] }],
        isDimmedChange: [{ type: Output }],
        isClickable: [{ type: Input }],
        transition: [{ type: Input }],
        transitionDuration: [{ type: Input }],
        wrapContent: [{ type: Input }],
        isDimmed: [{ type: HostBinding, args: ['class.active',] }, { type: Input }],
        onClick: [{ type: HostListener, args: ['click',] }]
    };
    return FuiDimmer;
}(FuiTransition));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiDimmerModule = /** @class */ (function () {
    function FuiDimmerModule() {
    }
    FuiDimmerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FuiTransitionModule
                    ],
                    declarations: [
                        FuiDimmer
                    ],
                    exports: [
                        FuiDimmer
                    ]
                },] }
    ];
    return FuiDimmerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Creates essentially a 'string' enum.
/** @type {?} */
var DropdownAutoCloseType = {
    ItemClick: (/** @type {?} */ ('itemClick')),
    OutsideClick: (/** @type {?} */ ('outsideClick')),
    Disabled: (/** @type {?} */ ('disabled'))
};
var DropdownService = /** @class */ (function () {
    function DropdownService(autoCloseMode) {
        if (autoCloseMode === void 0) { autoCloseMode = DropdownAutoCloseType.ItemClick; }
        this.isOpen = false;
        this.isOpenChange = new EventEmitter();
        this.isDisabled = false;
        this.autoCloseMode = autoCloseMode;
        this.children = [];
    }
    Object.defineProperty(DropdownService.prototype, "isNested", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.parent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} isOpen
     * @param {?=} reflectInParent
     * @return {?}
     */
    DropdownService.prototype.setOpenState = /**
     * @param {?} isOpen
     * @param {?=} reflectInParent
     * @return {?}
     */
    function (isOpen, reflectInParent) {
        var _this = this;
        if (reflectInParent === void 0) { reflectInParent = false; }
        if (this.isOpen !== isOpen && !this.isDisabled) {
            // Only update the state if it has changed, and the dropdown isn't disabled.
            this.isOpen = !!isOpen;
            this.isAnimating = true;
            // We must delay the emitting to avoid the 'changed after checked' Angular errors.
            this.delay((/**
             * @return {?}
             */
            function () { return _this.isOpenChange.emit(_this.isOpen); }));
            if (!this.isOpen) {
                // Close the child dropdowns when this one closes.
                this.children.forEach((/**
                 * @param {?} c
                 * @return {?}
                 */
                function (c) { return c.setOpenState(_this.isOpen); }));
            }
            if (this.parent && reflectInParent) {
                // Open the parent dropdowns when this one opens.
                this.parent.setOpenState(this.isOpen, true);
            }
        }
        else if (this.isOpen !== isOpen && this.isDisabled) {
            // If the state has changed, but the dropdown is disabled, re-emit the original isOpen value.
            this.delay((/**
             * @return {?}
             */
            function () { return _this.isOpenChange.emit(_this.isOpen); }));
        }
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    DropdownService.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        if (this.isDisabled !== isDisabled) {
            if (!!isDisabled) {
                // Close the dropdown as it is now disabled
                this.setOpenState(false);
            }
            this.isDisabled = !!isDisabled;
        }
    };
    /**
     * @return {?}
     */
    DropdownService.prototype.toggleOpenState = /**
     * @return {?}
     */
    function () {
        this.setOpenState(!this.isOpen);
    };
    // Registers a dropdown service as a child of this service.
    // Registers a dropdown service as a child of this service.
    /**
     * @param {?} child
     * @return {?}
     */
    DropdownService.prototype.registerChild = 
    // Registers a dropdown service as a child of this service.
    /**
     * @param {?} child
     * @return {?}
     */
    function (child) {
        if (!this.isChildRegistered(child)) {
            this.children.push(child);
            child.parent = this;
        }
    };
    // Recursive method to check if the provided dropdown is already registered as a child, or is a descendant of a child.
    // Recursive method to check if the provided dropdown is already registered as a child, or is a descendant of a child.
    /**
     * @param {?} child
     * @return {?}
     */
    DropdownService.prototype.isChildRegistered = 
    // Recursive method to check if the provided dropdown is already registered as a child, or is a descendant of a child.
    /**
     * @param {?} child
     * @return {?}
     */
    function (child) {
        return this === child || !!this.children
            .find((/**
         * @param {?} c
         * @return {?}
         */
        function (c) { return !!c.children
            .find((/**
         * @param {?} cChild
         * @return {?}
         */
        function (cChild) { return cChild.isChildRegistered(child); })); }));
    };
    // Wipes any nested data, so all services can be cleanly reattached.
    // Wipes any nested data, so all services can be cleanly reattached.
    /**
     * @return {?}
     */
    DropdownService.prototype.clearChildren = 
    // Wipes any nested data, so all services can be cleanly reattached.
    /**
     * @return {?}
     */
    function () {
        this.children.forEach((/**
         * @param {?} c
         * @return {?}
         */
        function (c) {
            c.parent = undefined;
        }));
        this.children = [];
    };
    // Method for delaying an event into the next tick, to avoid Angular "changed after checked" error.
    // Method for delaying an event into the next tick, to avoid Angular "changed after checked" error.
    /**
     * @private
     * @param {?} callback
     * @return {?}
     */
    DropdownService.prototype.delay = 
    // Method for delaying an event into the next tick, to avoid Angular "changed after checked" error.
    /**
     * @private
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        setTimeout((/**
         * @return {?}
         */
        function () { return callback(); }));
    };
    return DropdownService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiDropdownMenuItem = /** @class */ (function () {
    function FuiDropdownMenuItem(_renderer, element) {
        this._renderer = _renderer;
        this.element = element;
        this.isSelected = false;
        this.selectedClass = 'selected';
    }
    Object.defineProperty(FuiDropdownMenuItem.prototype, "isDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            // We must use nativeElement as Angular doesn't have a way of reading class information.
            /** @type {?} */
            var element = (/** @type {?} */ (this.element.nativeElement));
            return element.classList.contains('disabled');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdownMenuItem.prototype, "hasChildDropdown", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.childDropdownMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdownMenuItem.prototype, "isSelected", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isSelected;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // Renderer is used to enable a dynamic class name.
            if (value) {
                this._renderer.addClass(this.element.nativeElement, this.selectedClass);
            }
            else {
                this._renderer.removeClass(this.element.nativeElement, this.selectedClass);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiDropdownMenuItem.prototype.performClick = /**
     * @return {?}
     */
    function () {
        // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
        this.element.nativeElement.click();
    };
    FuiDropdownMenuItem.decorators = [
        { type: Directive, args: [{
                    // We must attach to every '.item' as Angular doesn't support > selectors.
                    selector: '.item'
                },] }
    ];
    /** @nocollapse */
    FuiDropdownMenuItem.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    FuiDropdownMenuItem.propDecorators = {
        childDropdownMenu: [{ type: ContentChild, args: [forwardRef((/**
                     * @return {?}
                     */
                    function () { return FuiDropdownMenu; })), { static: false },] }]
    };
    return FuiDropdownMenuItem;
}());
var FuiDropdownMenu = /** @class */ (function (_super) {
    __extends(FuiDropdownMenu, _super);
    function FuiDropdownMenu(renderer, element, changeDetector) {
        var _this = _super.call(this, renderer, element, changeDetector) || this;
        // Initialise transition functionality.
        _this._transitionController = new TransitionController(false);
        _this.setTransitionController(_this._transitionController);
        _this.menuTransition = 'slide down';
        _this.menuTransitionDuration = 200;
        _this.menuAutoSelectFirst = false;
        _this.menuSelectedItemClass = 'selected';
        // In case the dropdown menu is destroyed before it has a chance to be fully initialised.
        _this._parentKeyDownListener = (/**
         * @return {?}
         */
        function () {
        });
        return _this;
    }
    Object.defineProperty(FuiDropdownMenu.prototype, "parentElement", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._parentKeyDownListener = this._renderer
                .listen(value.nativeElement, 'keydown', (/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                return _this.onParentKeyDown(e);
            }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdownMenu.prototype, "items", {
        set: /**
         * @param {?} items
         * @return {?}
         */
        function (items) {
            this._itemsQueryOverride = items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdownMenu.prototype, "service", {
        get: /**
         * @return {?}
         */
        function () {
            return this._service;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._service = value;
            /** @type {?} */
            var previousIsOpen = this._service.isOpen;
            this._service.isOpenChange.subscribe((/**
             * @param {?} isOpen
             * @return {?}
             */
            function (isOpen) {
                if (isOpen !== previousIsOpen) {
                    // Only run transitions if the open state has changed.
                    _this._transitionController.stopAll();
                    _this._transitionController.animate(new Transition(_this.menuTransition, _this.menuTransitionDuration, TransitionDirection.Either, (/**
                     * @return {?}
                     */
                    function () { return _this._service.isAnimating = false; })));
                }
                if (!isOpen) {
                    // Reset the item selections when a nested item is selected to avoid incosistent open states.
                    if (_this.selectedItems.length > 1) {
                        _this.resetSelection();
                    }
                }
                previousIsOpen = isOpen;
            }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdownMenu.prototype, "_itemsQuery", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._itemsQueryOverride || this._itemsQueryInternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdownMenu.prototype, "_items", {
        // Get the list of items, ignoring those that are disabled.
        get: 
        // Get the list of items, ignoring those that are disabled.
        /**
         * @private
         * @return {?}
         */
        function () {
            return this._itemsQuery.filter((/**
             * @param {?} i
             * @return {?}
             */
            function (i) { return !i.isDisabled; }));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @return {?}
     */
    FuiDropdownMenu.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            if (this._service.autoCloseMode === DropdownAutoCloseType.ItemClick) {
                /** @type {?} */
                var target = (/** @type {?} */ (e.target));
                if (this._element.nativeElement.contains(target.closest('.item')) && !/input|textarea/i.test(target.tagName)) {
                    // Once an item is selected, we can close the entire dropdown.
                    this._service.setOpenState(false, true);
                }
            }
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiDropdownMenu.prototype.onParentKeyDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        // Only the root dropdown (i.e. not nested dropdowns) is responsible for keeping track of the currently selected item.
        if (this._service && this._service.isOpen && !this._service.isNested) {
            // Stop document events like scrolling while open.
            /** @type {?} */
            var target = (/** @type {?} */ (e.target));
            if (!/input/i.test(target.tagName) &&
                [KeyCode.Escape, KeyCode.Enter, KeyCode.Up, KeyCode.Down, KeyCode.Left, KeyCode.Right].find((/**
                 * @param {?} kC
                 * @return {?}
                 */
                function (kC) { return kC === e.keyCode; }))) {
                e.preventDefault();
            }
            // Gets the top selected item from the stack.
            var _a = __read(this.selectedItems.slice(-1), 1), selected = _a[0];
            // Keeping track of the menu containing the currently selected element allows us to easily determine its siblings.
            /** @type {?} */
            var selectedContainer = this;
            if (this.selectedItems.length >= 2) {
                var _b = __read(this.selectedItems.slice(-2), 1), selectedParent = _b[0];
                selectedContainer = selectedParent.childDropdownMenu;
            }
            switch (e.keyCode) {
                // Escape : close the entire dropdown.
                case KeyCode.Escape: {
                    this._service.setOpenState(false);
                    break;
                }
                // Down : select the next item below the current one, or the 1st if none selected.
                case KeyCode.Down:
                // Up : select the next item above the current one, or the 1st if none selected.
                case KeyCode.Up: {
                    this.selectedItems.pop();
                    this.selectedItems.push(selectedContainer.updateSelection(selected, e.keyCode));
                    // Prevent default regardless of whether we are in an input, to stop jumping to the start or end of the query string.
                    e.preventDefault();
                    break;
                }
                // Enter : if the item doesn't contain a nested dropdown, 'click' it. Otherwise, fall through to 'Right' action.
                case KeyCode.Enter: {
                    if (selected && !selected.hasChildDropdown) {
                        selected.performClick();
                        break;
                    }
                }
                // falls through
                // Right : if the selected item contains a nested dropdown, open the dropdown & select the 1st item.
                case KeyCode.Right: {
                    if (selected && selected.hasChildDropdown) {
                        selected.childDropdownMenu.service.setOpenState(true);
                        this.selectedItems.push(selected.childDropdownMenu.updateSelection(selected, e.keyCode));
                    }
                    break;
                }
                // Left : if the selected item is in a nested dropdown, close it and select the containing item.
                case KeyCode.Left: {
                    if (this.selectedItems.length >= 2) {
                        this.selectedItems.pop();
                        var _c = __read(this.selectedItems.slice(-1), 1), selectedParent = _c[0];
                        selectedParent.childDropdownMenu.service.setOpenState(false);
                        selectedParent.isSelected = true;
                    }
                    break;
                }
            }
        }
    };
    /**
     * @return {?}
     */
    FuiDropdownMenu.prototype.resetSelection = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.selectedItems = [];
        this._items.forEach((/**
         * @param {?} i
         * @return {?}
         */
        function (i) {
            i.selectedClass = _this.menuSelectedItemClass;
            i.isSelected = false;
        }));
        if (this.menuAutoSelectFirst && this._items.length > 0) {
            // Autoselect 1st item if required & possible.
            this._items[0].isSelected = true;
            this.scrollToItem(this._items[0]);
            this.selectedItems.push(this._itemsQuery.first);
        }
    };
    // Determines the item to next be selected, based on the keyboard input & the currently selected item.
    // Determines the item to next be selected, based on the keyboard input & the currently selected item.
    /**
     * @param {?} selectedItem
     * @param {?} keyCode
     * @return {?}
     */
    FuiDropdownMenu.prototype.updateSelection = 
    // Determines the item to next be selected, based on the keyboard input & the currently selected item.
    /**
     * @param {?} selectedItem
     * @param {?} keyCode
     * @return {?}
     */
    function (selectedItem, keyCode) {
        if (selectedItem) {
            // Remove the selected status on the previously selected item.
            selectedItem.isSelected = false;
        }
        /** @type {?} */
        var selectedIndex = this._items
            .findIndex((/**
         * @param {?} i
         * @return {?}
         */
        function (i) { return i === selectedItem; }));
        /** @type {?} */
        var newSelection;
        switch (keyCode) {
            case KeyCode.Enter:
            case KeyCode.Right:
            case KeyCode.Down:
                selectedIndex += 1;
                break;
            case KeyCode.Up:
                if (selectedIndex === -1) {
                    // If none are selected, select the 1st item. Should this be `this.items.last - 1`?
                    selectedIndex = 0;
                    break;
                }
                selectedIndex -= 1;
                break;
        }
        // Select the item at the updated index. The || is to stop us selecting past the start or end of the item list.
        newSelection = this._items[selectedIndex] || selectedItem;
        if (newSelection) {
            // Set the selected status on the newly selected item.
            newSelection.isSelected = true;
            // Set the current scroll position to the location of the newly selected item.
            this.scrollToItem(newSelection);
        }
        return newSelection;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    FuiDropdownMenu.prototype.scrollToItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var menu = this._element.nativeElement;
        /** @type {?} */
        var selectedRect = item.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        var menuRect = menu.getBoundingClientRect();
        /** @type {?} */
        var scrollAmount = 0;
        if (selectedRect.bottom > menuRect.bottom) {
            scrollAmount = selectedRect.bottom - menuRect.bottom;
        }
        if (selectedRect.top < menuRect.top) {
            scrollAmount = selectedRect.top - menuRect.top;
        }
        menu.scrollTop += Math.round(scrollAmount);
    };
    /**
     * @return {?}
     */
    FuiDropdownMenu.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.onItemsChanged();
        this._itemsQuery.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.onItemsChanged(); }));
    };
    /**
     * @return {?}
     */
    FuiDropdownMenu.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._parentKeyDownListener();
    };
    /**
     * @private
     * @return {?}
     */
    FuiDropdownMenu.prototype.onItemsChanged = /**
     * @private
     * @return {?}
     */
    function () {
        // We use `_items` rather than `items` in case one or more have become disabled.
        this.resetSelection();
    };
    FuiDropdownMenu.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiDropdownMenu]'
                },] }
    ];
    /** @nocollapse */
    FuiDropdownMenu.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    FuiDropdownMenu.propDecorators = {
        menuTransition: [{ type: Input }],
        menuTransitionDuration: [{ type: Input }],
        menuAutoSelectFirst: [{ type: Input }],
        menuSelectedItemClass: [{ type: Input }],
        _itemsQueryInternal: [{ type: ContentChildren, args: [FuiDropdownMenuItem,] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return FuiDropdownMenu;
}(FuiTransition));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiDropdown = /** @class */ (function () {
    function FuiDropdown(_element) {
        var _this = this;
        this._element = _element;
        this.service = new DropdownService();
        this.service.isOpenChange.subscribe((/**
         * @return {?}
         */
        function () {
            if (_this.service.isOpen) {
                _this._element.nativeElement.focus();
            }
        }));
    }
    Object.defineProperty(FuiDropdown.prototype, "isOpenChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.isOpenChange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdown.prototype, "isActive", {
        get: /**
         * @return {?}
         */
        function () {
            // This is to ensure nested dropdowns don't get made bold.
            return this.service.isOpen && !this.service.isNested;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdown.prototype, "isOpen", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.isOpen;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // If we are opening the dropdown, we want to always open its parents.
            this.service.setOpenState(value, !!value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdown.prototype, "isDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.isDisabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.service.setDisabledState(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdown.prototype, "autoClose", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.autoCloseMode;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.service.autoCloseMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdown.prototype, "children", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            // @ContentChildren includes the current element by default.
            return this._children.filter((/**
             * @param {?} c
             * @return {?}
             */
            function (c) { return c !== _this; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDropdown.prototype, "tabIndex", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.isDisabled || this.service.isNested) {
                // If disabled, remove from tabindex.
                return undefined;
            }
            if (this._tabIndex != undefined) {
                // If custom tabindex, default to that.
                return this._tabIndex;
            }
            // Otherwise, return default of 0.
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiDropdown.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._menu) {
            throw new Error('You must set [fuiDropdownMenu] on the menu element.');
        }
        this._menu.service = this.service;
        this._menu.parentElement = this._element;
        this.childrenUpdated();
        this._children.changes
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.childrenUpdated(); }));
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiDropdown.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            this.service.toggleOpenState();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiDropdown.prototype.onFocusOut = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.externallyClose();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiDropdown.prototype.onKeypress = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        // Block the keyboard event from being fired on parent dropdowns.
        if (!e.eventHandled) {
            if (e.keyCode === KeyCode.Enter) {
                e.eventHandled = true;
                this.service.setOpenState(true);
            }
        }
    };
    /**
     * @private
     * @return {?}
     */
    FuiDropdown.prototype.childrenUpdated = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Reregister child dropdowns each time the menu content changes.
        this.children
            .map((/**
         * @param {?} c
         * @return {?}
         */
        function (c) { return c.service; }))
            .forEach((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return _this.service.registerChild(s); }));
    };
    /**
     * @private
     * @return {?}
     */
    FuiDropdown.prototype.externallyClose = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.service.autoCloseMode === DropdownAutoCloseType.ItemClick ||
            this.service.autoCloseMode === DropdownAutoCloseType.OutsideClick) {
            // No need to reflect in parent since they are also bound to document.
            this.service.setOpenState(false);
        }
    };
    FuiDropdown.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiDropdown]'
                },] }
    ];
    /** @nocollapse */
    FuiDropdown.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    FuiDropdown.propDecorators = {
        _menu: [{ type: ContentChild, args: [FuiDropdownMenu, { static: false },] }],
        isOpenChange: [{ type: Output }],
        isActive: [{ type: HostBinding, args: ['class.active',] }],
        isOpen: [{ type: Input }],
        isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
        autoClose: [{ type: Input }],
        _children: [{ type: ContentChildren, args: [FuiDropdown, { descendants: true },] }],
        _tabIndex: [{ type: Input, args: ['tabindex',] }],
        tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }],
        onKeypress: [{ type: HostListener, args: ['keypress', ['$event'],] }]
    };
    return FuiDropdown;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiDropdownModule = /** @class */ (function () {
    function FuiDropdownModule() {
    }
    FuiDropdownModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FuiTransitionModule
                    ],
                    declarations: [
                        FuiDropdown,
                        FuiDropdownMenu,
                        FuiDropdownMenuItem
                    ],
                    exports: [
                        FuiDropdown,
                        FuiDropdownMenu,
                        FuiDropdownMenuItem
                    ]
                },] }
    ];
    return FuiDropdownModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Helper class to support method chaining when calling `FuiModalService.open(...)`.
/**
 * @template T, U, V
 */
var  
// Helper class to support method chaining when calling `FuiModalService.open(...)`.
/**
 * @template T, U, V
 */
ActiveModal = /** @class */ (function () {
    function ActiveModal(instance, componentRef) {
        var _this = this;
        this._config = instance;
        this._componentRef = componentRef;
        // Automatically destroy the modal component when it has been dismissed.
        this.component.onDismiss.subscribe((/**
         * @return {?}
         */
        function () { return _this._componentRef.destroy(); }));
    }
    Object.defineProperty(ActiveModal.prototype, "component", {
        // Shorthand for direct access to the `FuiModal` instance.
        get: 
        // Shorthand for direct access to the `FuiModal` instance.
        /**
         * @return {?}
         */
        function () {
            return this._componentRef.instance;
        },
        enumerable: true,
        configurable: true
    });
    // Registers a callback for when `onApprove` is fired.
    // Registers a callback for when `onApprove` is fired.
    /**
     * @param {?} callback
     * @return {?}
     */
    ActiveModal.prototype.onApprove = 
    // Registers a callback for when `onApprove` is fired.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        this.component.onApprove.subscribe((/**
         * @param {?} res
         * @return {?}
         */
        function (res) { return callback(res); }));
        return this;
    };
    // Registers a callback for when `onDeny` is fired.
    // Registers a callback for when `onDeny` is fired.
    /**
     * @param {?} callback
     * @return {?}
     */
    ActiveModal.prototype.onDeny = 
    // Registers a callback for when `onDeny` is fired.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        this.component.onDeny.subscribe((/**
         * @param {?} res
         * @return {?}
         */
        function (res) { return callback(res); }));
        return this;
    };
    // Fires the approve event of the modal manually.
    // Fires the approve event of the modal manually.
    /**
     * @param {?} result
     * @return {?}
     */
    ActiveModal.prototype.approve = 
    // Fires the approve event of the modal manually.
    /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        this.component.approve(result);
    };
    // Fires the deny event of the modal manually.
    // Fires the deny event of the modal manually.
    /**
     * @param {?} result
     * @return {?}
     */
    ActiveModal.prototype.deny = 
    // Fires the deny event of the modal manually.
    /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        this.component.deny(result);
    };
    // Removes the modal component instantly, without transitions or firing any events.
    // Removes the modal component instantly, without transitions or firing any events.
    /**
     * @return {?}
     */
    ActiveModal.prototype.destroy = 
    // Removes the modal component instantly, without transitions or firing any events.
    /**
     * @return {?}
     */
    function () {
        this._componentRef.destroy();
    };
    return ActiveModal;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ModalSize = {
    Mini: (/** @type {?} */ ('mini')),
    Tiny: (/** @type {?} */ ('tiny')),
    Small: (/** @type {?} */ ('small')),
    Normal: (/** @type {?} */ ('normal')),
    Large: (/** @type {?} */ ('large'))
};
// Stores a basic set of configuration options for a modal.
/**
 * @template T, U, V
 */
var  
// Stores a basic set of configuration options for a modal.
/**
 * @template T, U, V
 */
ModalConfig = /** @class */ (function () {
    function ModalConfig(context, isClosable) {
        if (context === void 0) { context = undefined; }
        if (isClosable === void 0) { isClosable = true; }
        // Initialise with default values.
        this.isClosable = isClosable;
        this.context = context;
        this.size = ModalSize.Normal;
        this.isFullScreen = false;
        this.isBasic = false;
        this.isInverted = false;
        this.isCentered = true;
        this.mustScroll = false;
        this.transition = 'scale';
        this.transitionDuration = 500;
    }
    return ModalConfig;
}());
// Used when creating a modal from a `TemplateRef`.
/**
 * @template T, U, V
 */
var  
// Used when creating a modal from a `TemplateRef`.
/**
 * @template T, U, V
 */
TemplateModalConfig = /** @class */ (function (_super) {
    __extends(TemplateModalConfig, _super);
    function TemplateModalConfig(template, context, isClosable) {
        if (context === void 0) { context = undefined; }
        if (isClosable === void 0) { isClosable = true; }
        var _this = _super.call(this, context, isClosable) || this;
        _this.template = template;
        return _this;
    }
    return TemplateModalConfig;
}(ModalConfig));
// Used when creating a modal from an existing component.
/**
 * @template T, U, V
 */
var  
// Used when creating a modal from an existing component.
/**
 * @template T, U, V
 */
ComponentModalConfig = /** @class */ (function (_super) {
    __extends(ComponentModalConfig, _super);
    function ComponentModalConfig(component, context, isClosable) {
        if (context === void 0) { context = undefined; }
        if (isClosable === void 0) { isClosable = true; }
        var _this = _super.call(this, context, isClosable) || this;
        _this.component = component;
        return _this;
    }
    return ComponentModalConfig;
}(ModalConfig));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Used to pass ability to control a modal to a component.
/**
 * @template T, U
 */
var  
// Used to pass ability to control a modal to a component.
/**
 * @template T, U
 */
ModalControls = /** @class */ (function () {
    function ModalControls(approve, deny) {
        this.approve = approve;
        this.deny = deny;
    }
    // Use method here rather than arrow variables to make intellisense show they're methods.
    // Use method here rather than arrow variables to make intellisense show they're methods.
    /**
     * @param {?} result
     * @return {?}
     */
    ModalControls.prototype.approve = 
    // Use method here rather than arrow variables to make intellisense show they're methods.
    /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
    };
    /**
     * @param {?} result
     * @return {?}
     */
    ModalControls.prototype.deny = /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
    };
    return ModalControls;
}());
// Injected into custom modal components, to allow control of the modal, and access to a context object.
/**
 * @template T, U, V
 */
var  
// Injected into custom modal components, to allow control of the modal, and access to a context object.
/**
 * @template T, U, V
 */
Modal = /** @class */ (function (_super) {
    __extends(Modal, _super);
    function Modal(controls, context) {
        var _this = 
        // Instances of `ModalControls` are only created in the `FuiModal` constructor,
        // so we take an initialised instance rather than remaking one each time.
        _super.call(this, controls.approve, controls.deny) || this;
        _this.context = context;
        return _this;
    }
    return Modal;
}(ModalControls));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Shorthand for a modal template. Sets up ability to write: `<ng-template let-context let-modal="modal">...</ng-template>`
// We use an abstract class as ModalTemplate tends to be used within decorated properties, which means it needs to exist!
/**
 * @abstract
 * @template T, U, V
 */
var  
// Shorthand for a modal template. Sets up ability to write: `<ng-template let-context let-modal="modal">...</ng-template>`
// We use an abstract class as ModalTemplate tends to be used within decorated properties, which means it needs to exist!
/**
 * @abstract
 * @template T, U, V
 */
ModalTemplate = /** @class */ (function (_super) {
    __extends(ModalTemplate, _super);
    function ModalTemplate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ModalTemplate;
}(TemplateRef));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
var FuiModal = /** @class */ (function () {
    function FuiModal(_renderer, _element, _componentFactory) {
        var _this = this;
        this._renderer = _renderer;
        this._element = _element;
        this._componentFactory = _componentFactory;
        // Initialise with default configuration from `ModalConfig` (to avoid writing defaults twice).
        /** @type {?} */
        var config = new ModalConfig();
        this.loadConfig(config);
        // Event emitters for each of the possible modal outcomes.
        this.onApprove = new EventEmitter();
        this.onDeny = new EventEmitter();
        this.onDismiss = new EventEmitter();
        // Initialise controls with actions for the `approve` and `deny` cases.
        this.controls = new ModalControls((/**
         * @param {?} res
         * @return {?}
         */
        function (res) { return _this.dismiss((/**
         * @return {?}
         */
        function () { return _this.onApprove.emit(res); })); }), (/**
         * @param {?} res
         * @return {?}
         */
        function (res) { return _this.dismiss((/**
         * @return {?}
         */
        function () { return _this.onDeny.emit(res); })); }));
        // Internal variable initialisation.
        this.dimBackground = false;
        this._isClosing = false;
        this.transitionController = new TransitionController(false);
    }
    Object.defineProperty(FuiModal.prototype, "approve", {
        get: /**
         * @return {?}
         */
        function () {
            return this.controls.approve;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiModal.prototype, "deny", {
        get: /**
         * @return {?}
         */
        function () {
            return this.controls.deny;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiModal.prototype, "dynamicClasses", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var classes = {};
            if (this.size) {
                classes[this.size] = true;
            }
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiModal.prototype, "isFullScreen", {
        // Value to deny with when closing via `isClosable`.
        get: 
        // Value to deny with when closing via `isClosable`.
        /**
         * @return {?}
         */
        function () {
            return this._isFullScreen;
        },
        set: /**
         * @param {?} fullScreen
         * @return {?}
         */
        function (fullScreen) {
            this._isFullScreen = Util.DOM.parseBooleanAttribute(fullScreen);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiModal.prototype, "mustScroll", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mustScroll;
        },
        set: /**
         * @param {?} mustScroll
         * @return {?}
         */
        function (mustScroll) {
            this._mustScroll = mustScroll;
            // 'Cache' value in _mustAlwaysScroll so that if `true`, _mustScroll isn't ever auto-updated.
            this._mustAlwaysScroll = mustScroll;
            this.updateScroll();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiModal.prototype, "isInverted", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isInverted;
        },
        set: /**
         * @param {?} inverted
         * @return {?}
         */
        function (inverted) {
            this._isInverted = Util.DOM.parseBooleanAttribute(inverted);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiModal.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Transition the modal to be visible.
        this.transitionController.animate(new Transition(this.transition, this.transitionDuration, TransitionDirection.In));
        setTimeout((/**
         * @return {?}
         */
        function () { return _this.dimBackground = true; }));
    };
    /**
     * @return {?}
     */
    FuiModal.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Move the modal to the document body to ensure correct scrolling.
        this._originalContainer = this._element.nativeElement.parentNode;
        (/** @type {?} */ (document.querySelector('body'))).appendChild(this._element.nativeElement);
        // Remove the #templateSibling element from the DOM to fix bottom border styles.
        /** @type {?} */
        var templateElement = (/** @type {?} */ (this.templateSibling.element.nativeElement));
        if (templateElement.parentNode) {
            templateElement.parentNode.removeChild(templateElement);
        }
        /** @type {?} */
        var element = (/** @type {?} */ (this._modalElement.nativeElement));
        setTimeout((/**
         * @return {?}
         */
        function () { return _this.updateScroll(); }));
        // Focus any element with [autofocus] attribute.
        /** @type {?} */
        var autoFocus = (/** @type {?} */ (element.querySelector('[autofocus]')));
        if (autoFocus) {
            // Autofocus after the browser has had time to process other event handlers.
            setTimeout((/**
             * @return {?}
             */
            function () { return autoFocus.focus(); }), 10);
            // Try to focus again when the modal has opened so that autofocus works in IE11.
            setTimeout((/**
             * @return {?}
             */
            function () { return autoFocus.focus(); }), this.transitionDuration);
        }
    };
    // Updates the modal with the specified configuration.
    // Updates the modal with the specified configuration.
    /**
     * @template V
     * @param {?} config
     * @return {?}
     */
    FuiModal.prototype.loadConfig = 
    // Updates the modal with the specified configuration.
    /**
     * @template V
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this.isClosable = config.isClosable;
        this.closeResult = config.closeResult;
        this.size = config.size;
        this.isFullScreen = config.isFullScreen;
        this.isBasic = config.isBasic;
        this.isInverted = config.isInverted;
        this.isCentered = config.isCentered;
        this.mustScroll = config.mustScroll;
        this.transition = config.transition;
        this.transitionDuration = config.transitionDuration;
    };
    // Closes the modal with a 'deny' outcome, using the specified default reason.
    // Closes the modal with a 'deny' outcome, using the specified default reason.
    /**
     * @return {?}
     */
    FuiModal.prototype.close = 
    // Closes the modal with a 'deny' outcome, using the specified default reason.
    /**
     * @return {?}
     */
    function () {
        if (this.isClosable) {
            // If we are allowed to close, fire the deny result with the default value.
            this.deny(this.closeResult);
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiModal.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        // Makes sense here, as the modal shouldn't be attached to any DOM element.
        e.stopPropagation();
    };
    // Document listener is fine here because nobody will have enough modals open.
    // Document listener is fine here because nobody will have enough modals open.
    /**
     * @param {?} e
     * @return {?}
     */
    FuiModal.prototype.onDocumentKeyUp = 
    // Document listener is fine here because nobody will have enough modals open.
    /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (e.keyCode === KeyCode.Escape) {
            // Close automatically covers case of `!isClosable`, so check not needed.
            this.close();
        }
    };
    /**
     * @return {?}
     */
    FuiModal.prototype.onDocumentResize = /**
     * @return {?}
     */
    function () {
        this.updateScroll();
    };
    // Dismisses the modal with a transition, firing the callback after the modal has finished transitioning.
    // Dismisses the modal with a transition, firing the callback after the modal has finished transitioning.
    /**
     * @private
     * @param {?=} callback
     * @return {?}
     */
    FuiModal.prototype.dismiss = 
    // Dismisses the modal with a transition, firing the callback after the modal has finished transitioning.
    /**
     * @private
     * @param {?=} callback
     * @return {?}
     */
    function (callback) {
        var _this = this;
        if (callback === void 0) { callback = (/**
         * @return {?}
         */
        function () {
        }); }
        // If we aren't currently closing,
        if (!this._isClosing) {
            this._isClosing = true;
            // Transition the modal to be invisible.
            this.dimBackground = false;
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.transition, this.transitionDuration, TransitionDirection.Out, (/**
             * @return {?}
             */
            function () {
                // When done, move the modal back to its original location, emit a dismiss event, and fire the callback.
                if (_this._originalContainer) {
                    _this._originalContainer.appendChild(_this._element.nativeElement);
                }
                _this.onDismiss.emit();
                callback();
            })));
        }
    };
    // Decides whether the modal needs to reposition to allow scrolling.
    // Decides whether the modal needs to reposition to allow scrolling.
    /**
     * @private
     * @return {?}
     */
    FuiModal.prototype.updateScroll = 
    // Decides whether the modal needs to reposition to allow scrolling.
    /**
     * @private
     * @return {?}
     */
    function () {
        // _mustAlwaysScroll works by stopping _mustScroll from being automatically updated, so it stays `true`.
        if (!this._mustAlwaysScroll && this._modalElement) {
            // Fomantic UI modal margin and dimmer padding are 1rem, which is relative to the global font size, so for compatibility:
            /** @type {?} */
            var fontSize = parseFloat(window.getComputedStyle(document.documentElement).getPropertyValue('font-size'));
            /** @type {?} */
            var margin = fontSize * 2;
            /** @type {?} */
            var element = (/** @type {?} */ (this._modalElement.nativeElement));
            // The modal must scroll if the window height is smaller than the modal height + both margins.
            this._mustScroll = window.innerHeight < element.clientHeight + margin * 2;
        }
    };
    FuiModal.decorators = [
        { type: Component, args: [{
                    selector: 'fui-modal',
                    template: "\n<!-- Page dimmer for modal background. -->\n<fui-modal-dimmer [ngClass]=\"{'top aligned': !isCentered}\"\n                  [class.inverted]=\"isInverted\"\n                  [(isDimmed)]=\"dimBackground\"\n                  [transitionDuration]=\"transitionDuration\"\n                  (click)=\"close()\">\n\n    <!-- Modal component, with transition component attached -->\n    <div class=\"ui modal\"\n         [fuiTransition]=\"transitionController\"\n         [class.active]=\"transitionController?.isVisible\"\n         [class.fullscreen]=\"isFullScreen\"\n         [class.basic]=\"isBasic\"\n         [class.scrolling]=\"mustScroll\"\n         [class.inverted]=\"isInverted\"\n         [ngClass]=\"dynamicClasses\"\n         (click)=\"onClick($event)\"\n         #modal>\n\n        <!-- Configurable close icon -->\n        <i class=\"close icon\" *ngIf=\"isClosable\" (click)=\"close()\"></i>\n        <!-- <ng-content> so that <fui-modal> can be used as a normal component. -->\n        <ng-content></ng-content>\n        <!-- @ViewChild reference so we can insert elements beside this div. -->\n        <div #templateSibling></div>\n    </div>\n</fui-modal-dimmer>\n",
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    FuiModal.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: FuiComponentFactory }
    ]; };
    FuiModal.propDecorators = {
        isClosable: [{ type: Input }],
        closeResult: [{ type: Input }],
        onApprove: [{ type: Output, args: ['approved',] }],
        onDeny: [{ type: Output, args: ['denied',] }],
        onDismiss: [{ type: Output, args: ['dismissed',] }],
        size: [{ type: Input }],
        isCentered: [{ type: Input }],
        isBasic: [{ type: Input }],
        transition: [{ type: Input }],
        transitionDuration: [{ type: Input }],
        templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: true },] }],
        _modalElement: [{ type: ViewChild, args: ['modal', { static: false },] }],
        isFullScreen: [{ type: Input }],
        mustScroll: [{ type: Input }],
        isInverted: [{ type: Input }],
        onDocumentKeyUp: [{ type: HostListener, args: ['document:keyup', ['$event'],] }],
        onDocumentResize: [{ type: HostListener, args: ['window:resize',] }]
    };
    return FuiModal;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiModalService = /** @class */ (function () {
    function FuiModalService(_componentFactory) {
        this._componentFactory = _componentFactory;
    }
    /**
     * @template T, U, V
     * @param {?} modal
     * @return {?}
     */
    FuiModalService.prototype.open = /**
     * @template T, U, V
     * @param {?} modal
     * @return {?}
     */
    function (modal) {
        // Generate the modal component to be shown.
        /** @type {?} */
        var componentRef = this._componentFactory.createComponent(FuiModal);
        // Shorthand for the created modal component instance.
        /** @type {?} */
        var modalComponent = componentRef.instance;
        if (modal instanceof TemplateModalConfig) {
            // Inject the template into the view.
            this._componentFactory.createView(modalComponent.templateSibling, modal.template, {
                // `let-context`
                $implicit: modal.context,
                // `let-modal="modal"`
                modal: componentRef.instance.controls
            });
        }
        else if (modal instanceof ComponentModalConfig) {
            // Generate the component to be used as the modal content,
            // injecting an instance of `Modal` to be used in the component constructor.
            /** @type {?} */
            var contentComponentRef = this._componentFactory.createComponent(modal.component, [
                {
                    provide: Modal,
                    useValue: new Modal(modalComponent.controls, modal.context)
                }
            ]);
            // Insert the new component into the content of the modal.
            this._componentFactory.attachToView(contentComponentRef, modalComponent.templateSibling);
            // Shorthand for access to the content component's DOM element.
            /** @type {?} */
            var contentElement = (/** @type {?} */ (contentComponentRef.location.nativeElement));
            // Move all of the DOM elements inside the component to the main modal element.
            // This is done so that CSS classes apply correctly. It does stop any custom styles from working however,
            // so other ways may have to be investigated.
            while (contentElement.hasChildNodes() && contentElement.parentElement && contentElement.firstChild) {
                contentElement.parentElement.appendChild(contentElement.removeChild(contentElement.firstChild));
            }
            // Remove the generated component's 'empty shell' from the DOM.
            this._componentFactory.detachFromDocument(contentComponentRef);
        }
        // Attach the new modal component to the application.
        // The component will move itself to the document body for correctl styling.
        this._componentFactory.attachToApplication(componentRef);
        // Initialise the generated modal with the provided config.
        modalComponent.loadConfig(modal);
        // Return an instance of an `ActiveModal`, so the user can control the new modal.
        return new ActiveModal(modal, componentRef);
    };
    FuiModalService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    FuiModalService.ctorParameters = function () { return [
        { type: FuiComponentFactory }
    ]; };
    return FuiModalService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiModalDimmer = /** @class */ (function (_super) {
    __extends(FuiModalDimmer, _super);
    function FuiModalDimmer(renderer, element, changeDetector) {
        var _this = _super.call(this, renderer, element, changeDetector) || this;
        _this.hasClasses = true;
        _this.isClickable = false;
        return _this;
    }
    FuiModalDimmer.decorators = [
        { type: Component, args: [{
                    selector: 'fui-modal-dimmer',
                    template: "<ng-content></ng-content>",
                    styles: ["\n        :host.ui.dimmer:not(.hidden) {\n            transition: none;\n            overflow-y: auto;\n            display: flex !important;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    FuiModalDimmer.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    FuiModalDimmer.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.page',] }, { type: HostBinding, args: ['class.modals',] }]
    };
    return FuiModalDimmer;
}(FuiDimmer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiModalModule = /** @class */ (function () {
    function FuiModalModule() {
    }
    FuiModalModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FuiDimmerModule,
                        FuiTransitionModule,
                        FuiUtilityModule
                    ],
                    declarations: [
                        FuiModal,
                        FuiModalDimmer
                    ],
                    exports: [
                        FuiModal
                    ],
                    providers: [
                        FuiModalService
                    ],
                    entryComponents: [
                        FuiModal
                    ]
                },] }
    ];
    return FuiModalModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiRating = /** @class */ (function () {
    function FuiRating() {
        this.hoveredIndex = -1;
        this.value = 0;
        this.valueChange = new EventEmitter();
        this.type = 'star';
        this.maximum = 5;
        this.isReadonly = false;
        this.hasClasses = true;
    }
    Object.defineProperty(FuiRating.prototype, "icons", {
        get: /**
         * @return {?}
         */
        function () {
            // tslint:disable-next-line:prefer-literal
            return new Array(this.maximum);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiRating.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            return this._type;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._type = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiRating.prototype, "maximum", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maximum;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._maximum = +value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} i
     * @return {?}
     */
    FuiRating.prototype.onClick = /**
     * @param {?} i
     * @return {?}
     */
    function (i) {
        if (!this.isReadonly) {
            this.value = i + 1;
            this.valueChange.emit(this.value);
        }
    };
    /**
     * @param {?} i
     * @return {?}
     */
    FuiRating.prototype.onMouseover = /**
     * @param {?} i
     * @return {?}
     */
    function (i) {
        this.hoveredIndex = i;
    };
    /**
     * @return {?}
     */
    FuiRating.prototype.onMouseout = /**
     * @return {?}
     */
    function () {
        this.hoveredIndex = -1;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    FuiRating.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    FuiRating.decorators = [
        { type: Component, args: [{
                    selector: 'fui-rating',
                    // tslint:disable-next-line
                    template: "<i *ngFor=\"let icon of icons; let i = index\" class=\"icon {{type}}\" (mouseover)=\"onMouseover(i)\" (click)=\"onClick(i)\" [class.selected]=\"hoveredIndex >= i && !isReadonly\" [class.active]=\"value > i\"></i>",
                    styles: ["\n:host.read-only .icon {\n    cursor: auto\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiRating.ctorParameters = function () { return []; };
    FuiRating.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.rating',] }],
        valueChange: [{ type: Output }],
        isReadonly: [{ type: HostBinding, args: ['class.read-only',] }, { type: Input }],
        type: [{ type: Input }],
        maximum: [{ type: Input }],
        onMouseout: [{ type: HostListener, args: ['mouseout',] }]
    };
    return FuiRating;
}());
var FuiRatingValueAccessor = /** @class */ (function (_super) {
    __extends(FuiRatingValueAccessor, _super);
    function FuiRatingValueAccessor(host) {
        return _super.call(this, host) || this;
    }
    FuiRatingValueAccessor.decorators = [
        { type: Directive, args: [{
                    selector: 'fui-rating',
                    host: { '(valueChange)': 'onChange($event)' },
                    providers: [customValueAccessorFactory(FuiRatingValueAccessor)]
                },] }
    ];
    /** @nocollapse */
    FuiRatingValueAccessor.ctorParameters = function () { return [
        { type: FuiRating }
    ]; };
    return FuiRatingValueAccessor;
}(CustomValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiRatingModule = /** @class */ (function () {
    function FuiRatingModule() {
    }
    FuiRatingModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        FormsModule,
                        CommonModule
                    ],
                    declarations: [
                        FuiRating,
                        FuiRatingValueAccessor
                    ],
                    exports: [
                        FuiRating,
                        FuiRatingValueAccessor
                    ]
                },] }
    ];
    return FuiRatingModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var FuiSearchResult = /** @class */ (function () {
    function FuiSearchResult(componentFactory) {
        this.componentFactory = componentFactory;
        this.hasClasses = true;
        // By default we make this function return an empty string, for the brief moment when it isn't displaying the correct label.
        this.formatter = (/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return ''; });
    }
    Object.defineProperty(FuiSearchResult.prototype, "template", {
        get: /**
         * @return {?}
         */
        function () {
            return this._template;
        },
        set: /**
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._template = template;
            if (this.template) {
                this.componentFactory.createView(this.templateSibling, this.template, {
                    $implicit: this.value,
                    query: this.query
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    FuiSearchResult.decorators = [
        { type: Component, args: [{
                    selector: 'fui-search-result',
                    template: "\n<span #templateSibling></span>\n<span *ngIf=\"!template\" [innerHTML]=\"formatter(value, query)\"></span>\n"
                }] }
    ];
    /** @nocollapse */
    FuiSearchResult.ctorParameters = function () { return [
        { type: FuiComponentFactory }
    ]; };
    FuiSearchResult.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.result',] }],
        value: [{ type: Input }],
        query: [{ type: Input }],
        formatter: [{ type: Input }],
        templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
        template: [{ type: Input }]
    };
    return FuiSearchResult;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
var  /**
 * @template T, U
 */
SearchService = /** @class */ (function () {
    function SearchService(allowEmptyQuery) {
        var _this = this;
        if (allowEmptyQuery === void 0) { allowEmptyQuery = false; }
        this._options = [];
        this.optionsFilter = (/**
         * @param {?} os
         * @param {?} q
         * @return {?}
         */
        function (os, q) {
            // Convert the query string to a RegExp.
            /** @type {?} */
            var regex = _this.toRegex(_this._query);
            if (regex instanceof RegExp) {
                // Only update the results if the query was valid regex.
                // This avoids the results suddenly becoming empty if an invalid regex string is inputted.
                return os
                    // Filter on the options with a string match on the field we are testing.
                    .filter((/**
                 * @param {?} o
                 * @return {?}
                 */
                function (o) { return Util.Object.readValue(o, _this._optionsField)
                    .toString()
                    .match(regex); }));
            }
            // Don't update since it wasn't a valid regex.
            return false;
        });
        // Set default values and reset.
        this.allowEmptyQuery = allowEmptyQuery;
        this.searchDelay = 0;
        this.reset();
    }
    Object.defineProperty(SearchService.prototype, "hasItemLookup", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.optionsLookup && this.optionsLookup.length === 2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchService.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            return this._options;
        },
        set: /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            this._options = options || [];
            // We cannot use both local & remote options simultaneously.
            this._optionsLookup = undefined;
            // Reset entire service with new options.
            this.reset();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchService.prototype, "optionsLookup", {
        get: /**
         * @return {?}
         */
        function () {
            return this._optionsLookup;
        },
        set: /**
         * @param {?} lookupFn
         * @return {?}
         */
        function (lookupFn) {
            this._optionsLookup = lookupFn;
            // As before, cannot use local & remote options simultaneously.
            this._options = [];
            this.reset();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchService.prototype, "optionsField", {
        get: /**
         * @return {?}
         */
        function () {
            return this._optionsField;
        },
        set: /**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            this._optionsField = field;
            // We need to reset otherwise we would now be showing invalid search results.
            this.reset();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchService.prototype, "results", {
        get: /**
         * @return {?}
         */
        function () {
            return this._results;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchService.prototype, "query", {
        get: /**
         * @return {?}
         */
        function () {
            return this._query;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchService.prototype, "isSearching", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isSearching;
        },
        enumerable: true,
        configurable: true
    });
    // Updates the query after the specified search delay.
    // Updates the query after the specified search delay.
    /**
     * @param {?} query
     * @param {?=} callback
     * @return {?}
     */
    SearchService.prototype.updateQueryDelayed = 
    // Updates the query after the specified search delay.
    /**
     * @param {?} query
     * @param {?=} callback
     * @return {?}
     */
    function (query, callback) {
        var _this = this;
        if (callback === void 0) { callback = (/**
         * @return {?}
         */
        function () {
        }); }
        this._query = query;
        clearTimeout(this._searchDelayTimeout);
        this._searchDelayTimeout = window.setTimeout((/**
         * @return {?}
         */
        function () {
            _this.updateQuery(query, callback);
        }), this.searchDelay);
    };
    // Updates the current search query.
    // Updates the current search query.
    /**
     * @param {?} query
     * @param {?=} callback
     * @return {?}
     */
    SearchService.prototype.updateQuery = 
    // Updates the current search query.
    /**
     * @param {?} query
     * @param {?=} callback
     * @return {?}
     */
    function (query, callback) {
        var _this = this;
        if (callback === void 0) { callback = (/**
         * @return {?}
         */
        function () {
        }); }
        this._query = query;
        if (this._query === '' && !this.allowEmptyQuery) {
            // Don't update if the new query is empty (and we don't allow empty queries).
            // Don't reset so that when animating closed we don't get a judder.
            return callback();
        }
        if (this._resultsCache.hasOwnProperty(this._query)) {
            // If the query is already cached, make use of it.
            this._results = this._resultsCache[this._query];
            return callback();
        }
        if (this._optionsLookup) {
            this._isSearching = true;
            // Call the options lookup without a this context.
            /** @type {?} */
            var queryLookup = (/** @type {?} */ (this._optionsLookup.call(undefined, this._query)));
            queryLookup
                .then((/**
             * @param {?} results
             * @return {?}
             */
            function (results) {
                _this._isSearching = false;
                _this.updateResults(results);
                return callback();
            }))
                .catch((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                // Unset 'loading' state, and throw the returned error without updating the results.
                _this._isSearching = false;
                return callback(error);
            }));
            return;
        }
        /** @type {?} */
        var filtered = this.optionsFilter.call(undefined, this._options, this._query);
        if (filtered) {
            this.updateResults(filtered);
        }
        return callback();
    };
    // tslint:disable-next-line:promise-function-async
    // tslint:disable-next-line:promise-function-async
    /**
     * @param {?} initial
     * @return {?}
     */
    SearchService.prototype.initialLookup = 
    // tslint:disable-next-line:promise-function-async
    /**
     * @param {?} initial
     * @return {?}
     */
    function (initial) {
        if (initial instanceof Array) {
            return (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this._optionsLookup)))))(undefined, initial)));
        }
        return (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this._optionsLookup)))))(undefined, initial)));
    };
    // Generates HTML for highlighted match text.
    // Generates HTML for highlighted match text.
    /**
     * @param {?} text
     * @param {?} query
     * @return {?}
     */
    SearchService.prototype.highlightMatches = 
    // Generates HTML for highlighted match text.
    /**
     * @param {?} text
     * @param {?} query
     * @return {?}
     */
    function (text, query) {
        /** @type {?} */
        var regex = this.toRegex(query);
        if (regex instanceof RegExp) {
            return text.replace(regex, (/**
             * @param {?} match
             * @return {?}
             */
            function (match) { return "<b>" + match + "</b>"; }));
        }
        return text;
    };
    // Updates & caches the new set of results.
    // Updates & caches the new set of results.
    /**
     * @private
     * @param {?} results
     * @return {?}
     */
    SearchService.prototype.updateResults = 
    // Updates & caches the new set of results.
    /**
     * @private
     * @param {?} results
     * @return {?}
     */
    function (results) {
        this._resultsCache[this._query] = results;
        this._results = results;
    };
    // Converts a query string to regex without throwing an error.
    // Converts a query string to regex without throwing an error.
    /**
     * @private
     * @param {?} query
     * @return {?}
     */
    SearchService.prototype.toRegex = 
    // Converts a query string to regex without throwing an error.
    /**
     * @private
     * @param {?} query
     * @return {?}
     */
    function (query) {
        try {
            return new RegExp(query, 'i');
        }
        catch (e) {
            return query;
        }
    };
    // Resets the search back to a pristine state.
    // Resets the search back to a pristine state.
    /**
     * @private
     * @return {?}
     */
    SearchService.prototype.reset = 
    // Resets the search back to a pristine state.
    /**
     * @private
     * @return {?}
     */
    function () {
        this._results = [];
        this._resultsCache = {};
        this._isSearching = false;
        this.updateQuery('');
    };
    return SearchService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var FuiSearch = /** @class */ (function () {
    function FuiSearch(_element, renderer, _localizationService) {
        var _this = this;
        this._element = _element;
        this._localizationService = _localizationService;
        this.dropdownService = new DropdownService();
        this.searchService = new SearchService();
        this.onLocaleUpdate();
        this._localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        function () { return _this.onLocaleUpdate(); }));
        this.hasClasses = true;
        this.tabindex = 0;
        this.hasIcon = true;
        this.retainSelectedResult = true;
        this.searchDelay = 200;
        this.maxResults = 7;
        this.onResultSelected = new EventEmitter();
        this.transition = 'scale';
        this.transitionDuration = 200;
    }
    Object.defineProperty(FuiSearch.prototype, "isActive", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dropdownService.isOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "query", {
        get: /**
         * @return {?}
         */
        function () {
            return this.searchService.query;
        },
        set: /**
         * @param {?} query
         * @return {?}
         */
        function (query) {
            var _this = this;
            this.selectedResult = undefined;
            // Initialise a delayed search.
            this.searchService.updateQueryDelayed(query, (/**
             * @return {?}
             */
            function () {
                // Set the results open state depending on whether a query has been entered.
                return _this.dropdownService.setOpenState(_this.searchService.query.length > 0);
            }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "options", {
        set: /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            if (options) {
                this.searchService.options = options;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "optionsFilter", {
        set: /**
         * @param {?} filter
         * @return {?}
         */
        function (filter) {
            if (filter) {
                this.searchService.optionsFilter = filter;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "optionsLookup", {
        set: /**
         * @param {?} lookupFn
         * @return {?}
         */
        function (lookupFn) {
            this.searchService.optionsLookup = lookupFn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "optionsField", {
        set: /**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            this.searchService.optionsField = field;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "searchDelay", {
        set: /**
         * @param {?} delay
         * @return {?}
         */
        function (delay) {
            this.searchService.searchDelay = delay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "isSearching", {
        get: /**
         * @return {?}
         */
        function () {
            return this.searchService.isSearching;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "results", {
        get: /**
         * @return {?}
         */
        function () {
            return this.searchService.results.slice(0, this.maxResults);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "placeholder", {
        // Gets & sets the placeholder text displayed inside the text input.
        get: 
        // Gets & sets the placeholder text displayed inside the text input.
        /**
         * @return {?}
         */
        function () {
            return this._placeholder || this.localeValues.placeholder;
        },
        set: /**
         * @param {?} placeholder
         * @return {?}
         */
        function (placeholder) {
            this._placeholder = placeholder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "localeValues", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localizationService.override(this._localeValues, this.localeOverrides);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSearch.prototype, "resultFormatter", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._resultFormatter) {
                return this._resultFormatter;
            }
            else if (this.searchService.optionsLookup) {
                return (/**
                 * @param {?} r
                 * @return {?}
                 */
                function (r) { return _this.readValue(r); });
            }
            else {
                return (/**
                 * @param {?} r
                 * @param {?} q
                 * @return {?}
                 */
                function (r, q) { return _this.searchService.highlightMatches(_this.readValue(r), q); });
            }
        },
        set: /**
         * @param {?} formatter
         * @return {?}
         */
        function (formatter) {
            this._resultFormatter = formatter;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiSearch.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this._menu.service = this.dropdownService;
    };
    // Selects a result.
    // Selects a result.
    /**
     * @param {?} result
     * @return {?}
     */
    FuiSearch.prototype.select = 
    // Selects a result.
    /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        this.onResultSelected.emit(result);
        this.dropdownService.setOpenState(false);
        if (this.retainSelectedResult) {
            this.selectedResult = result;
            this.searchService.updateQuery(this.readValue(result));
        }
        else {
            this.searchService.updateQuery('');
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSearch.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.open();
    };
    /**
     * @return {?}
     */
    FuiSearch.prototype.onFocusIn = /**
     * @return {?}
     */
    function () {
        if (!this.dropdownService.isAnimating) {
            this.open();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSearch.prototype.onFocusOut = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        console.log(e);
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.dropdownService.setOpenState(false);
        }
    };
    // Reads the specified field from an item.
    // Reads the specified field from an item.
    /**
     * @param {?} object
     * @return {?}
     */
    FuiSearch.prototype.readValue = 
    // Reads the specified field from an item.
    /**
     * @param {?} object
     * @return {?}
     */
    function (object) {
        return Util.Object.readValue(object, this.searchService.optionsField);
    };
    /**
     * @private
     * @return {?}
     */
    FuiSearch.prototype.onLocaleUpdate = /**
     * @private
     * @return {?}
     */
    function () {
        this._localeValues = this._localizationService.get().search;
    };
    /**
     * @private
     * @return {?}
     */
    FuiSearch.prototype.open = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.searchService.query.length > 0) {
            // Only open on click when there is a query entered.
            this.dropdownService.setOpenState(true);
        }
    };
    FuiSearch.decorators = [
        { type: Component, args: [{
                    selector: 'fui-search',
                    template: "\n<div class=\"ui input\" [class.icon]=\"hasIcon\" (click)=\"onClick($event)\">\n    <input class=\"prompt\" type=\"text\" [attr.placeholder]=\"placeholder\" autocomplete=\"off\" [(ngModel)]=\"query\">\n    <i *ngIf=\"hasIcon\" class=\"search icon\"></i>\n</div>\n<div class=\"results\"\n     fuiDropdownMenu\n     [menuTransition]=\"transition\"\n     [menuTransitionDuration]=\"transitionDuration\"\n     menuSelectedItemClass=\"active\">\n\n    <fui-search-result *ngFor=\"let r of results\"\n                       class=\"item\"\n                       [value]=\"r\"\n                       [query]=\"query\"\n                       [formatter]=\"resultFormatter\"\n                       [template]=\"resultTemplate\"\n                       (click)=\"select(r)\"></fui-search-result>\n\n    <div *ngIf=\"results.length == 0\" class=\"message empty\">\n        <div class=\"header\">{{ localeValues.noResults.header }}</div>\n        <div class=\"description\">{{ localeValues.noResults.message }}</div>\n    </div>\n</div>\n",
                    styles: ["\n/* Ensures results div has margin. */\n:host {\n    display: inline-block;\n    outline: 0;\n}\n\n/* Fixes positioning when results are pushed above the search. */\n.results {\n    margin-bottom: .5em;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiSearch.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: FuiLocalizationService }
    ]; };
    FuiSearch.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.search',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        hasIcon: [{ type: Input }],
        resultTemplate: [{ type: Input }],
        retainSelectedResult: [{ type: Input }],
        maxResults: [{ type: Input }],
        onResultSelected: [{ type: Output, args: ['resultSelected',] }],
        transition: [{ type: Input }],
        transitionDuration: [{ type: Input }],
        _menu: [{ type: ViewChild, args: [FuiDropdownMenu, { static: false },] }],
        isActive: [{ type: HostBinding, args: ['class.active',] }],
        options: [{ type: Input }],
        optionsFilter: [{ type: Input }],
        optionsLookup: [{ type: Input }],
        optionsField: [{ type: Input }],
        searchDelay: [{ type: Input }],
        isSearching: [{ type: HostBinding, args: ['class.loading',] }],
        placeholder: [{ type: Input }],
        resultFormatter: [{ type: Input }],
        onFocusIn: [{ type: HostListener, args: ['focusin',] }],
        onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }]
    };
    return FuiSearch;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiSearchModule = /** @class */ (function () {
    function FuiSearchModule() {
    }
    FuiSearchModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        FuiDropdownModule,
                        FuiLocalizationModule,
                        FuiUtilityModule
                    ],
                    declarations: [
                        FuiSearch,
                        FuiSearchResult
                    ],
                    exports: [
                        FuiSearch
                    ]
                },] }
    ];
    return FuiSearchModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var FuiSelectOption = /** @class */ (function (_super) {
    __extends(FuiSelectOption, _super);
    function FuiSelectOption(renderer, element, changeDetector) {
        var _this = 
        // We inherit FuiDropdownMenuItem to automatically gain all keyboard navigation functionality.
        // This is not done via adding the .item class because it isn't supported by Angular.
        _super.call(this, renderer, element) || this;
        _this.changeDetector = changeDetector;
        _this.hasClasses = true;
        _this.isActive = false;
        _this.onSelected = new EventEmitter();
        // By default we make the default text an empty label, for the brief moment when it isn't displaying the correct one.
        _this.renderedText = '';
        _this.usesTemplate = false;
        return _this;
    }
    Object.defineProperty(FuiSelectOption.prototype, "formatter", {
        set: /**
         * @param {?} formatter
         * @return {?}
         */
        function (formatter) {
            if (!this.usesTemplate) {
                this.renderedText = formatter(this.value);
            }
            else {
                this.renderedText = '';
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSelectOption.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        var _this = this;
        e.eventHandled = true;
        setTimeout((/**
         * @return {?}
         */
        function () { return _this.onSelected.emit(_this.value); }));
    };
    FuiSelectOption.decorators = [
        { type: Component, args: [{
                    selector: 'fui-select-option',
                    template: "\n<span #templateSibling></span>\n<span [innerHTML]=\"renderedText\"></span>\n"
                }] }
    ];
    /** @nocollapse */
    FuiSelectOption.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    FuiSelectOption.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.item',] }],
        value: [{ type: Input }],
        onSelected: [{ type: Output }],
        isActive: [{ type: HostBinding, args: ['class.active',] }],
        templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return FuiSelectOption;
}(FuiDropdownMenuItem));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiSelectSearch = /** @class */ (function () {
    function FuiSelectSearch(_renderer, _element) {
        this._renderer = _renderer;
        this._element = _element;
        this.onQueryUpdated = new EventEmitter();
        this.onQueryKeyDown = new EventEmitter();
        this.hasClasses = true;
        this.autoComplete = 'off';
    }
    Object.defineProperty(FuiSelectSearch.prototype, "query", {
        set: /**
         * @param {?} query
         * @return {?}
         */
        function (query) {
            this._renderer.setProperty(this._element.nativeElement, 'value', query);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} query
     * @return {?}
     */
    FuiSelectSearch.prototype.updateQuery = /**
     * @param {?} query
     * @return {?}
     */
    function (query) {
        this.onQueryUpdated.emit(query);
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSelectSearch.prototype.onKeyDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.onQueryKeyDown.emit(e);
    };
    /**
     * @return {?}
     */
    FuiSelectSearch.prototype.focus = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Slightly delay to support in menu search.
        this._element.nativeElement.focus();
        setTimeout((/**
         * @return {?}
         */
        function () { return _this._element.nativeElement.focus(); }));
    };
    FuiSelectSearch.decorators = [
        { type: Directive, args: [{
                    selector: 'input[fuiSelectSearch]'
                },] }
    ];
    /** @nocollapse */
    FuiSelectSearch.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    FuiSelectSearch.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.search',] }],
        autoComplete: [{ type: HostBinding, args: ['attr.autocomplete',] }],
        updateQuery: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
        onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return FuiSelectSearch;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// We use generic type T to smenuTransitionDurationpecify the type of the options we are working with,
// and U to specify the type of the property of the option used as the value.
/**
 * @abstract
 * @template T, U
 */
var FuiSelectBase = /** @class */ (function () {
    function FuiSelectBase(_element, _localizationService) {
        var _this = this;
        this._element = _element;
        this._localizationService = _localizationService;
        this.dropdownService = new DropdownService();
        // We do want an empty query to return all results.
        this.searchService = new SearchService(true);
        this.isSearchable = false;
        this.onLocaleUpdate();
        this._localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        function () { return _this.onLocaleUpdate(); }));
        this._renderedSubscriptions = [];
        this.icon = 'dropdown';
        this.transition = 'slide down';
        this.transitionDuration = 200;
        this.onTouched = new EventEmitter();
        this.hasClasses = true;
    }
    Object.defineProperty(FuiSelectBase.prototype, "isActive", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dropdownService.isOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "isVisible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._menu.isVisible;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "hasSearchClass", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isSearchable && !this.isSearchExternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "isSearching", {
        get: /**
         * @return {?}
         */
        function () {
            return this.searchService.isSearching;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "isClearing", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isClearable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "searchInput", {
        get: /**
         * @return {?}
         */
        function () {
            return this._manualSearch || this._internalSearch;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "tabindex", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.isDisabled) {
                // If disabled, remove from tabindex.
                return -1;
            }
            if (this.dropdownService.isOpen && this.isSearchExternal) {
                // If open & in menu search, remove from tabindex (as input always autofocusses).
                return -1;
            }
            if (this._tabIndex != undefined) {
                // If custom tabindex, default to that.
                return this._tabIndex;
            }
            if (this.hasSearchClass) {
                // If search input enabled, tab goes to input.
                return -1;
            }
            // Otherwise, return default of 0.
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "isDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dropdownService.isDisabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dropdownService.isDisabled = !!value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "options", {
        set: /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            if (options) {
                this.searchService.options = options;
                this.optionsUpdateHook();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "optionsFilter", {
        set: /**
         * @param {?} filter
         * @return {?}
         */
        function (filter) {
            if (filter) {
                this.searchService.optionsFilter = filter;
                this.optionsUpdateHook();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "optionsLookup", {
        set: /**
         * @param {?} lookup
         * @return {?}
         */
        function (lookup) {
            if (lookup) {
                this.searchService.optionsLookup = lookup;
                this.optionsUpdateHook();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "filteredOptions", {
        get: /**
         * @return {?}
         */
        function () {
            return this.searchService.results;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "availableOptions", {
        // Deprecated
        get: 
        // Deprecated
        /**
         * @return {?}
         */
        function () {
            return this.filteredOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "query", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isSearchable ? this.searchService.query : undefined;
        },
        set: /**
         * @param {?} query
         * @return {?}
         */
        function (query) {
            var _this = this;
            if (query != undefined) {
                this.queryUpdateHook();
                this.updateQuery(query);
                // Update the rendered text as query has changed.
                this._renderedOptions.forEach((/**
                 * @param {?} ro
                 * @return {?}
                 */
                function (ro) { return _this.initialiseRenderedOption(ro); }));
                if (this.searchInput) {
                    this.searchInput.query = query;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "labelField", {
        get: /**
         * @return {?}
         */
        function () {
            return this.searchService.optionsField;
        },
        set: /**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            this.searchService.optionsField = field;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "labelGetter", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            // Helper function to retrieve the label from an item.
            return (/**
             * @param {?} obj
             * @return {?}
             */
            function (obj) {
                /** @type {?} */
                var label = Util.Object.readValue(obj, _this.labelField);
                if (label != undefined) {
                    return label.toString();
                }
                return '';
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "valueGetter", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            // Helper function to retrieve the value from an item.
            return (/**
             * @param {?} obj
             * @return {?}
             */
            function (obj) { return Util.Object.readValue(obj, _this.valueField); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "configuredFormatter", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._optionFormatter) {
                return (/**
                 * @param {?} o
                 * @return {?}
                 */
                function (o) { return (/** @type {?} */ (_this._optionFormatter))(o, _this.isSearchable ? _this.query : undefined); });
            }
            else if (this.searchService.optionsLookup) {
                return (/**
                 * @param {?} o
                 * @return {?}
                 */
                function (o) { return _this.labelGetter(o); });
            }
            else {
                return (/**
                 * @param {?} o
                 * @return {?}
                 */
                function (o) { return _this.searchService.highlightMatches(_this.labelGetter(o), _this.query || ''); });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "optionFormatter", {
        set: /**
         * @param {?} formatter
         * @return {?}
         */
        function (formatter) {
            this._optionFormatter = formatter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSelectBase.prototype, "localeValues", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localizationService.override(this._localeValues, this.localeOverrides);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiSelectBase.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._menu.service = this.dropdownService;
        // We manually specify the menu items to the menu because the @ContentChildren doesn't pick up our dynamically rendered items.
        this._menu.items = this._renderedOptions;
        this._menu.parentElement = this._element;
        if (this._manualSearch) {
            this.isSearchable = true;
            this.isSearchExternal = true;
        }
        if (this.searchInput) {
            this.searchInput.onQueryUpdated.subscribe((/**
             * @param {?} q
             * @return {?}
             */
            function (q) { return _this.query = q; }));
            this.searchInput.onQueryKeyDown.subscribe((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return _this.onQueryInputKeydown(e); }));
        }
        // We must call this immediately as changes doesn't fire when you subscribe.
        this.onAvailableOptionsRendered();
        this._renderedOptions.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.onAvailableOptionsRendered(); }));
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSelectBase.prototype.onCaretClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            if (!this.dropdownService.isAnimating) {
                this.dropdownService.setOpenState(!this.dropdownService.isOpen);
                this.focus();
            }
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSelectBase.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!e.eventHandled && !this.dropdownService.isAnimating) {
            e.eventHandled = true;
            // If the dropdown is searchable, clicking should keep it open, otherwise we toggle the open state.
            this.dropdownService.setOpenState(this.isSearchable ? true : !this.dropdownService.isOpen);
            // Immediately focus the search input whenever clicking on the select.
            this.focus();
        }
    };
    /**
     * @return {?}
     */
    FuiSelectBase.prototype.onFocusIn = /**
     * @return {?}
     */
    function () {
        if (!this.dropdownService.isOpen && !this.dropdownService.isAnimating) {
            this.dropdownService.setOpenState(true);
            this.focus();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSelectBase.prototype.onFocusOut = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.dropdownService.setOpenState(false);
            this.onTouched.emit();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSelectBase.prototype.onKeyPress = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (e.keyCode === KeyCode.Enter) {
            // Enables support for focussing and opening with the keyboard alone.
            // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
            this._element.nativeElement.click();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSelectBase.prototype.onKeyDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this.dropdownService.isOpen && e.keyCode === KeyCode.Down) {
            // Enables support for focussing and opening with the keyboard alone.
            // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
            this._element.nativeElement.click();
            e.preventDefault();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    FuiSelectBase.prototype.onQueryInputKeydown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
    };
    /**
     * @return {?}
     */
    FuiSelectBase.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._renderedSubscriptions.forEach((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return s.unsubscribe(); }));
    };
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    /**
     * @protected
     * @return {?}
     */
    FuiSelectBase.prototype.optionsUpdateHook = 
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    /**
     * @protected
     * @return {?}
     */
    function () {
    };
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    /**
     * @protected
     * @return {?}
     */
    FuiSelectBase.prototype.queryUpdateHook = 
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    /**
     * @protected
     * @return {?}
     */
    function () {
    };
    /**
     * @protected
     * @param {?} query
     * @return {?}
     */
    FuiSelectBase.prototype.updateQuery = /**
     * @protected
     * @param {?} query
     * @return {?}
     */
    function (query) {
        var _this = this;
        // Update the query then open the dropdown, as after keyboard input it should always be open.
        this.searchService.updateQuery(query, (/**
         * @return {?}
         */
        function () {
            return _this.dropdownService.setOpenState(true);
        }));
    };
    /**
     * @protected
     * @param {?=} delayed
     * @return {?}
     */
    FuiSelectBase.prototype.resetQuery = /**
     * @protected
     * @param {?=} delayed
     * @return {?}
     */
    function (delayed) {
        if (delayed === void 0) { delayed = true; }
        // The search delay is set to the transition duration to ensure results
        // aren't rendered as the select closes as that causes a sudden flash.
        if (delayed) {
            this.searchService.searchDelay = this._menu.menuTransitionDuration;
            this.searchService.updateQueryDelayed('');
        }
        else {
            this.searchService.updateQuery('');
        }
        if (this.searchInput) {
            this.searchInput.query = '';
        }
    };
    /**
     * @protected
     * @return {?}
     */
    FuiSelectBase.prototype.onAvailableOptionsRendered = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        // Unsubscribe from all previous subscriptions to avoid memory leaks on large selects.
        this._renderedSubscriptions.forEach((/**
         * @param {?} rs
         * @return {?}
         */
        function (rs) { return rs.unsubscribe(); }));
        this._renderedSubscriptions = [];
        this._renderedOptions.forEach((/**
         * @param {?} ro
         * @return {?}
         */
        function (ro) {
            // Slightly delay initialisation to avoid change after checked errors. TODO - look into avoiding this!
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.initialiseRenderedOption(ro); }));
            _this._renderedSubscriptions.push(ro.onSelected.subscribe((/**
             * @return {?}
             */
            function () { return _this.selectOption(ro.value); })));
        }));
        // If no options have been provided, autogenerate them from the rendered ones.
        if (this.searchService.options.length === 0 && !this.searchService.optionsLookup) {
            this.options = this._renderedOptions.map((/**
             * @param {?} ro
             * @return {?}
             */
            function (ro) { return ro.value; }));
        }
    };
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    FuiSelectBase.prototype.initialiseRenderedOption = /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    function (option) {
        option.usesTemplate = !!this.optionTemplate;
        option.formatter = this.configuredFormatter;
        if (option.usesTemplate) {
            this.drawTemplate(option.templateSibling, option.value);
        }
        option.changeDetector.markForCheck();
    };
    /**
     * @protected
     * @param {?} options
     * @param {?} value
     * @return {?}
     */
    FuiSelectBase.prototype.findOption = /**
     * @protected
     * @param {?} options
     * @param {?} value
     * @return {?}
     */
    function (options, value) {
        var _this = this;
        // Tries to find an option in options array
        return options.find((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return value === _this.valueGetter(o); }));
    };
    /**
     * @protected
     * @return {?}
     */
    FuiSelectBase.prototype.focus = /**
     * @protected
     * @return {?}
     */
    function () {
        if (this.isSearchable && this.searchInput) {
            // Focusses the search input only when searchable.
            // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
            this.searchInput.focus();
        }
        else {
            this._element.nativeElement.focus();
        }
    };
    // Helper that draws the provided template beside the provided ViewContainerRef.
    // Helper that draws the provided template beside the provided ViewContainerRef.
    /**
     * @protected
     * @param {?} siblingRef
     * @param {?} value
     * @return {?}
     */
    FuiSelectBase.prototype.drawTemplate = 
    // Helper that draws the provided template beside the provided ViewContainerRef.
    /**
     * @protected
     * @param {?} siblingRef
     * @param {?} value
     * @return {?}
     */
    function (siblingRef, value) {
        siblingRef.clear();
        // Use of `$implicit` means use of <ng-template let-option> syntax is supported.
        siblingRef.createEmbeddedView(this.optionTemplate, {
            $implicit: value,
            query: this.query
        });
    };
    /**
     * @private
     * @return {?}
     */
    FuiSelectBase.prototype.onLocaleUpdate = /**
     * @private
     * @return {?}
     */
    function () {
        this._localeValues = this._localizationService.get().select;
    };
    FuiSelectBase.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.dropdown',] }],
        isClearable: [{ type: Input }],
        isSearchable: [{ type: Input }],
        valueField: [{ type: Input }],
        optionTemplate: [{ type: Input }],
        icon: [{ type: Input }],
        transition: [{ type: Input }],
        transitionDuration: [{ type: Input }],
        onTouched: [{ type: Output, args: ['touched',] }],
        _menu: [{ type: ViewChild, args: [FuiDropdownMenu, { static: true },] }],
        _renderedOptions: [{ type: ContentChildren, args: [FuiSelectOption, { descendants: true },] }],
        _internalSearch: [{ type: ViewChild, args: [FuiSelectSearch, { static: false },] }],
        _manualSearch: [{ type: ContentChild, args: [FuiSelectSearch, { static: false },] }],
        _tabIndex: [{ type: Input, args: ['tabindex',] }],
        isActive: [{ type: HostBinding, args: ['class.active',] }],
        isVisible: [{ type: HostBinding, args: ['class.visible',] }],
        hasSearchClass: [{ type: HostBinding, args: ['class.search',] }],
        isSearching: [{ type: HostBinding, args: ['class.loading',] }],
        isClearing: [{ type: HostBinding, args: ['class.clearable',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
        options: [{ type: Input }],
        optionsFilter: [{ type: Input }],
        optionsLookup: [{ type: Input }],
        labelField: [{ type: Input }],
        optionFormatter: [{ type: Input }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onFocusIn: [{ type: HostListener, args: ['focusin',] }],
        onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }],
        onKeyPress: [{ type: HostListener, args: ['keypress', ['$event'],] }],
        onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return FuiSelectBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var FuiMultiSelectLabel = /** @class */ (function (_super) {
    __extends(FuiMultiSelectLabel, _super);
    function FuiMultiSelectLabel(renderer, element, changeDetector, componentFactory) {
        var _this = _super.call(this, renderer, element, changeDetector) || this;
        _this.componentFactory = componentFactory;
        // Initialise transition functionality.
        _this._transitionController = new TransitionController(false, 'inline-block');
        _this.setTransitionController(_this._transitionController);
        _this.onDeselected = new EventEmitter();
        _this.hasClasses = true;
        _this._transitionController.animate(new Transition('scale', 100, TransitionDirection.In));
        return _this;
    }
    Object.defineProperty(FuiMultiSelectLabel.prototype, "template", {
        get: /**
         * @return {?}
         */
        function () {
            return this._template;
        },
        set: /**
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._template = template;
            if (this.template) {
                this.componentFactory.createView(this.templateSibling, this.template, {
                    $implicit: this.value,
                    query: this.query
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @return {?}
     */
    FuiMultiSelectLabel.prototype.deselectOption = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        var _this = this;
        e.eventHandled = true;
        this._transitionController.animate(new Transition('scale', 100, TransitionDirection.Out, (/**
         * @return {?}
         */
        function () {
            return _this.onDeselected.emit(_this.value);
        })));
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiMultiSelectLabel.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.eventHandled = true;
    };
    FuiMultiSelectLabel.decorators = [
        { type: Component, args: [{
                    selector: 'fui-multi-select-label',
                    template: "\n<span #templateSibling></span>\n<span *ngIf=\"!template\" [innerHTML]=\"formatter(value)\"></span>\n<i class=\"delete icon\" (click)=\"deselectOption($event)\"></i>\n"
                }] }
    ];
    /** @nocollapse */
    FuiMultiSelectLabel.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: FuiComponentFactory }
    ]; };
    FuiMultiSelectLabel.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.label',] }],
        value: [{ type: Input }],
        query: [{ type: Input }],
        onDeselected: [{ type: Output, args: ['deselected',] }],
        formatter: [{ type: Input }],
        templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
        template: [{ type: Input }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return FuiMultiSelectLabel;
}(FuiTransition));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
var FuiMultiSelect = /** @class */ (function (_super) {
    __extends(FuiMultiSelect, _super);
    function FuiMultiSelect(element, localizationService) {
        var _this = _super.call(this, element, localizationService) || this;
        _this.selectedOptions = [];
        _this.selectedOptionsChange = new EventEmitter();
        _this.hasLabels = true;
        _this.hasClasses = true;
        return _this;
    }
    Object.defineProperty(FuiMultiSelect.prototype, "filteredOptions", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.maxSelectedReached) {
                // If we have reached the maximum number of selections, then empty the results completely.
                return [];
            }
            /** @type {?} */
            var searchResults = this.searchService.results;
            if (!this.hasLabels) {
                return searchResults;
            }
            else {
                // Returns the search results \ selected options.
                return searchResults
                    .filter((/**
                 * @param {?} r
                 * @return {?}
                 */
                function (r) { return _this.selectedOptions.find((/**
                 * @param {?} o
                 * @return {?}
                 */
                function (o) { return r === o; })) == undefined; }));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMultiSelect.prototype, "availableOptions", {
        get: /**
         * @return {?}
         */
        function () {
            return this.filteredOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMultiSelect.prototype, "maxSelectedReached", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.maxSelected == undefined) {
                // If there is no maximum then we can immediately return.
                return false;
            }
            return this.selectedOptions.length === this.maxSelected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMultiSelect.prototype, "maxSelectedMessage", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localizationService.interpolate(this.localeValues.multi.maxSelectedMessage, [['max', this.maxSelected.toString()]]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMultiSelect.prototype, "selectedMessage", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localizationService.interpolate(this.localeValues.multi.selectedMessage, [['count', this.selectedOptions.length.toString() === '0' && this._showCountText ?
                        this._showCountText : this.selectedOptions.length.toString()]]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMultiSelect.prototype, "hasLabels", {
        get: /**
         * @return {?}
         */
        function () {
            return this._hasLabels;
        },
        set: /**
         * @param {?} hasLabels
         * @return {?}
         */
        function (hasLabels) {
            this._hasLabels = hasLabels;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMultiSelect.prototype, "showCountText", {
        get: /**
         * @return {?}
         */
        function () {
            return this._showCountText;
        },
        set: /**
         * @param {?} showCountText
         * @return {?}
         */
        function (showCountText) {
            this._showCountText = showCountText;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiMultiSelect.prototype, "placeholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this._placeholder || this.localeValues.multi.placeholder;
        },
        set: /**
         * @param {?} placeholder
         * @return {?}
         */
        function (placeholder) {
            this._placeholder = placeholder;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} option
     * @return {?}
     */
    FuiMultiSelect.prototype.selectOption = /**
     * @param {?} option
     * @return {?}
     */
    function (option) {
        var _this = this;
        if (this.selectedOptions.indexOf(option) !== -1) {
            this.deselectOption(option);
            return;
        }
        this.selectedOptions.push(option);
        this.selectedOptionsChange.emit(this.selectedOptions.map((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return _this.valueGetter(o); })));
        this.resetQuery(false);
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
        if (!this.hasLabels) {
            this.onAvailableOptionsRendered();
        }
    };
    /**
     * @param {?} values
     * @return {?}
     */
    FuiMultiSelect.prototype.writeValue = /**
     * @param {?} values
     * @return {?}
     */
    function (values) {
        var _this = this;
        if (values instanceof Array) {
            if (this.searchService.options.length > 0) {
                // If the options have already been loaded, we can immediately match the ngModel values to options.
                this.selectedOptions = values
                    // non-null assertion added here because Typescript doesn't recognise the non-null filter.
                    .map((/**
                 * @param {?} v
                 * @return {?}
                 */
                function (v) { return (/** @type {?} */ (_this.findOption(_this.searchService.options, v))); }))
                    .filter((/**
                 * @param {?} v
                 * @return {?}
                 */
                function (v) { return v != undefined; }));
            }
            if (values.length > 0 && this.selectedOptions.length === 0) {
                if (this.searchService.hasItemLookup) {
                    // If the search service has a selected lookup function, make use of that to load the initial values.
                    this.searchService
                        .initialLookup(values)
                        .then((/**
                     * @param {?} items
                     * @return {?}
                     */
                    function (items) { return _this.selectedOptions = items; }));
                }
                else {
                    // Otherwise, cache the written value for when options are set.
                    this._writtenOptions = values;
                }
            }
            if (values.length === 0) {
                this.selectedOptions = [];
            }
        }
        else {
            this.selectedOptions = [];
        }
    };
    /**
     * @param {?} option
     * @return {?}
     */
    FuiMultiSelect.prototype.deselectOption = /**
     * @param {?} option
     * @return {?}
     */
    function (option) {
        var _this = this;
        // Update selected options to the previously selected options \ {option}.
        this.selectedOptions = this.selectedOptions.filter((/**
         * @param {?} so
         * @return {?}
         */
        function (so) { return so !== option; }));
        this.selectedOptionsChange.emit(this.selectedOptions.map((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return _this.valueGetter(o); })));
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
        if (!this.hasLabels) {
            this.onAvailableOptionsRendered();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    FuiMultiSelect.prototype.onQueryInputKeydown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.keyCode === KeyCode.Backspace && this.query === '' && this.selectedOptions.length > 0) {
            // Deselect the rightmost option when the user presses backspace in the search input.
            this.deselectOption(this.selectedOptions[this.selectedOptions.length - 1]);
        }
    };
    /**
     * @protected
     * @return {?}
     */
    FuiMultiSelect.prototype.optionsUpdateHook = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._writtenOptions && this.selectedOptions.length > 0) {
            // We need to check the options still exist.
            this.writeValue(this.selectedOptions.map((/**
             * @param {?} o
             * @return {?}
             */
            function (o) { return _this.valueGetter(o); })));
        }
        if (this._writtenOptions && this.searchService.options.length > 0) {
            // If there were values written by ngModel before the options had been loaded, this runs to fix it.
            this.selectedOptions = this._writtenOptions
                // non-null assertion added here because Typescript doesn't recognise the non-null filter.
                .map((/**
             * @param {?} v
             * @return {?}
             */
            function (v) { return (/** @type {?} */ (_this.findOption(_this.searchService.options, v))); }))
                .filter((/**
             * @param {?} v
             * @return {?}
             */
            function (v) { return v != undefined; }));
            if (this.selectedOptions.length === this._writtenOptions.length) {
                this._writtenOptions = undefined;
            }
        }
    };
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    FuiMultiSelect.prototype.initialiseRenderedOption = /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    function (option) {
        _super.prototype.initialiseRenderedOption.call(this, option);
        // Boldens the item so it appears selected in the dropdown.
        option.isActive = !this.hasLabels && this.selectedOptions.indexOf(option.value) !== -1;
    };
    FuiMultiSelect.decorators = [
        { type: Component, args: [{
                    selector: 'fui-multi-select',
                    template: "\n<!-- Dropdown icon -->\n<i class=\"{{ icon }} icon\" (click)=\"onCaretClick($event)\"></i>\n\n<ng-container *ngIf=\"hasLabels\">\n<!-- Multi-select labels -->\n    <fui-multi-select-label *ngFor=\"let selected of selectedOptions;\"\n                            [value]=\"selected\"\n                            [query]=\"query\"\n                            [formatter]=\"configuredFormatter\"\n                            [template]=\"optionTemplate\"\n                            (deselected)=\"deselectOption($event)\"></fui-multi-select-label>\n</ng-container>\n\n<!-- Query input -->\n<input fuiSelectSearch\n       type=\"text\"\n       [hidden]=\"!isSearchable || isSearchExternal\">\n\n<!-- Helper text -->\n<div class=\"text\"\n     [class.default]=\"hasLabels\"\n     [class.filtered]=\"!!query && !isSearchExternal\">\n\n    <!-- Placeholder text -->\n    <ng-container *ngIf=\"hasLabels; else selectedBlock\">{{ placeholder }}</ng-container>\n\n    <!-- Summary shown when labels are hidden -->\n    <ng-template #selectedBlock> {{ selectedMessage }}</ng-template>\n</div>\n\n<!-- Select dropdown menu -->\n<div class=\"menu\"\n     fuiDropdownMenu\n     [menuTransition]=\"transition\"\n     [menuTransitionDuration]=\"transitionDuration\"\n     [menuAutoSelectFirst]=\"true\">\n\n    <ng-content></ng-content>\n    <ng-container *ngIf=\"availableOptions.length == 0 \">\n        <div *ngIf=\"!maxSelectedReached\" class=\"message\">{{ localeValues.noResultsMessage }}</div>\n        <div *ngIf=\"maxSelectedReached\" class=\"message\">{{ maxSelectedMessage }}</div>\n    </ng-container>\n</div>\n",
                    styles: ["\n:host input.search {\n    width: 12em !important;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiMultiSelect.ctorParameters = function () { return [
        { type: ElementRef },
        { type: FuiLocalizationService }
    ]; };
    FuiMultiSelect.propDecorators = {
        selectedOptionsChange: [{ type: Output }],
        maxSelected: [{ type: Input }],
        hasClasses: [{ type: HostBinding, args: ['class.multiple',] }],
        hasLabels: [{ type: Input }],
        showCountText: [{ type: Input }],
        placeholder: [{ type: Input }]
    };
    return FuiMultiSelect;
}(FuiSelectBase));
// Value accessor directive for the select to support ngModel.
/**
 * @template T, U
 */
var FuiMultiSelectValueAccessor = /** @class */ (function (_super) {
    __extends(FuiMultiSelectValueAccessor, _super);
    function FuiMultiSelectValueAccessor(host) {
        return _super.call(this, host) || this;
    }
    FuiMultiSelectValueAccessor.decorators = [
        { type: Directive, args: [{
                    selector: 'fui-multi-select',
                    host: {
                        '(selectedOptionsChange)': 'onChange($event)',
                        '(touched)': 'onTouched()'
                    },
                    providers: [customValueAccessorFactory(FuiMultiSelectValueAccessor)]
                },] }
    ];
    /** @nocollapse */
    FuiMultiSelectValueAccessor.ctorParameters = function () { return [
        { type: FuiMultiSelect }
    ]; };
    return FuiMultiSelectValueAccessor;
}(CustomValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
var FuiSelect = /** @class */ (function (_super) {
    __extends(FuiSelect, _super);
    function FuiSelect(element, localizationService) {
        var _this = _super.call(this, element, localizationService) || this;
        _this.selectedOptionChange = new EventEmitter();
        return _this;
    }
    Object.defineProperty(FuiSelect.prototype, "placeholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this._placeholder || this.localeValues.single.placeholder;
        },
        set: /**
         * @param {?} placeholder
         * @return {?}
         */
        function (placeholder) {
            this._placeholder = placeholder;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} option
     * @return {?}
     */
    FuiSelect.prototype.selectOption = /**
     * @param {?} option
     * @return {?}
     */
    function (option) {
        // Choose and emit the selected option.
        this.selectedOption = option;
        this.selectedOptionChange.emit(this.valueGetter(option));
        this.dropdownService.setOpenState(false);
        this.resetQuery();
        this.drawSelectedOption();
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    FuiSelect.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        if (value != undefined) {
            if (this.searchService.options.length > 0) {
                // If the options have already been loaded, we can immediately match the ngModel value to an option.
                this.selectedOption = this.findOption(this.searchService.options, value);
                this.drawSelectedOption();
            }
            if (this.selectedOption == undefined) {
                if (this.valueField && this.searchService.hasItemLookup) {
                    // If the search service has a selected lookup function, make use of that to load the initial value.
                    this.searchService
                        .initialLookup(value)
                        .then((/**
                     * @param {?} i
                     * @return {?}
                     */
                    function (i) {
                        _this.selectedOption = i;
                        _this.drawSelectedOption();
                    }));
                }
                else {
                    // Otherwise, cache the written value for when options are set.
                    this._writtenOption = value;
                }
            }
        }
        else {
            this.selectedOption = undefined;
            this.drawSelectedOption();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    FuiSelect.prototype.onRemoveClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            this.selectedOption = undefined;
            this.selectedOptionChange.emit(undefined);
            this._renderedOptions.forEach((/**
             * @param {?} o
             * @return {?}
             */
            function (o) { return o.isActive = false; }));
        }
    };
    /**
     * @protected
     * @return {?}
     */
    FuiSelect.prototype.optionsUpdateHook = /**
     * @protected
     * @return {?}
     */
    function () {
        if (!this._writtenOption && this.selectedOption) {
            // We need to check the option still exists.
            this.writeValue(this.valueGetter(this.selectedOption));
        }
        if (this._writtenOption && this.searchService.options.length > 0) {
            // If there was an value written by ngModel before the options had been loaded, this runs to fix it.
            this.selectedOption = this.findOption(this.searchService.options, this._writtenOption);
            if (this.selectedOption) {
                this._writtenOption = undefined;
                this.drawSelectedOption();
            }
        }
    };
    /**
     * @protected
     * @return {?}
     */
    FuiSelect.prototype.queryUpdateHook = /**
     * @protected
     * @return {?}
     */
    function () {
        // When the query is updated, we just abandon the current selection.
        this.selectedOption = undefined;
    };
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    FuiSelect.prototype.initialiseRenderedOption = /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    function (option) {
        _super.prototype.initialiseRenderedOption.call(this, option);
        // Boldens the item so it appears selected in the dropdown.
        option.isActive = option.value === this.selectedOption;
    };
    /**
     * @private
     * @return {?}
     */
    FuiSelect.prototype.drawSelectedOption = /**
     * @private
     * @return {?}
     */
    function () {
        // Updates the active class on the newly selected option.
        if (this._renderedOptions) {
            this.onAvailableOptionsRendered();
        }
        if (this.selectedOption != undefined && this.optionTemplate) {
            this.drawTemplate(this._optionTemplateSibling, this.selectedOption);
        }
    };
    FuiSelect.decorators = [
        { type: Component, args: [{
                    selector: 'fui-select',
                    template: "\n                   <!-- Query input -->\n                   <input fuiSelectSearch\n                          type=\"text\"\n                          [hidden]=\"!isSearchable || isSearchExternal\">\n\n                   <!-- Placeholder text -->\n                   <div *ngIf=\"selectedOption == undefined\" class=\"default text\" [class.filtered]=\"query\">{{ placeholder }}</div>\n                   <!-- Selected item -->\n                   <div class=\"text\" [class.filtered]=\"query || selectedOption == undefined\">\n                       <span #optionTemplateSibling></span>\n                       <span *ngIf=\"!optionTemplate && selectedOption != undefined\"\n                             [innerHTML]=\"configuredFormatter(selectedOption)\"></span>\n                   </div>\n                   <!-- Dropdown icon -->\n                   <i *ngIf=\"selectedOption && !isSearching && isClearable\" class=\"times icon\"\n                      (click)=\"onRemoveClick($event)\"></i>\n                   <i *ngIf=\"!selectedOption || !isClearable\" class=\"{{ icon }} icon\" (click)=\"onCaretClick($event)\"></i>\n                   <!-- Select dropdown menu -->\n                   <div class=\"menu\"\n                        fuiDropdownMenu\n                        [menuTransition]=\"transition\"\n                        [menuTransitionDuration]=\"transitionDuration\"\n                        [menuAutoSelectFirst]=\"isSearchable\">\n\n                       <ng-content></ng-content>\n                       <div *ngIf=\"isSearchable && availableOptions.length === 0\" class=\"message\">\n                           {{ localeValues.noResultsMessage }}\n                       </div>\n                   </div>\n               ",
                    styles: ["\n                   :host .times.icon {\n                       position: absolute;\n                       width: auto;\n                       height: auto;\n                       line-height: 1.21428571em;\n                       top: .78571429em;\n                       right: 1em;\n                       margin: -.78571429em;\n                       opacity: .6;\n                       font-size: 1.07142857em;\n                       padding: .6em;\n                       -webkit-transition: opacity .1s ease;\n                       transition: opacity .1s ease;\n                       z-index: 3;\n                   }\n\n                   :host .times.icon.larger {\n                       padding: .91666667em;\n                       font-size: .85714286em;\n                   }\n\n                   :host .times.icon:hover {\n                       opacity: 1;\n                   }\n               "]
                }] }
    ];
    /** @nocollapse */
    FuiSelect.ctorParameters = function () { return [
        { type: ElementRef },
        { type: FuiLocalizationService }
    ]; };
    FuiSelect.propDecorators = {
        selectedOptionChange: [{ type: Output }],
        _optionTemplateSibling: [{ type: ViewChild, args: ['optionTemplateSibling', { read: ViewContainerRef, static: false },] }],
        placeholder: [{ type: Input }]
    };
    return FuiSelect;
}(FuiSelectBase));
// Value accessor directive for the select to support ngModel.
/**
 * @template T, U
 */
var FuiSelectValueAccessor = /** @class */ (function (_super) {
    __extends(FuiSelectValueAccessor, _super);
    function FuiSelectValueAccessor(host) {
        return _super.call(this, host) || this;
    }
    FuiSelectValueAccessor.decorators = [
        { type: Directive, args: [{
                    selector: 'fui-select',
                    host: {
                        '(selectedOptionChange)': 'onChange($event)',
                        '(touched)': 'onTouched()'
                    },
                    providers: [customValueAccessorFactory(FuiSelectValueAccessor)]
                },] }
    ];
    /** @nocollapse */
    FuiSelectValueAccessor.ctorParameters = function () { return [
        { type: FuiSelect }
    ]; };
    return FuiSelectValueAccessor;
}(CustomValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiSelectModule = /** @class */ (function () {
    function FuiSelectModule() {
    }
    FuiSelectModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        FuiDropdownModule,
                        FuiUtilityModule,
                        FuiLocalizationModule
                    ],
                    declarations: [
                        FuiSelect,
                        FuiSelectOption,
                        FuiSelectSearch,
                        FuiSelectValueAccessor,
                        FuiMultiSelect,
                        FuiMultiSelectLabel,
                        FuiMultiSelectValueAccessor
                    ],
                    exports: [
                        FuiSelect,
                        FuiSelectOption,
                        FuiSelectSearch,
                        FuiSelectValueAccessor,
                        FuiMultiSelect,
                        FuiMultiSelectValueAccessor
                    ]
                },] }
    ];
    return FuiSelectModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var SidebarTransition = {
    Overlay: (/** @type {?} */ ('overlay')),
    Push: (/** @type {?} */ ('push')),
    ScaleDown: (/** @type {?} */ ('scale down')),
    Uncover: (/** @type {?} */ ('uncover')),
    SlideAlong: (/** @type {?} */ ('slide along')),
    SlideOut: (/** @type {?} */ ('slide out'))
};
/** @type {?} */
var SidebarDirection = {
    Left: (/** @type {?} */ ('left')),
    Right: (/** @type {?} */ ('right')),
    Top: (/** @type {?} */ ('top')),
    Bottom: (/** @type {?} */ ('bottom'))
};
var SidebarService = /** @class */ (function () {
    function SidebarService(isVisible) {
        if (isVisible === void 0) { isVisible = false; }
        this.isVisible = isVisible;
        this.isAnimating = false;
        this.wasJustOpened = false;
        this.isVisibleChange = new EventEmitter();
        this.widthChange = new EventEmitter();
        this.heightChange = new EventEmitter();
        this.width = 260;
        this.height = 0;
        this.transition = SidebarTransition.Uncover;
    }
    Object.defineProperty(SidebarService.prototype, "width", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.direction === SidebarDirection.Left) {
                return this._width;
            }
            if (this.direction === SidebarDirection.Right) {
                return -this._width;
            }
            return 0;
        },
        set: /**
         * @param {?} width
         * @return {?}
         */
        function (width) {
            this._width = width;
            this.widthChange.emit();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidebarService.prototype, "height", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.direction === SidebarDirection.Top) {
                return this._height;
            }
            if (this.direction === SidebarDirection.Bottom) {
                return -this._height;
            }
            return 0;
        },
        set: /**
         * @param {?} height
         * @return {?}
         */
        function (height) {
            this._height = height;
            this.heightChange.emit();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} isVisible
     * @return {?}
     */
    SidebarService.prototype.setVisibleState = /**
     * @param {?} isVisible
     * @return {?}
     */
    function (isVisible) {
        var _this = this;
        if (this.isVisible !== isVisible) {
            this.isVisible = isVisible;
            this.isAnimating = true;
            this.wasJustOpened = true;
            this.isVisibleChange.emit(isVisible);
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.wasJustOpened = false; }));
            clearTimeout(this._isAnimatingTimeout);
            this._isAnimatingTimeout = window.setTimeout((/**
             * @return {?}
             */
            function () { return _this.isAnimating = false; }), 500);
        }
    };
    /**
     * @return {?}
     */
    SidebarService.prototype.toggleVisibleState = /**
     * @return {?}
     */
    function () {
        this.setVisibleState(!this.isVisible);
    };
    return SidebarService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiSidebar = /** @class */ (function () {
    function FuiSidebar(_renderer, _element) {
        var _this = this;
        this._renderer = _renderer;
        this._element = _element;
        this.service = new SidebarService();
        // We set the default here as well to force the classes to update.
        this.transition = SidebarTransition.Uncover;
        this.direction = SidebarDirection.Left;
        setTimeout((/**
         * @return {?}
         */
        function () { return _this.updateDimensions(); }));
        this.service.isVisibleChange.subscribe((/**
         * @return {?}
         */
        function () { return _this.updateDimensions(); }));
        this.hasClasses = true;
    }
    Object.defineProperty(FuiSidebar.prototype, "transition", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.transition;
        },
        set: /**
         * @param {?} transition
         * @return {?}
         */
        function (transition) {
            var _this = this;
            this.service.transition.split(' ').forEach((/**
             * @param {?} c
             * @return {?}
             */
            function (c) { return _this.setClass(c, false); }));
            this.service.transition = transition;
            this.service.transition.split(' ').forEach((/**
             * @param {?} c
             * @return {?}
             */
            function (c) { return _this.setClass(c, true); }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSidebar.prototype, "direction", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.direction;
        },
        set: /**
         * @param {?} direction
         * @return {?}
         */
        function (direction) {
            this.setClass(this.service.direction, false);
            this.service.direction = direction;
            this.setClass(this.service.direction, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSidebar.prototype, "isVisible", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.isVisible;
        },
        set: /**
         * @param {?} isVisible
         * @return {?}
         */
        function (isVisible) {
            this.service.setVisibleState(isVisible);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSidebar.prototype, "isVisibleChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.isVisibleChange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSidebar.prototype, "isAnimating", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.isAnimating;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiSidebar.prototype.open = /**
     * @return {?}
     */
    function () {
        this.service.setVisibleState(true);
    };
    /**
     * @return {?}
     */
    FuiSidebar.prototype.close = /**
     * @return {?}
     */
    function () {
        this.service.setVisibleState(false);
    };
    /**
     * @return {?}
     */
    FuiSidebar.prototype.toggle = /**
     * @return {?}
     */
    function () {
        this.service.toggleVisibleState();
    };
    /**
     * @private
     * @return {?}
     */
    FuiSidebar.prototype.updateDimensions = /**
     * @private
     * @return {?}
     */
    function () {
        this.service.width = this._element.nativeElement.offsetWidth;
        this.service.height = this._element.nativeElement.offsetHeight;
    };
    /**
     * @private
     * @param {?} className
     * @param {?=} isAdd
     * @return {?}
     */
    FuiSidebar.prototype.setClass = /**
     * @private
     * @param {?} className
     * @param {?=} isAdd
     * @return {?}
     */
    function (className, isAdd) {
        if (isAdd === void 0) { isAdd = true; }
        if (isAdd) {
            this._renderer.addClass(this._element.nativeElement, className);
        }
        else {
            this._renderer.removeClass(this._element.nativeElement, className);
        }
    };
    FuiSidebar.decorators = [
        { type: Component, args: [{
                    selector: 'fui-sidebar',
                    template: "<ng-content></ng-content>"
                }] }
    ];
    /** @nocollapse */
    FuiSidebar.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    FuiSidebar.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.sidebar',] }, { type: HostBinding, args: ['class.menu',] }],
        transition: [{ type: Input }],
        direction: [{ type: Input }],
        isVisible: [{ type: HostBinding, args: ['class.visible',] }, { type: Input }],
        isVisibleChange: [{ type: Output }],
        isAnimating: [{ type: HostBinding, args: ['class.animating',] }]
    };
    return FuiSidebar;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiSidebarSibling = /** @class */ (function () {
    function FuiSidebarSibling(_renderer, _element) {
        this._renderer = _renderer;
        this._element = _element;
        this.canCloseSidebar = true;
        this.isDimmedWhenVisible = false;
        this.hasClasses = true;
    }
    Object.defineProperty(FuiSidebarSibling.prototype, "isVisible", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.service) {
                return false;
            }
            return this.service.isVisible;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSidebarSibling.prototype, "isDimmed", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.service) {
                return false;
            }
            return this.service.isVisible && this.isDimmedWhenVisible;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiSidebarSibling.prototype, "service", {
        get: /**
         * @return {?}
         */
        function () {
            return this._service;
        },
        set: /**
         * @param {?} service
         * @return {?}
         */
        function (service) {
            var _this = this;
            this._service = service;
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.updateTransform(); }));
            this._service.isVisibleChange.subscribe((/**
             * @return {?}
             */
            function () { return _this.updateTransform(); }));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    FuiSidebarSibling.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.canCloseSidebar && this.service.isVisible && !this.service.wasJustOpened) {
            this.service.setVisibleState(false);
        }
    };
    /**
     * @private
     * @return {?}
     */
    FuiSidebarSibling.prototype.updateTransform = /**
     * @private
     * @return {?}
     */
    function () {
        this._renderer.removeStyle(this._element.nativeElement, 'transform');
        this._renderer.removeStyle(this._element.nativeElement, '-webkit-transform');
        if (this.service.isVisible &&
            this.service.transition !== SidebarTransition.Overlay &&
            this.service.transition !== SidebarTransition.ScaleDown) {
            /** @type {?} */
            var translate = "translate3d(" + this.service.width + "px, " + this.service.height + "px, 0)";
            this._renderer.setStyle(this._element.nativeElement, 'transform', translate);
            this._renderer.setStyle(this._element.nativeElement, '-webkit-transform', translate);
        }
    };
    FuiSidebarSibling.decorators = [
        { type: Component, args: [{
                    selector: 'fui-sidebar-sibling',
                    template: "\n                   <ng-content></ng-content>",
                    styles: ["\n                   :host {\n                       display: block;\n                   }\n               "]
                }] }
    ];
    /** @nocollapse */
    FuiSidebarSibling.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    FuiSidebarSibling.propDecorators = {
        isDimmedWhenVisible: [{ type: Input }],
        hasClasses: [{ type: HostBinding, args: ['class.pusher',] }],
        canCloseSidebar: [{ type: Input }],
        isVisible: [{ type: HostBinding, args: ['class.visible',] }],
        isDimmed: [{ type: HostBinding, args: ['class.dimmed',] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return FuiSidebarSibling;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiSidebarContainer = /** @class */ (function () {
    function FuiSidebarContainer() {
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    FuiSidebarContainer.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (!this.sidebar) {
            throw new Error('You must include a <fui-sidebar> element within the container.');
        }
        this.service = this.sidebar.service;
        if (!this.sibling) {
            throw new Error('You must include a <fui-sidebar-sibling> element within the container.');
        }
        this.sibling.service = this.service;
    };
    FuiSidebarContainer.decorators = [
        { type: Component, args: [{
                    selector: 'fui-sidebar-container',
                    template: "<ng-content></ng-content>",
                    styles: ["\n:host {\n    display: block;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiSidebarContainer.ctorParameters = function () { return []; };
    FuiSidebarContainer.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.pushable',] }],
        sidebar: [{ type: ContentChild, args: [FuiSidebar, { static: false },] }],
        sibling: [{ type: ContentChild, args: [FuiSidebarSibling, { static: false },] }]
    };
    return FuiSidebarContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiSidebarModule = /** @class */ (function () {
    function FuiSidebarModule() {
    }
    FuiSidebarModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        FuiSidebar,
                        FuiSidebarContainer,
                        FuiSidebarSibling
                    ],
                    exports: [
                        FuiSidebar,
                        FuiSidebarContainer,
                        FuiSidebarSibling
                    ]
                },] }
    ];
    return FuiSidebarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Tab = /** @class */ (function () {
    function Tab(header, content) {
        var _this = this;
        this.id = header.id;
        this.header = header;
        this.content = content;
        // So that the header and content isActive properties are always in sync.
        this.header.isActiveChange
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.content.isActive = _this.isActive; }));
    }
    Object.defineProperty(Tab.prototype, "isActive", {
        // Saves accessing .header.isActive every time.
        get: 
        // Saves accessing .header.isActive every time.
        /**
         * @return {?}
         */
        function () {
            return this.header.isActive;
        },
        set: /**
         * @param {?} active
         * @return {?}
         */
        function (active) {
            // Use `setActiveState` so as not to fire 'external changes' event.
            this.header.setActiveState(active);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tab.prototype, "isDisabled", {
        // Saves accessing .header.isDisabled every time.
        get: 
        // Saves accessing .header.isDisabled every time.
        /**
         * @return {?}
         */
        function () {
            return this.header.isDisabled;
        },
        enumerable: true,
        configurable: true
    });
    return Tab;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiTabHeader = /** @class */ (function () {
    function FuiTabHeader() {
        this._isActive = false;
        this.isActiveChange = new EventEmitter();
        this.isActiveExternalChange = new EventEmitter();
        this.onActivate = new EventEmitter();
        this.onDeactivate = new EventEmitter();
        this.isDisabled = false;
        this.hasClasses = true;
    }
    Object.defineProperty(FuiTabHeader.prototype, "isActive", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isActive;
        },
        set: /**
         * @param {?} active
         * @return {?}
         */
        function (active) {
            var _this = this;
            /** @type {?} */
            var isActive = active;
            // Only used by @Input(), runs whenever user input changes `isActive`.
            // Run in timeout because `isDisabled` can prohibit user from changing `isActive`.
            // so update is delayed to avoid 'changed after checked' error.
            setTimeout((/**
             * @return {?}
             */
            function () {
                // Only allow change if tab header is not disabled.
                isActive = !_this.isDisabled ? active : false;
                _this.setActiveState(isActive);
                // Fire 'external change' event as user input has occured.
                _this.isActiveExternalChange.emit(isActive);
            }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiTabHeader.prototype, "isDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isDisabled;
        },
        set: /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            // Only update if value provided is different to current one.
            if (this._isDisabled !== disabled) {
                this._isDisabled = disabled;
                // If now disabled, then tab header must be deactivated.
                if (this.isDisabled) {
                    this.isActive = false;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    // Internally update active state.
    // Internally update active state.
    /**
     * @param {?} active
     * @return {?}
     */
    FuiTabHeader.prototype.setActiveState = 
    // Internally update active state.
    /**
     * @param {?} active
     * @return {?}
     */
    function (active) {
        // If (cast) active value has changed:
        if (!!this._isActive !== active) {
            // Update to the new value.
            this._isActive = active;
            // Fire the appropriate activation event.
            if (active) {
                this.onActivate.emit();
            }
            else {
                this.onDeactivate.emit();
            }
        }
        // Regardless, emit a change to `isActive`, so [(isActive)] works correctly.
        this.isActiveChange.emit(active);
    };
    /**
     * @return {?}
     */
    FuiTabHeader.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (!this.isDisabled) {
            // Activate the tab when clicked, so long as it isn't disabled.
            this.isActive = true;
        }
    };
    FuiTabHeader.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiTabHeader]'
                },] }
    ];
    /** @nocollapse */
    FuiTabHeader.ctorParameters = function () { return []; };
    FuiTabHeader.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.item',] }],
        id: [{ type: Input, args: ['fuiTabHeader',] }],
        isActiveChange: [{ type: Output }],
        onActivate: [{ type: Output, args: ['activate',] }],
        onDeactivate: [{ type: Output, args: ['deactivate',] }],
        isActive: [{ type: HostBinding, args: ['class.active',] }, { type: Input }],
        isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
        onClick: [{ type: HostListener, args: ['click',] }]
    };
    return FuiTabHeader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiTabContent = /** @class */ (function () {
    function FuiTabContent() {
        this.isActive = false;
        this.hasClasses = true;
    }
    FuiTabContent.decorators = [
        { type: Directive, args: [{
                    selector: '[fuiTabContent]'
                },] }
    ];
    /** @nocollapse */
    FuiTabContent.ctorParameters = function () { return []; };
    FuiTabContent.propDecorators = {
        hasClasses: [{ type: HostBinding, args: ['class.tab',] }],
        id: [{ type: Input, args: ['fuiTabContent',] }],
        isActive: [{ type: HostBinding, args: ['class.active',] }]
    };
    return FuiTabContent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiTabset = /** @class */ (function () {
    function FuiTabset() {
        this.tabs = [];
        this._barrierCount = 0;
    }
    Object.defineProperty(FuiTabset.prototype, "activeTab", {
        // When setting a tab as the currently active tab, it automatically gains
        get: 
        // When setting a tab as the currently active tab, it automatically gains
        /**
         * @return {?}
         */
        function () {
            return this._activeTab;
        },
        // `isActive` status (saves littering `isActive = true` everywhere).
        set: 
        // `isActive` status (saves littering `isActive = true` everywhere).
        /**
         * @param {?} tab
         * @return {?}
         */
        function (tab) {
            this._activeTab = tab;
            tab.isActive = true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiTabset.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Fire `internalComponentsUpdated` when the query lists change.
        this._tabHeaders.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.internalComponentsUpdated(); }));
        this._tabContents.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.internalComponentsUpdated(); }));
        // Initially load the tabs.
        this.loadTabs();
    };
    // Activate the first tab in the set.
    // Activate the first tab in the set.
    /**
     * @return {?}
     */
    FuiTabset.prototype.activateFirstTab = 
    // Activate the first tab in the set.
    /**
     * @return {?}
     */
    function () {
        this.activeTab = this.tabs[0];
    };
    // Activates the closest available tab to a given one.
    // Activates the closest available tab to a given one.
    /**
     * @param {?} tab
     * @return {?}
     */
    FuiTabset.prototype.activateClosestTab = 
    // Activates the closest available tab to a given one.
    /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        /** @type {?} */
        var nextAvailable;
        // When the exited tab's index is higher than all available tabs,
        if (tab.index >= this.tabs.length) {
            // Activate the last tab.
            nextAvailable = this.tabs[this.tabs.length - 1];
        }
        // If that didn't work, try the following cases:
        if (!nextAvailable) {
            if (!this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return t === tab; }))) { // When the exited tab no longer exists,
                // Replace it with a tab at the same index.
                nextAvailable = this.tabs[tab.index];
            }
            else { // Or if the exited tab still exists,
                // Go to the tab immediately to the left.
                nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];
            }
        }
        // However, if the chosen tab is disabled,
        if (nextAvailable.isDisabled) {
            // Activate the closest available tab to it.
            return this.activateClosestTab(nextAvailable);
        }
        this.activeTab = nextAvailable;
    };
    // Fires whenever either the tab headers or tab contents query lists update.
    // Fires whenever either the tab headers or tab contents query lists update.
    /**
     * @private
     * @return {?}
     */
    FuiTabset.prototype.internalComponentsUpdated = 
    // Fires whenever either the tab headers or tab contents query lists update.
    /**
     * @private
     * @return {?}
     */
    function () {
        // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.
        // This is so that both the headers and contents query lists can update before we run code that matches the two up.
        this._barrierCount++;
        if (this._barrierCount === 2) {
            // Reset the barrier so it can be called again.
            this._barrierCount = 0;
            // Update the tabs.
            this.loadTabs();
        }
    };
    // Connects tab headers to tab contents, and creates a tab instance for each pairing.
    // Connects tab headers to tab contents, and creates a tab instance for each pairing.
    /**
     * @private
     * @return {?}
     */
    FuiTabset.prototype.loadTabs = 
    // Connects tab headers to tab contents, and creates a tab instance for each pairing.
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Remove any tabs that no longer have an associated header.
        this.tabs = this.tabs.filter((/**
         * @param {?} t
         * @return {?}
         */
        function (t) { return !!_this._tabHeaders.find((/**
         * @param {?} tH
         * @return {?}
         */
        function (tH) { return tH === t.header; })); }));
        this._tabHeaders
            // Filter out the loaded headers with attached tab instances.
            .filter((/**
         * @param {?} tH
         * @return {?}
         */
        function (tH) { return !_this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        function (t) { return t.header === tH; })); }))
            .forEach((/**
         * @param {?} tH
         * @return {?}
         */
        function (tH) {
            /** @type {?} */
            var content = _this._tabContents.find((/**
             * @param {?} tC
             * @return {?}
             */
            function (tC) { return tC.id === tH.id; }));
            if (!content) {
                // Error if an associated tab content cannot be found for the given header.
                throw new Error('A [fuiTabHeader] must have a related [fuiTabContent].');
            }
            // Create a new tab instance for this header & content combo.
            /** @type {?} */
            var tab = new Tab(tH, content);
            // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.
            tab.header.isActiveExternalChange.subscribe((/**
             * @return {?}
             */
            function () { return _this.onHeaderActiveChanged(tab); }));
            // Add the new instance to the list of tabs.
            _this.tabs.push(tab);
        }));
        // Assign each tab an index (which denotes the order they physically appear in).
        this._tabHeaders
            .forEach((/**
         * @param {?} tH
         * @param {?} i
         * @return {?}
         */
        function (tH, i) {
            /** @type {?} */
            var tab = _this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return t.header === tH; }));
            if (tab) {
                tab.index = i;
            }
        }));
        // Sort the tabs by their index.
        this.tabs.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) { return a.index - b.index; }));
        if (!this.activeTab) { // Check if there are no current existing active tabs.
            // If so, we must activate the first available tab.
            this.activateFirstTab();
        }
        else if (!this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        function (t) { return t === _this.activeTab; }))) { // O'wise check if current active tab has been deleted.
            // If so, we must find the closest.
            // Use `setTimeout` as this causes a 'changed after checked' error o'wise.
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.activateClosestTab(_this.activeTab); }));
        }
        if (this.tabs.length === 0) {
            // Error if there aren't any tabs in the tabset.
            throw new Error('You cannot have no tabs!');
        }
    };
    // Fires whenever a tab header's active state is externally changed.
    // Fires whenever a tab header's active state is externally changed.
    /**
     * @private
     * @param {?} tab
     * @return {?}
     */
    FuiTabset.prototype.onHeaderActiveChanged = 
    // Fires whenever a tab header's active state is externally changed.
    /**
     * @private
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        // If the tab has become activated, but was not previously the active tab:
        if (tab.isActive && this.activeTab !== tab) {
            // Deactivate all of the tabs.
            this.tabs.filter((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return t !== tab; })).forEach((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return t.isActive = false; }));
            // Set the currently active tab to this one.
            this.activeTab = tab;
        }
        // If the tab has become deactivated, but was previously the active tab:
        if (!tab.isActive && this.activeTab === tab) {
            // Activate the closest tab to it.
            this.activateClosestTab(tab);
        }
    };
    FuiTabset.decorators = [
        { type: Component, args: [{
                    selector: 'fui-tabset',
                    template: "<ng-content></ng-content>"
                }] }
    ];
    /** @nocollapse */
    FuiTabset.ctorParameters = function () { return []; };
    FuiTabset.propDecorators = {
        _tabHeaders: [{ type: ContentChildren, args: [FuiTabHeader,] }],
        _tabContents: [{ type: ContentChildren, args: [FuiTabContent,] }]
    };
    return FuiTabset;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiTabsModule = /** @class */ (function () {
    function FuiTabsModule() {
    }
    FuiTabsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        FuiTabset,
                        FuiTabHeader,
                        FuiTabContent
                    ],
                    exports: [
                        FuiTabset,
                        FuiTabHeader,
                        FuiTabContent
                    ]
                },] }
    ];
    return FuiTabsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiToastTitle = /** @class */ (function () {
    function FuiToastTitle(templateRef) {
        this.templateRef = templateRef;
    }
    FuiToastTitle.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[fuiToastTitle]' },] }
    ];
    /** @nocollapse */
    FuiToastTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return FuiToastTitle;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiToastMessage = /** @class */ (function () {
    function FuiToastMessage(templateRef) {
        this.templateRef = templateRef;
    }
    FuiToastMessage.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[fuiToastMessage]', },] }
    ];
    /** @nocollapse */
    FuiToastMessage.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return FuiToastMessage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiToast = /** @class */ (function () {
    function FuiToast(elementRef) {
        this.elementRef = elementRef;
        this.closeEvent = new EventEmitter();
        this.icons = {
            info: 'info',
            success: 'checkmark',
            warning: 'warning',
            error: 'times'
        };
        this.dismissible = this.dismissible || true;
        this.title = this.title || '';
        this.message = this.message || '';
        this.class = this.class || 'info';
        if (typeof this.showIcon !== 'string') {
            if (this.showIcon === undefined || this.showIcon === null) {
                this.showIcon = this.icons[this.class];
            }
            else {
                this.showIcon = false;
            }
        }
        this.closeIcon = this.closeIcon || false;
        this.className = this.className || 'ui toast';
        this.progressUp = this.progressUp || true;
        this.displayTime = this.displayTime || 0;
    }
    /**
     * @return {?}
     */
    FuiToast.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.displayTime) {
            window.setTimeout((/**
             * @return {?}
             */
            function () { return _this.close(); }), this.displayTime);
            if (this.showProgress) {
                this.progress = this.progressUp ? 0 : 100;
                window.setTimeout((/**
                 * @return {?}
                 */
                function () { return _this.progress = _this.progressUp ? 100 : 0; }), 300);
            }
        }
    };
    /**
     * @return {?}
     */
    FuiToast.prototype.close = /**
     * @return {?}
     */
    function () {
        this.elementRef.nativeElement.remove();
        this.closeEvent.next(this.id);
    };
    FuiToast.decorators = [
        { type: Component, args: [{
                    selector: 'fui-toast',
                    exportAs: 'fuiToast',
                    template: "\n    <div class=\"toast-box compact\" (click)=\"(dismissible ? (!closeIcon ? close() : null) : null)\">\n      <div *ngIf=\"showProgress && showProgress === 'top'\" class=\"ui attached active progress {{class}} {{showProgress}}\">\n        <div class=\"bar\" [ngStyle]=\"{'transition': 'width ' + (displayTime / 1000)  + 's', 'width': progress + '%'}\"\n             style=\"width: 100%;\"></div>\n      </div>\n      <div class=\"{{class}} {{className}}\" [ngClass]=\"{'icon': showIcon}\">\n        <i *ngIf=\"closeIcon\" class=\"close icon\" (click)=\"close()\"></i>\n        <i *ngIf=\"showIcon\" class=\"{{showIcon}} icon\"></i>\n        <div class=\"content\">\n          <ng-container *ngIf=\"title\">\n            <div class=\"header\">{{title}}</div>\n          </ng-container>\n          <div class=\"header\" *ngIf=\"titleTpl\">\n            <ng-template [ngTemplateOutlet]=\"titleTpl.templateRef\"></ng-template>\n          </div>\n          <ng-container *ngIf=\"message\">\n            <div class=\"body\">{{message}}</div>\n          </ng-container>\n          <div *ngIf=\"messageTpl\" class=\"body\">\n            <ng-template [ngTemplateOutlet]=\"messageTpl.templateRef\"></ng-template>\n          </div>\n        </div>\n      </div>\n      <div *ngIf=\"showProgress && showProgress === 'bottom'\" class=\"ui attached active progress {{class}} {{showProgress}}\">\n        <div class=\"bar\" [ngStyle]=\"{'transition': 'width ' + (displayTime / 1000)  + 's', 'width': progress + '%'}\"\n             style=\"width: 100%;\"></div>\n      </div>\n    </div>\n  "
                }] }
    ];
    /** @nocollapse */
    FuiToast.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    FuiToast.propDecorators = {
        dismissible: [{ type: Input }],
        title: [{ type: Input }],
        message: [{ type: Input }],
        class: [{ type: Input }],
        showIcon: [{ type: Input }],
        closeIcon: [{ type: Input }],
        className: [{ type: Input }],
        progressUp: [{ type: Input }],
        showProgress: [{ type: Input }],
        displayTime: [{ type: Input }],
        id: [{ type: Input }],
        closeEvent: [{ type: Output, args: ['close',] }],
        titleTpl: [{ type: ContentChild, args: [FuiToastTitle, { static: false },] }],
        messageTpl: [{ type: ContentChild, args: [FuiToastMessage, { static: false },] }]
    };
    return FuiToast;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiToastContainer = /** @class */ (function () {
    function FuiToastContainer() {
        this.toastData = [];
        this.timeoutIds = {};
        this.maxId = 0;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    FuiToastContainer.prototype.addToast = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        data.id = data.id || ++this.maxId;
        data.showProgress = data.showProgress || 'bottom';
        data.class = data.class || 'info';
        data.displayTime = data.displayTime || 5000;
        this.toastData.unshift(data);
        this.timeoutIds[data.id] = window.setTimeout((/**
         * @return {?}
         */
        function () { return _this.closeToast(data.id); }), data.displayTime);
    };
    /**
     * @param {?} toastId
     * @return {?}
     */
    FuiToastContainer.prototype.closeToast = /**
     * @param {?} toastId
     * @return {?}
     */
    function (toastId) {
        /** @type {?} */
        var x = this.toastData.findIndex((/**
         * @param {?} t
         * @return {?}
         */
        function (t) { return t.id === toastId; }));
        if (x > -1) {
            /** @type {?} */
            var id = this.toastData[x].id;
            window.clearTimeout(this.timeoutIds[id]);
            delete this.timeoutIds[id];
            this.toastData.splice(x, 1);
        }
    };
    FuiToastContainer.decorators = [
        { type: Component, args: [{
                    selector: 'fui-toast-container',
                    exportAs: 'fuiToastContainer',
                    template: "\n    <fui-toast *ngFor=\"let toast of toastData\"\n               [id]=\"toast.id\"\n               [title]=\"toast.title\"\n               [message]=\"toast.message\"\n               [class]=\"toast.class\"\n               [showProgress]=\"toast.showProgress\"\n               [displayTime]=\"toast.displayTime\"\n               [showIcon]=\"toast.showIcon\"\n               [closeIcon]=\"toast.closeIcon\"\n               [progressUp]=\"toast.progressUp\"\n               [className]=\"toast.className\"\n               (close)=\"closeToast(toast.id)\"></fui-toast>"
                }] }
    ];
    return FuiToastContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiToastConfig = /** @class */ (function () {
    function FuiToastConfig() {
    }
    FuiToastConfig.decorators = [
        { type: Injectable }
    ];
    return FuiToastConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FuiToastModule = /** @class */ (function () {
    function FuiToastModule() {
    }
    FuiToastModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        FuiToastTitle,
                        FuiToastMessage,
                        FuiToast,
                        FuiToastContainer
                    ],
                    exports: [
                        FuiToastTitle,
                        FuiToastMessage,
                        FuiToast,
                        FuiToastContainer
                    ]
                },] }
    ];
    return FuiToastModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FomanticUIModule = /** @class */ (function () {
    function FomanticUIModule() {
    }
    FomanticUIModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    exports: [
                        FuiMessageModule,
                        FuiPaginationModule,
                        FuiAccordionModule,
                        FuiCheckboxModule,
                        FuiCollapseModule,
                        FuiDatepickerModule,
                        FuiDimmerModule,
                        FuiDropdownModule,
                        FuiModalModule,
                        FuiPopupModule,
                        FuiProgressModule,
                        FuiRatingModule,
                        FuiSearchModule,
                        FuiSelectModule,
                        FuiSidebarModule,
                        FuiTabsModule,
                        FuiToastModule,
                        FuiTransitionModule,
                        FuiLocalizationModule,
                        FuiUtilityModule
                    ]
                },] }
    ];
    return FomanticUIModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ComponentModalConfig, DatepickerMode, DropdownAutoCloseType, FomanticUIModule, FuiAccordionModule, FuiActiveMessage, ActiveModal as FuiActiveModal, FuiCheckboxModule, FuiCollapseModule, FuiDatepickerModule, FuiDimmerModule, FuiDropdownModule, FuiLocalizationModule, FuiLocalizationService, FuiMessageContainer, FuiMessageModule, FuiMessageService, Modal as FuiModal, FuiModalModule, FuiModalService, FuiPaginationModule, FuiPopupConfig, FuiPopupModule, FuiProgressModule, FuiRatingModule, FuiSearchModule, FuiSelectModule, FuiSidebarModule, FuiTabsModule, FuiToast, FuiToastConfig, FuiToastContainer, FuiToastMessage, FuiToastModule, FuiToastTitle, FuiTransition, FuiTransitionModule, FuiUtilityModule, MessageConfig, MessageController, MessagePosition, MessageState, ModalConfig, ModalControls, ModalSize, ModalTemplate, PositioningPlacement as PopupPlacement, PopupTrigger, SearchService, SidebarDirection, SidebarTransition, TemplateModalConfig, Transition, TransitionController, TransitionDirection, FuiLocalizationService as ɵa, FuiLocalizationModule as ɵb, FuiDatepickerInputDirective as ɵba, CalendarRangeService as ɵbb, CalendarView as ɵbc, FuiCalendarDateView as ɵbd, FuiCalendarHourView as ɵbe, FuiCalendarMinuteView as ɵbf, FuiCalendarMonthView as ɵbg, FuiCalendarYearView as ɵbh, FuiDatepickerModule as ɵbi, FuiDimmer as ɵbj, FuiDimmerModule as ɵbk, FuiDropdownMenuItem as ɵbl, FuiDropdownMenu as ɵbm, FuiDropdown as ɵbn, FuiDropdownModule as ɵbo, ModalConfig as ɵbp, ModalControls as ɵbq, ModalTemplate as ɵbr, FuiModal as ɵbs, FuiModalService as ɵbt, FuiModalModule as ɵbu, CustomValidator as ɵbv, customValidatorFactory as ɵbw, CustomValueAccessor as ɵbx, customValueAccessorFactory as ɵby, DatePrecision as ɵbz, FuiMessageContainer as ɵc, FuiComponentFactory as ɵca, FuiUtilityModule as ɵcb, FuiPopupComponentController as ɵcc, PopupConfig as ɵcd, FuiPopupController as ɵce, FuiPopupTemplateController as ɵcf, FuiPopupArrow as ɵcg, FuiPopup as ɵch, FuiPopupDirective as ɵci, FuiPopupConfig as ɵcj, FuiPopupModule as ɵck, FuiProgress as ɵcl, FuiProgressModule as ɵcm, FuiRating as ɵcn, FuiRatingValueAccessor as ɵco, FuiRatingModule as ɵcp, FuiSearchResult as ɵcq, FuiSearch as ɵcr, FuiSearchModule as ɵcs, FuiSelectBase as ɵct, FuiMultiSelectLabel as ɵcu, FuiMultiSelect as ɵcv, FuiMultiSelectValueAccessor as ɵcw, FuiSelectOption as ɵcx, FuiSelect as ɵcy, FuiSelectValueAccessor as ɵcz, FuiMessageGlobalContainer as ɵd, FuiSelectSearch as ɵda, FuiSelectModule as ɵdb, FuiSidebarContainer as ɵdc, FuiSidebarSibling as ɵdd, FuiSidebar as ɵde, FuiSidebarModule as ɵdf, FuiTabset as ɵdg, FuiTabContent as ɵdh, FuiTabHeader as ɵdi, FuiTabsModule as ɵdj, FuiToastModule as ɵdk, FuiTransition as ɵdl, FuiTransitionModule as ɵdm, FuiModalDimmer as ɵdn, FuiMessage as ɵe, FuiMessageService as ɵf, FuiMessageModule as ɵg, FuiPagination as ɵh, FuiPaginationModule as ɵi, FuiAccordionPanel as ɵj, FuiAccordion as ɵk, FuiAccordionModule as ɵl, FuiCheckbox as ɵm, FuiCheckboxValueAccessor as ɵn, FuiRadio as ɵo, FuiRadioValueAccessor as ɵp, FuiRadioManager as ɵq, FuiCheckboxModule as ɵr, FuiCollapse as ɵs, FuiCollapseModule as ɵt, FuiCalendarViewTitle as ɵu, FuiDatepicker as ɵv, FuiCalendarItem as ɵw, FuiDatepickerDirective as ɵx, FuiDatepickerDirectiveValueAccessor as ɵy, FuiDatepickerDirectiveValidator as ɵz };
//# sourceMappingURL=ngx-fomantic-ui.js.map
