import { EventEmitter, Injectable, NgModule, Directive, Renderer2, ElementRef, ChangeDetectorRef, HostBinding, Input, Component, Output, forwardRef, ReflectiveInjector, ApplicationRef, ComponentFactoryResolver, Injector, ViewChild, ViewContainerRef, HostListener, ContentChildren, ViewChildren, Host, ContentChild, TemplateRef } from '@angular/core';
import * as $extend from 'extend';
import $extend__default, {  } from 'extend';
import { CommonModule } from '@angular/common';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import Popper from 'popper.js';
import { format, parse } from 'date-fns';
import * as defaultLocale from 'date-fns/locale/en';
import 'element-closest';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const enGB = {
    datepicker: {
        months: [
            'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
        ],
        monthsShort: [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
        ],
        weekdays: [
            'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
        ],
        weekdaysShort: [
            'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
        ],
        weekdaysNarrow: [
            'S', 'M', 'T', 'W', 'T', 'F', 'S'
        ],
        timesOfDay: [
            'a.m.', 'p.m.'
        ],
        timesOfDayUppercase: [
            'AM', 'PM'
        ],
        timesOfDayLowercase: [
            'am', 'pm'
        ],
        formats: {
            time: 'h:mm A',
            datetime: 'D MMMM YYYY h:mm A',
            date: 'D MMMM YYYY',
            month: 'MMMM YYYY',
            year: 'YYYY'
        },
        firstDayOfWeek: 1
    },
    search: {
        placeholder: 'Search...',
        noResults: {
            header: 'No Results',
            message: 'Your search returned no results.'
        }
    },
    select: {
        noResultsMessage: 'No results',
        single: {
            placeholder: 'Select one'
        },
        multi: {
            placeholder: 'Select...',
            maxSelectedMessage: 'Max #{max} selections',
            selectedMessage: '#{count} selections'
        }
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} obj
 * @return {?}
 */
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 * @template T, U
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
function deepExtend(target, source) {
    // Rollup...
    /** @type {?} */
    const extend = $extend__default || $extend;
    return extend(true, target, source);
}
/**
 * @param {?} language
 * @return {?}
 */
function lang(language) {
    return language.toLowerCase().replace('-', '');
}
class FuiLocalizationService {
    constructor() {
        this.onLanguageUpdate = new EventEmitter();
        this._fallbackValues = enGB;
        this._values = {};
        this._language = 'en-GB';
        this.load('en-GB', enGB);
    }
    /**
     * @return {?}
     */
    get language() {
        return this._language;
    }
    /**
     * @param {?} language
     * @return {?}
     */
    setLanguage(language) {
        if (lang(this._language) !== lang(language)) {
            this._language = language;
            this.onLanguageUpdate.emit();
        }
    }
    /**
     * @param {?=} language
     * @return {?}
     */
    get(language = this.language) {
        /** @type {?} */
        const values = deepClone(this._fallbackValues);
        if (!this._values[lang(language)]) {
            throw new Error(`Locale ${language} is not loaded`);
        }
        deepExtend(values, this._values[lang(language)]);
        return deepClone(values);
    }
    /**
     * @template T
     * @param {?} values
     * @param {?} overrides
     * @return {?}
     */
    override(values, overrides) {
        return deepExtend(deepClone(values), overrides);
    }
    /**
     * @param {?} language
     * @param {?} values
     * @return {?}
     */
    load(language, values) {
        this._values[lang(language)] = deepClone(values);
        this.onLanguageUpdate.emit();
    }
    /**
     * @param {?} language
     * @param {?} values
     * @return {?}
     */
    patch(language, values) {
        deepExtend(this._values[lang(language)], values);
    }
    /**
     * @param {?} value
     * @param {?} variables
     * @return {?}
     */
    interpolate(value, variables) {
        return variables.reduce((/**
         * @param {?} s
         * @param {?} __1
         * @return {?}
         */
        (s, [k, v]) => s.replace(new RegExp(`#{${k}}`, 'g'), v)), value);
    }
}
FuiLocalizationService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FuiLocalizationService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiLocalizationModule {
}
FuiLocalizationModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                providers: [FuiLocalizationService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FuiActiveMessage {
}
class ActiveMessage {
    /**
     * @param {?} config
     * @param {?} componentRef
     */
    constructor(config, componentRef) {
        this.config = config;
        this.componentRef = componentRef;
        this.component.onDismiss.subscribe((/**
         * @return {?}
         */
        () => this.componentRef.destroy()));
    }
    /**
     * @return {?}
     */
    get component() {
        return this.componentRef.instance;
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    onClick(callback) {
        this.config.onClick.subscribe((/**
         * @return {?}
         */
        () => callback()));
        return this;
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    onDismiss(callback) {
        this.config.onDismiss.subscribe((/**
         * @return {?}
         */
        () => callback()));
        return this;
    }
    /**
     * @return {?}
     */
    dismiss() {
        this.component.dismiss();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MessageState = {
    Default: (/** @type {?} */ ('')),
    Info: (/** @type {?} */ ('info')),
    Success: (/** @type {?} */ ('success')),
    Warning: (/** @type {?} */ ('warning')),
    Error: (/** @type {?} */ ('error'))
};
class MessageConfig {
    /**
     * @param {?} text
     * @param {?=} state
     * @param {?=} header
     */
    constructor(text, state = MessageState.Default, header) {
        this.text = text;
        this.state = state;
        this.header = header;
        this.timeout = 5000;
        this.extendedTimeout = 1000;
        this.hasDismissButton = true;
        this.hasProgress = false;
        this.transition = 'fade';
        this.transitionInDuration = 400;
        this.transitionOutDuration = 1000;
        this.onClick = new EventEmitter();
        this.onDismiss = new EventEmitter();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MessageController {
    constructor() {
        this.maxShown = 7;
        this.isNewestOnTop = true;
    }
    /**
     * @param {?} container
     * @return {?}
     */
    registerContainer(container) {
        this._container = container;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    show(config) {
        this.throwContainerError();
        return this._container.show(config, this.maxShown, this.isNewestOnTop);
    }
    /**
     * @return {?}
     */
    dismissAll() {
        this.throwContainerError();
        return this._container.dismissAll();
    }
    /**
     * @private
     * @return {?}
     */
    throwContainerError() {
        if (!this._container) {
            throw new Error('You must pass this controller to a message container.');
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const TransitionDirection = {
    In: 0,
    Out: 1,
    Either: 2,
    Static: 3,
};
TransitionDirection[TransitionDirection.In] = 'In';
TransitionDirection[TransitionDirection.Out] = 'Out';
TransitionDirection[TransitionDirection.Either] = 'Either';
TransitionDirection[TransitionDirection.Static] = 'Static';
class Transition {
    /**
     * @param {?} name
     * @param {?=} duration
     * @param {?=} direction
     * @param {?=} onComplete
     */
    constructor(name, duration = 250, direction = TransitionDirection.Either, onComplete = (/**
     * @return {?}
     */
    () => {
    })) {
        this.type = name;
        // We set a minimum duration of 1ms, to give the appearance of an immediate transition
        // whilst allowing positioning calculations to happen without a visible flicker.
        this.duration = Math.max(duration, 1);
        this.direction = direction;
        this.classes = this.type.split(' ');
        this.onComplete = onComplete;
    }
    // Converts TransitionDirection to class name.
    /**
     * @return {?}
     */
    get directionClass() {
        switch (this.direction) {
            case TransitionDirection.In:
                return 'in';
            case TransitionDirection.Out:
                return 'out';
        }
        return '';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TransitionController {
    /**
     * @param {?=} isInitiallyVisible
     * @param {?=} display
     */
    constructor(isInitiallyVisible = true, display = 'block') {
        // isInitiallyVisible sets whether the element starts out visible.
        this._isVisible = isInitiallyVisible;
        this._isHidden = !this._isVisible;
        this._display = display;
        this._queue = [];
        this._isAnimating = false;
    }
    /**
     * @return {?}
     */
    get isAnimating() {
        return this._isAnimating;
    }
    /**
     * @return {?}
     */
    get isVisible() {
        return this._isVisible;
    }
    /**
     * @return {?}
     */
    get isHidden() {
        return this._isHidden;
    }
    // Used to delay animations until we have an element to animate.
    /**
     * @private
     * @return {?}
     */
    get _isReady() {
        return this._renderer != undefined && this._element != undefined && this._changeDetector != undefined;
    }
    // Gets the first transition in the queue.
    /**
     * @private
     * @return {?}
     */
    get _queueFirst() {
        return this._queue[0];
    }
    // Gets the last transition in the queue.
    /**
     * @private
     * @return {?}
     */
    get _queueLast() {
        return this._queue[this._queue.length - 1];
    }
    // Sets the renderer to be used for animating.
    /**
     * @param {?} renderer
     * @return {?}
     */
    registerRenderer(renderer) {
        this._renderer = renderer;
        this.performTransition();
    }
    // Sets the element to perform the animations on.
    /**
     * @param {?} element
     * @return {?}
     */
    registerElement(element) {
        this._element = element;
        this.performTransition();
    }
    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.
    /**
     * @param {?} changeDetector
     * @return {?}
     */
    registerChangeDetector(changeDetector) {
        this._changeDetector = changeDetector;
        this.performTransition();
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    animate(transition) {
        // Test if transition is one of the list that doesn't change the visible state.
        // Should these eventually become classes?
        /** @type {?} */
        const isDirectionless = ['jiggle', 'flash', 'shake', 'pulse', 'tada', 'bounce'].indexOf(transition.type) !== -1;
        if (isDirectionless) {
            transition.direction = TransitionDirection.Static;
        }
        else if (transition.direction == undefined || transition.direction === TransitionDirection.Either) {
            // Set the direction to the opposite of the current visible state automatically if not set, or set to either direction.
            transition.direction = this._isVisible ? TransitionDirection.Out : TransitionDirection.In;
            if (this._queueLast) {
                // If there is an transition in the queue already, set the direction to the opposite of the direction of that transition.
                if (this._queueLast.direction === TransitionDirection.In) {
                    transition.direction = TransitionDirection.Out;
                }
                else if (this._queueLast.direction === TransitionDirection.Out) {
                    transition.direction = TransitionDirection.In;
                }
            }
        }
        // Store the transition in the queue before attempting to perform it.
        this._queue.push(transition);
        this.performTransition();
    }
    // Stops the current transition, leaves the rest of the queue intact.
    /**
     * @param {?=} transition
     * @return {?}
     */
    stop(transition = this._queueFirst) {
        if (!transition || !this._isAnimating) {
            return;
        }
        this.finalizeTransition(transition);
    }
    // Cancels the current transition, leaves the rest of the queue intact.
    /**
     * @param {?=} transition
     * @return {?}
     */
    cancel(transition = this._queueFirst) {
        if (!transition || !this._isAnimating) {
            return;
        }
        this.completeTransition(transition);
        if (transition.direction === TransitionDirection.In) {
            // Return hidden class if we were originally transitioning in.
            this._isHidden = true;
        }
    }
    // Stops the current transition, and empties the queue.
    /**
     * @return {?}
     */
    stopAll() {
        this.clearQueue();
        this.stop();
    }
    /**
     * @return {?}
     */
    cancelAll() {
        this.clearQueue();
        this.cancel();
    }
    // Empties the transition queue but carries on with the current transition.
    /**
     * @return {?}
     */
    clearQueue() {
        if (this.isAnimating) {
            this._queue = [this._queueFirst];
            return;
        }
        this._queue = [];
    }
    /**
     * @private
     * @return {?}
     */
    performTransition() {
        if (!this._isReady || this._isAnimating || !this._queueFirst) {
            // Don't transition until we are ready, or if we are animating, or if there aren't any transitions in the queue.
            return;
        }
        this._isAnimating = true;
        /** @type {?} */
        const transition = this._queueFirst;
        // Set the Fomantic UI classes for transitioning.
        transition.classes.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this._renderer.addClass(this._element, c)));
        this._renderer.addClass(this._element, `animating`);
        this._renderer.addClass(this._element, transition.directionClass);
        // Set the Fomantic UI styles for transitioning.
        this._renderer.setStyle(this._element, `animationDuration`, `${transition.duration}ms`);
        this._renderer.setStyle(this._element, `display`, this._display);
        if (transition.direction === TransitionDirection.In) {
            // Unset hidden if we are transitioning in.
            this._isHidden = false;
        }
        // Wait the length of the animation before calling the complete callback.
        this._animationTimeout = window.setTimeout((/**
         * @return {?}
         */
        () => this.finalizeTransition(transition)), transition.duration);
    }
    /**
     * @private
     * @param {?} transition
     * @return {?}
     */
    completeTransition(transition) {
        transition.classes.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this._renderer.removeClass(this._element, c)));
        this._renderer.removeClass(this._element, `animating`);
        this._renderer.removeClass(this._element, transition.directionClass);
        this._renderer.removeStyle(this._element, `animationDuration`);
        this._renderer.removeStyle(this._element, `display`);
        // Delete the transition from the queue.
        this._queue.shift();
        this._isAnimating = false;
        this._changeDetector.markForCheck();
        clearTimeout(this._animationTimeout);
    }
    // Called when a transition has completed.
    /**
     * @private
     * @param {?} transition
     * @return {?}
     */
    finalizeTransition(transition) {
        this.completeTransition(transition);
        if (transition.direction === TransitionDirection.In) {
            // If we have just animated in, we are now visible.
            this._isVisible = true;
        }
        else if (transition.direction === TransitionDirection.Out) {
            // If we have transitioned out, we should be invisible and hidden.
            this._isVisible = false;
            this._isHidden = true;
        }
        if (transition.onComplete) {
            // Call the user-defined transition callback.
            transition.onComplete();
        }
        // Immediately attempt to perform another transition.
        this.performTransition();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTransition {
    /**
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} _changeDetector
     */
    constructor(_renderer, _element, _changeDetector) {
        this._renderer = _renderer;
        this._element = _element;
        this._changeDetector = _changeDetector;
        this.transitionClass = true;
    }
    /**
     * @param {?} tC
     * @return {?}
     */
    set fuiTransition(tC) {
        // Set the transition controller (e.g. '<div [fuiTransition]="transitionController"></div>').
        this.setTransitionController(tC);
    }
    /**
     * @return {?}
     */
    get isVisible() {
        if (this._controller) {
            return this._controller.isVisible;
        }
        return false;
    }
    /**
     * @return {?}
     */
    get isHidden() {
        if (this._controller) {
            return this._controller.isHidden;
        }
        return false;
    }
    // Initialises the controller with the injected renderer and elementRef.
    /**
     * @param {?} transitionController
     * @return {?}
     */
    setTransitionController(transitionController) {
        this._controller = transitionController;
        this._controller.registerRenderer(this._renderer);
        this._controller.registerElement(this._element.nativeElement);
        this._controller.registerChangeDetector(this._changeDetector);
    }
}
FuiTransition.decorators = [
    { type: Directive, args: [{
                selector: '[fuiTransition]',
                exportAs: 'transition'
            },] }
];
/** @nocollapse */
FuiTransition.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiTransition.propDecorators = {
    transitionClass: [{ type: HostBinding, args: ['class.transition',] }],
    fuiTransition: [{ type: Input }],
    isVisible: [{ type: HostBinding, args: ['class.visible',] }],
    isHidden: [{ type: HostBinding, args: ['class.hidden',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTransitionModule {
}
FuiTransitionModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [
                    FuiTransition
                ],
                exports: [
                    FuiTransition
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiMessage {
    constructor() {
        /** @type {?} */
        const config = new MessageConfig('');
        this.loadConfig(config);
        this.isDynamic = false;
        this.transitionOutDuration = 300;
        this.timeoutProgress = 100;
        this.transitionController = new TransitionController(false);
        this.show();
    }
    /**
     * @return {?}
     */
    get dynamicClasses() {
        /** @type {?} */
        const classes = {};
        classes[this.state] = true;
        if (this.isDynamic && this.hasProgress) {
            classes.attached = true;
        }
        (this.classes || '')
            .split(' ')
            .forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => classes[c] = true));
        return classes;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    loadConfig(config) {
        this.isDynamic = true;
        this.text = config.text;
        this.header = config.header;
        this.state = config.state;
        this.timeout = config.timeout;
        this.extendedTimeout = config.extendedTimeout;
        this.hasDismissButton = config.hasDismissButton;
        this.hasProgress = config.hasProgress;
        this.transition = config.transition;
        this.transitionInDuration = config.transitionInDuration;
        this.transitionOutDuration = config.transitionOutDuration;
        this.onClick = config.onClick;
        this.onDismiss = config.onDismiss;
    }
    /**
     * @return {?}
     */
    show() {
        this.transitionController.stopAll();
        this.transitionController.animate(new Transition(this.transition, this.isDynamic ? this.transitionInDuration : 0, TransitionDirection.In, (/**
         * @return {?}
         */
        () => {
            if (this.isDynamic) {
                this.beginTimer(this.timeout);
            }
        })));
    }
    /**
     * @return {?}
     */
    dismiss() {
        this.isDismissing = true;
        this.transitionOutDuration = this.transitionInDuration;
        this.hide();
    }
    /**
     * @return {?}
     */
    hide() {
        this.isClosing = true;
        this.transitionController.stopAll();
        this.transitionController.animate(new Transition(this.transition, this.transitionOutDuration, TransitionDirection.Out, (/**
         * @return {?}
         */
        () => {
            this.isClosing = false;
            this.onDismiss.emit();
        })));
    }
    /**
     * @param {?} timeout
     * @return {?}
     */
    beginTimer(timeout) {
        if (this.isDynamic && !this.isDismissing) {
            this.timeoutProgress = 0;
            this.currentTimeout = timeout;
            this._displayTimeout = window.setTimeout((/**
             * @return {?}
             */
            () => this.onTimedOut()), timeout);
        }
    }
    /**
     * @return {?}
     */
    cancelTimer() {
        if (this.isDynamic && !this.isDismissing) {
            this.timeoutProgress = 100;
            this.currentTimeout = 0;
            clearTimeout(this._displayTimeout);
            if (this.isClosing) {
                this.isClosing = false;
                this.transitionController.cancel();
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClicked(e) {
        if (!e.eventHandled) {
            this.cancelTimer();
            this.onClick.emit();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onDismissClicked(e) {
        e.eventHandled = true;
        this.dismiss();
    }
    /**
     * @private
     * @return {?}
     */
    onTimedOut() {
        this.hide();
    }
}
FuiMessage.decorators = [
    { type: Component, args: [{
                selector: 'fui-message',
                template: `
<div [fuiTransition]="transitionController">
    <div class="ui message"
         [ngClass]="dynamicClasses"
         (mousemove)="cancelTimer()"
         (mouseleave)="beginTimer(extendedTimeout)"
         (click)="onClicked($event)">
        <i class="close icon" *ngIf="hasDismissButton" (click)="onDismissClicked($event)"></i>
        <ng-content></ng-content>
        <ng-container *ngIf="isDynamic">
            <div class="header" *ngIf="header">{{ header }}</div>
            <p>{{ text }}</p>
        </ng-container>
    </div>
    <fui-progress *ngIf="isDynamic && hasProgress"
                  class="bottom attached"
                  [value]="timeoutProgress"
                  [autoSuccess]="false"
                  transition="linear"
                  [transitionDuration]="currentTimeout"
                  [canCompletelyEmpty]="true"></fui-progress>
</div>
`
            }] }
];
/** @nocollapse */
FuiMessage.ctorParameters = () => [];
FuiMessage.propDecorators = {
    hasDismissButton: [{ type: Input }],
    transition: [{ type: Input }],
    transitionOutDuration: [{ type: Input, args: ['transitionDuration',] }],
    onClick: [{ type: Output, args: ['click',] }],
    onDismiss: [{ type: Output, args: ['dismiss',] }],
    classes: [{ type: Input, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class CustomValidator {
    /**
     * @param {?} _host
     */
    constructor(_host) {
        this._host = _host;
        this.onValidatorChange = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this._host.validate(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
}
/**
 * @param {?} type
 * @return {?}
 */
function customValidatorFactory(type) {
    return {
        provide: NG_VALIDATORS,
        useExisting: forwardRef((/**
         * @return {?}
         */
        () => type)),
        multi: true
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template U, T
 */
class CustomValueAccessor {
    /**
     * @param {?} _host
     */
    constructor(_host) {
        this._host = _host;
        this.onChange = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
        });
        this.onTouched = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._host.writeValue(value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
/**
 * @param {?} type
 * @return {?}
 */
function customValueAccessorFactory(type) {
    return {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef((/**
         * @return {?}
         */
        () => type)),
        multi: true
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const KeyCode = {
    Left: 37,
    Up: 38,
    Right: 39,
    Down: 40,
    Escape: 27,
    Enter: 13,
    Space: 32,
    Backspace: 8,
};
KeyCode[KeyCode.Left] = 'Left';
KeyCode[KeyCode.Up] = 'Up';
KeyCode[KeyCode.Right] = 'Right';
KeyCode[KeyCode.Down] = 'Down';
KeyCode[KeyCode.Escape] = 'Escape';
KeyCode[KeyCode.Enter] = 'Enter';
KeyCode[KeyCode.Space] = 'Space';
KeyCode[KeyCode.Backspace] = 'Backspace';
/** @type {?} */
const Util = {
    Array: {
        /**
         * @param {?} n
         * @param {?=} offset
         * @return {?}
         */
        range(n, offset = 0) {
            return Array(n).fill(0).map((/**
             * @param {?} z
             * @param {?} i
             * @return {?}
             */
            (z, i) => i + offset));
        },
        /**
         * @template T
         * @param {?} items
         * @param {?} groupLength
         * @return {?}
         */
        group(items, groupLength) {
            /** @type {?} */
            const mutable = items.slice(0);
            /** @type {?} */
            const groups = [];
            while (mutable.length > 0) {
                groups.push(mutable.splice(0, groupLength));
            }
            return groups;
        },
        /**
         * @template T
         * @param {?} items
         * @param {?} field
         * @return {?}
         */
        groupBy(items, field) {
            return items.reduce((/**
             * @param {?} groups
             * @param {?} i
             * @return {?}
             */
            (groups, i) => {
                /** @type {?} */
                const fieldValue = i[field].toString();
                groups[fieldValue] = groups[fieldValue] || [];
                groups[fieldValue].push(i);
                return groups;
            }), Object());
        },
        /**
         * @template T
         * @param {?} items
         * @return {?}
         */
        flatten(items) {
            return items.reduce((/**
             * @param {?} is
             * @param {?} i
             * @return {?}
             */
            (is, i) => is.concat(i)), []);
        }
    },
    String: {
        /**
         * @param {?} str
         * @param {?} length
         * @param {?} padding
         * @return {?}
         */
        padLeft(str, length, padding) {
            /** @type {?} */
            let s = str;
            while (s.length < length) {
                s = padding + s;
            }
            return s;
        }
    },
    DOM: {
        /**
         * @param {?} attributeValue
         * @return {?}
         */
        parseBooleanAttribute(attributeValue) {
            /** @type {?} */
            let value = attributeValue;
            if (typeof attributeValue === 'string') {
                value = true;
            }
            return value;
        },
        /**
         * @return {?}
         */
        getDocumentFontSize() {
            return parseFloat(window
                .getComputedStyle(document.documentElement, undefined)
                .getPropertyValue('font-size'));
        }
    },
    Object: {
        /**
         * @template T, U
         * @param {?} object
         * @param {?=} path
         * @return {?}
         */
        readValue(object, path) {
            if (!path) {
                return (/** @type {?} */ ((/** @type {?} */ (object))));
            }
            /** @type {?} */
            let recursed = (/** @type {?} */ ((/** @type {?} */ (object))));
            for (let i = 0, p = path.split('.'), len = p.length; i < len; i++) {
                recursed = ((/** @type {?} */ ((/** @type {?} */ (recursed)))))[p[i]];
            }
            return (/** @type {?} */ ((/** @type {?} */ (recursed))));
        }
    },
    Math: {
        /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        round(r, n) {
            return Math.round(r / n) * n;
        },
        /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        roundUp(r, n) {
            return Math.ceil(r / n) * n;
        },
        /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        roundDown(r, n) {
            return Math.floor(r / n) * n;
        },
        /**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        mod(r, n) {
            /** @type {?} */
            const rem = r % n;
            if (rem < 0) {
                return rem + n;
            }
            return rem;
        }
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const DatePrecision = {
    Decade: 0,
    Year: 1,
    Month: 2,
    Date: 3,
    Hour: 4,
    Minute: 5,
};
DatePrecision[DatePrecision.Decade] = 'Decade';
DatePrecision[DatePrecision.Year] = 'Year';
DatePrecision[DatePrecision.Month] = 'Month';
DatePrecision[DatePrecision.Date] = 'Date';
DatePrecision[DatePrecision.Hour] = 'Hour';
DatePrecision[DatePrecision.Minute] = 'Minute';
/** @type {?} */
const DateUtil = {
    /**
     * @param {?} precision
     * @param {?} date
     * @param {?=} resetAll
     * @return {?}
     */
    startOf(precision, date, resetAll = false) {
        switch (precision) {
            case DatePrecision.Decade:
                /** @type {?} */
                const start = Math.floor(date.getFullYear() / 10) * 10 + 1;
                date.setFullYear(start);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Year:
                date.setMonth(0);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Month:
                date.setDate(1);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Date:
                date.setHours(0);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Hour:
                date.setMinutes(0);
                if (!resetAll) {
                    break;
                }
            // falls through
            case DatePrecision.Minute:
                date.setSeconds(0, 0);
        }
        return date;
    },
    /**
     * @param {?} precision
     * @param {?} date
     * @return {?}
     */
    endOf(precision, date) {
        switch (precision) {
            case DatePrecision.Year:
                date.setMonth(12, 0);
            // falls through
            case DatePrecision.Month:
                date.setMonth(date.getMonth() + 1, 0);
            // falls through
            case DatePrecision.Date:
                date.setHours(23, 59, 59, 999);
                break;
            case DatePrecision.Hour:
                date.setMinutes(59, 59, 999);
                break;
            case DatePrecision.Minute:
                date.setSeconds(59, 999);
                break;
        }
        return date;
    },
    /**
     * @param {?} precision
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    equal(precision, a, b) {
        /** @type {?} */
        let equal = true;
        switch (precision) {
            case DatePrecision.Minute:
                equal = equal && a.getMinutes() === b.getMinutes();
            // falls through
            case DatePrecision.Hour:
                equal = equal && a.getHours() === b.getHours();
            // falls through
            case DatePrecision.Date:
                equal = equal && a.getDate() === b.getDate();
            // falls through
            case DatePrecision.Month:
                equal = equal && a.getMonth() === b.getMonth();
            // falls through
            case DatePrecision.Year:
                equal = equal && a.getFullYear() === b.getFullYear();
        }
        return equal;
    },
    /**
     * @param {?} precision
     * @param {?} date
     * @return {?}
     */
    next(precision, date) {
        return DateUtil.add(precision, date, 1);
    },
    /**
     * @param {?} precision
     * @param {?} date
     * @param {?} i
     * @return {?}
     */
    add(precision, date, i) {
        /** @type {?} */
        const year = date.getFullYear();
        /** @type {?} */
        const month = date.getMonth();
        /** @type {?} */
        const day = date.getDate();
        switch (precision) {
            case DatePrecision.Decade:
                date.setFullYear(year + i * 10);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Year:
                date.setFullYear(year + i);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Month:
                date.setMonth(month + i);
                if (date.getMonth() !== Util.Math.mod(month + i, 12)) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Date:
                date.setDate(day + i);
                break;
            case DatePrecision.Hour:
                date.setHours(date.getHours() + i);
                break;
            case DatePrecision.Minute:
                date.setMinutes(date.getMinutes() + i);
                break;
        }
        return date;
    },
    /**
     * @param {?} precision
     * @param {?} date
     * @return {?}
     */
    previous(precision, date) {
        /** @type {?} */
        const year = date.getFullYear();
        /** @type {?} */
        const month = date.getMonth();
        /** @type {?} */
        const day = date.getDate();
        switch (precision) {
            case DatePrecision.Decade:
                date.setFullYear(year - 10);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Year:
                date.setFullYear(year - 1);
                if (date.getMonth() !== month) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Month:
                date.setMonth(month - 1);
                if (date.getMonth() !== Util.Math.mod(month - 1, 12)) {
                    date.setDate(0);
                }
                break;
            case DatePrecision.Date:
                date.setDate(day - 1);
                break;
            case DatePrecision.Hour:
                /** @type {?} */
                const hours = date.getHours();
                date.setHours(hours - 1);
                if (date.getHours() !== Util.Math.mod(hours - 1, 24)) {
                    date.setHours(hours - 2);
                }
                break;
            case DatePrecision.Minute:
                /** @type {?} */
                const minutes = date.getMinutes();
                date.setMinutes(minutes - 1);
        }
        return date;
    },
    /**
     * @param {?} date
     * @return {?}
     */
    clone(date) {
        return new Date(date.getTime());
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiComponentFactory {
    /**
     * @param {?} _applicationRef
     * @param {?} _componentFactoryResolver
     * @param {?} _injector
     */
    constructor(_applicationRef, _componentFactoryResolver, _injector) {
        this._applicationRef = _applicationRef;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._injector = _injector;
    }
    /**
     * @template T
     * @param {?} type
     * @param {?=} providers
     * @return {?}
     */
    createComponent(type, providers = []) {
        // Resolve a factory for creating components of type `type`.
        /** @type {?} */
        const factory = this._componentFactoryResolver.resolveComponentFactory((/** @type {?} */ (type)));
        // Resolve and create an injector with the specified providers.
        /** @type {?} */
        const injector = ReflectiveInjector.resolveAndCreate(providers, this._injector);
        // Create a component using the previously resolved factory & injector.
        /** @type {?} */
        const componentRef = factory.create(injector);
        return componentRef;
    }
    /**
     * @template T, U
     * @param {?} viewContainer
     * @param {?} template
     * @param {?} context
     * @return {?}
     */
    createView(viewContainer, template, context) {
        viewContainer.createEmbeddedView(template, context);
    }
    // Inserts the component into the specified view container.
    /**
     * @template T
     * @param {?} componentRef
     * @param {?} viewContainer
     * @return {?}
     */
    attachToView(componentRef, viewContainer) {
        viewContainer.insert(componentRef.hostView, 0);
    }
    // Inserts the component in the root application node.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    attachToApplication(componentRef) {
        this._applicationRef.attachView(componentRef.hostView);
    }
    // Detaches the component from the root application node.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    detachFromApplication(componentRef) {
        this._applicationRef.detachView(componentRef.hostView);
    }
    // Moves the component to the specified DOM element.
    /**
     * @template T
     * @param {?} componentRef
     * @param {?} element
     * @return {?}
     */
    moveToElement(componentRef, element) {
        element.appendChild(componentRef.location.nativeElement);
    }
    // Moves the component to the document body.
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    moveToDocumentBody(componentRef) {
        this.moveToElement(componentRef, (/** @type {?} */ (document.querySelector('body'))));
    }
    /**
     * @template T
     * @param {?} componentRef
     * @return {?}
     */
    detachFromDocument(componentRef) {
        /** @type {?} */
        const element = (/** @type {?} */ (componentRef.location.nativeElement));
        // We can't use `element.remove()` due to lack of IE11 support.
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
    }
}
FuiComponentFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FuiComponentFactory.ctorParameters = () => [
    { type: ApplicationRef },
    { type: ComponentFactoryResolver },
    { type: Injector }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PositioningPlacement = {
    Auto: (/** @type {?} */ ('auto')),
    TopLeft: (/** @type {?} */ ('top left')),
    Top: (/** @type {?} */ ('top')),
    TopRight: (/** @type {?} */ ('top right')),
    LeftTop: (/** @type {?} */ ('left top')),
    Left: (/** @type {?} */ ('left')),
    LeftBottom: (/** @type {?} */ ('left bottom')),
    BottomLeft: (/** @type {?} */ ('bottom left')),
    Bottom: (/** @type {?} */ ('bottom')),
    BottomRight: (/** @type {?} */ ('bottom right')),
    RightTop: (/** @type {?} */ ('right top')),
    Right: (/** @type {?} */ ('right')),
    RightBottom: (/** @type {?} */ ('right bottom'))
};
/**
 * @param {?} placement
 * @return {?}
 */
function placementToPopper(placement) {
    if (!placement || placement === PositioningPlacement.Auto) {
        return 'auto';
    }
    // All placements of the format: `direction alignment`, e.g. `top left`.
    const [direction, alignment] = placement.split(' ');
    // Direction alone covers case of just `top`, `left`, `bottom`, `right`.
    /** @type {?} */
    const chosenPlacement = [direction];
    // Add `start` / `end` to placement, depending on alignment direction.
    switch (alignment) {
        case 'top':
        case 'left':
            chosenPlacement.push('start');
            break;
        case 'bottom':
        case 'right':
            chosenPlacement.push('end');
            break;
    }
    // Join with hyphen to create Popper compatible placement.
    return (/** @type {?} */ (chosenPlacement.join('-')));
}
/**
 * @param {?} popper
 * @return {?}
 */
function popperToPlacement(popper) {
    if (!popper || popper === 'auto') {
        return 'auto';
    }
    const [direction, alignment] = popper.split('-');
    /** @type {?} */
    const chosenPlacement = [direction];
    switch (direction) {
        case 'top':
        case 'bottom':
            switch (alignment) {
                case 'start':
                    chosenPlacement.push('left');
                    break;
                case 'end':
                    chosenPlacement.push('right');
                    break;
            }
            break;
        case 'left':
        case 'right':
            switch (alignment) {
                case 'start':
                    chosenPlacement.push('top');
                    break;
                case 'end':
                    chosenPlacement.push('bottom');
                    break;
            }
            break;
    }
    return (/** @type {?} */ (chosenPlacement.join(' ')));
}
class PositioningService {
    /**
     * @param {?} anchor
     * @param {?} subject
     * @param {?} placement
     * @param {?=} arrowSelector
     */
    constructor(anchor, subject, placement, arrowSelector) {
        this.anchor = anchor;
        this.subject = subject;
        this._placement = placement;
        this._arrowSelector = arrowSelector;
        this.init();
    }
    /**
     * @return {?}
     */
    get actualPlacement() {
        if (!this._popperState) {
            return PositioningPlacement.Auto;
        }
        return popperToPlacement(this._popperState.placement);
    }
    /**
     * @return {?}
     */
    get state() {
        return this._popperState;
    }
    /**
     * @return {?}
     */
    get placement() {
        return this._placement;
    }
    /**
     * @param {?} placement
     * @return {?}
     */
    set placement(placement) {
        this._placement = placement;
        if (this._popper) {
            this._popper.options.placement = placementToPopper(placement);
        }
    }
    /**
     * @param {?} hasArrow
     * @return {?}
     */
    set hasArrow(hasArrow) {
        this._hasArrow = hasArrow;
    }
    /**
     * @return {?}
     */
    init() {
        /** @type {?} */
        const modifiers = {
            computeStyle: {
                gpuAcceleration: false
            },
            preventOverflow: {
                escapeWithReference: true,
                boundariesElement: document.body
            },
            arrow: {
                element: this._arrowSelector
            },
            offset: {
                fn: (/**
                 * @param {?} data
                 * @return {?}
                 */
                (data) => {
                    if (this._hasArrow) {
                        /** @type {?} */
                        const offsets = this.calculateOffsets();
                        data.offsets.popper.left += offsets.left;
                        data.offsets.popper.top += offsets.top;
                    }
                    return data;
                })
            }
        };
        if (!this._arrowSelector) {
            delete modifiers.arrow;
        }
        this._popper = (/** @type {?} */ (new Popper(this.anchor.nativeElement, this.subject.nativeElement, {
            placement: placementToPopper(this._placement),
            modifiers,
            onCreate: (/**
             * @param {?} initial
             * @return {?}
             */
            initial => this._popperState = initial),
            onUpdate: (/**
             * @param {?} update
             * @return {?}
             */
            update => this._popperState = update)
        })));
    }
    /**
     * @return {?}
     */
    update() {
        this._popper.update();
    }
    /**
     * @return {?}
     */
    destroy() {
        this._popper.destroy();
    }
    /**
     * @private
     * @return {?}
     */
    calculateOffsets() {
        /** @type {?} */
        let left = 0;
        /** @type {?} */
        let top = 0;
        // To support correct positioning for all popup sizes we should calculate offset using em
        /** @type {?} */
        const fontSize = parseFloat(window.getComputedStyle(this.subject.nativeElement).getPropertyValue('font-size'));
        // The Fomantic UI popup arrow width and height are 0.71428571em and the margin from the popup edge is 1em
        /** @type {?} */
        const arrowCenter = (0.71428571 / 2 + 1) * fontSize;
        if (this.anchor.nativeElement.offsetWidth <= arrowCenter * 2) {
            /** @type {?} */
            const anchorCenterWidth = this.anchor.nativeElement.offsetWidth / 2;
            if (this._placement === PositioningPlacement.TopLeft || this._placement === PositioningPlacement.BottomLeft) {
                left = anchorCenterWidth - arrowCenter;
            }
            if (this._placement === PositioningPlacement.TopRight || this._placement === PositioningPlacement.BottomRight) {
                left = arrowCenter - anchorCenterWidth;
            }
        }
        if (this.anchor.nativeElement.offsetHeight <= arrowCenter * 2) {
            /** @type {?} */
            const anchorCenterHeight = this.anchor.nativeElement.offsetHeight / 2;
            if (this._placement === PositioningPlacement.LeftTop || this._placement === PositioningPlacement.RightTop) {
                top = anchorCenterHeight - arrowCenter;
            }
            if (this._placement === PositioningPlacement.LeftBottom || this._placement === PositioningPlacement.RightBottom) {
                top = arrowCenter - anchorCenterHeight;
            }
        }
        return { top, left, width: 0, height: 0 };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiUtilityModule {
}
FuiUtilityModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                providers: [
                    FuiComponentFactory
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiMessageContainer {
    /**
     * @param {?} _componentFactory
     * @param {?} _element
     */
    constructor(_componentFactory, _element) {
        this._componentFactory = _componentFactory;
        this._element = _element;
        this._messages = [];
        this._queue = [];
    }
    /**
     * @param {?} controller
     * @return {?}
     */
    set controller(controller) {
        controller.registerContainer(this);
    }
    /**
     * @param {?} config
     * @param {?} maxShown
     * @param {?} showNewestFirst
     * @return {?}
     */
    show(config, maxShown, showNewestFirst) {
        /** @type {?} */
        const componentRef = this._componentFactory.createComponent(FuiMessage);
        componentRef.instance.loadConfig(config);
        /** @type {?} */
        const active = new ActiveMessage(config, componentRef)
            .onDismiss((/**
         * @return {?}
         */
        () => this.onMessageClose(active, showNewestFirst)));
        if (this._messages.length < maxShown) {
            this.open(active, showNewestFirst);
        }
        else {
            this.queue(active);
        }
        return active;
    }
    /**
     * @return {?}
     */
    dismissAll() {
        this._queue = [];
        this._messages.forEach((/**
         * @param {?} m
         * @return {?}
         */
        m => m.dismiss()));
    }
    /**
     * @private
     * @param {?} message
     * @param {?} showNewestFirst
     * @return {?}
     */
    open(message, showNewestFirst) {
        this._messages.push(message);
        this._componentFactory.attachToView(message.componentRef, this.containerSibling);
        if (!showNewestFirst) {
            this._componentFactory.moveToElement(message.componentRef, this._element.nativeElement);
        }
        message.component.show();
    }
    /**
     * @private
     * @param {?} message
     * @return {?}
     */
    queue(message) {
        this._queue.push(message);
    }
    /**
     * @private
     * @param {?} message
     * @param {?} showNewestFirst
     * @return {?}
     */
    onMessageClose(message, showNewestFirst) {
        this._messages = this._messages.filter((/**
         * @param {?} m
         * @return {?}
         */
        m => m !== message));
        if (this._queue.length > 0) {
            const [queued] = this._queue.slice(0, 1);
            this.open(queued, showNewestFirst);
        }
    }
}
FuiMessageContainer.decorators = [
    { type: Component, args: [{
                selector: 'fui-message-container',
                template: `
<div #containerSibling></div>
`,
                styles: [`
:host {
    display: block;
}
:host >>> fui-message {
    display: block;
    margin-bottom: 1rem;
}
:host >>> fui-message:last-of-type {
    margin-bottom: 0;
}
:host >>> fui-message {
    cursor: pointer;
}
`]
            }] }
];
/** @nocollapse */
FuiMessageContainer.ctorParameters = () => [
    { type: FuiComponentFactory },
    { type: ElementRef }
];
FuiMessageContainer.propDecorators = {
    containerSibling: [{ type: ViewChild, args: ['containerSibling', { read: ViewContainerRef, static: false },] }],
    controller: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MessagePosition = {
    Top: (/** @type {?} */ ('top')),
    TopLeft: (/** @type {?} */ ('top-left')),
    TopRight: (/** @type {?} */ ('top-right')),
    Bottom: (/** @type {?} */ ('bottom')),
    BottomLeft: (/** @type {?} */ ('bottom-left')),
    BottomRight: (/** @type {?} */ ('bottom-right'))
};
class FuiMessageGlobalContainer {
    /**
     * @return {?}
     */
    get dynamicClasses() {
        /** @type {?} */
        const classes = {};
        this.position
            .split('-')
            .forEach((/**
         * @param {?} p
         * @return {?}
         */
        p => classes[p] = true));
        return classes;
    }
    /**
     * @return {?}
     */
    get dynamicWidth() {
        /** @type {?} */
        const margin = Util.DOM.getDocumentFontSize();
        /** @type {?} */
        let width = this.width;
        if (this.position === MessagePosition.Top ||
            this.position === MessagePosition.Bottom ||
            window.innerWidth < width + margin * 2) {
            width = window.innerWidth - margin * 2;
        }
        return width;
    }
    /**
     * @return {?}
     */
    onDocumentResize() {
    }
}
FuiMessageGlobalContainer.decorators = [
    { type: Component, args: [{
                selector: 'fui-message-global-container',
                template: `
<div class="global container" [ngClass]="dynamicClasses" [style.width.px]="dynamicWidth">
    <fui-message-container [controller]="controller"></fui-message-container>
</div>
`,
                styles: [`
.global.container {
    display: block;
    position: fixed;
}
.global.container.top {
    top: 1rem;
}
.global.container.bottom {
    bottom: 1rem;
}
.global.container.left {
    left: 1rem;
}
.global.container.right {
    right: 1rem;
}
.global.container:not(.left):not(.right) {
    left: 1rem;
}
`]
            }] }
];
FuiMessageGlobalContainer.propDecorators = {
    onDocumentResize: [{ type: HostListener, args: ['window:resize',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiMessageService {
    /**
     * @param {?} _componentFactory
     */
    constructor(_componentFactory) {
        this._componentFactory = _componentFactory;
        this._controller = new MessageController();
        this._containerRef = this._componentFactory.createComponent(FuiMessageGlobalContainer);
        this._container.controller = this._controller;
        this._componentFactory.attachToApplication(this._containerRef);
        this._componentFactory.moveToDocumentBody(this._containerRef);
        this.position = MessagePosition.TopRight;
        this.width = 480;
    }
    /**
     * @return {?}
     */
    get position() {
        return this._container.position;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    set position(position) {
        this._container.position = position;
    }
    /**
     * @return {?}
     */
    get width() {
        return this._container.width;
    }
    /**
     * @param {?} width
     * @return {?}
     */
    set width(width) {
        this._container.width = width;
    }
    /**
     * @return {?}
     */
    get maxShown() {
        return this._controller.maxShown;
    }
    /**
     * @param {?} max
     * @return {?}
     */
    set maxShown(max) {
        this._controller.maxShown = max;
    }
    /**
     * @return {?}
     */
    get isNewestOnTop() {
        return this._controller.isNewestOnTop;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isNewestOnTop(value) {
        this._controller.isNewestOnTop = value;
    }
    /**
     * @private
     * @return {?}
     */
    get _container() {
        return this._containerRef.instance;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    show(config) {
        return this._controller.show(config);
    }
    /**
     * @return {?}
     */
    dismissAll() {
        return this._controller.dismissAll();
    }
}
FuiMessageService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FuiMessageService.ctorParameters = () => [
    { type: FuiComponentFactory }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiProgress {
    constructor() {
        this.value = 0;
        this.maximum = 100;
        this.precision = 0;
        this._overrideSuccess = false;
        this.autoSuccess = true;
        this.showProgress = true;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get reachedMaximum() {
        return this._overrideSuccess || ((this.value >= this.maximum) && this.autoSuccess);
    }
    /**
     * @return {?}
     */
    get percentage() {
        /** @type {?} */
        const boundedValue = Math.min(Math.max(this.value, 0), this.maximum);
        /** @type {?} */
        const percentage = (boundedValue / this.maximum) * 100;
        return percentage.toFixed(this.precision);
    }
    /**
     * @param {?} classes
     * @return {?}
     */
    set classValue(classes) {
        if (classes.includes('attached') || classes.includes('tiny')) {
            this.showProgress = false;
        }
        if (classes.includes('success')) {
            this._overrideSuccess = true;
        }
        this.transition = 'ease';
        this.transitionDuration = 350;
        this.canCompletelyEmpty = false;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        // Convert value from string to number where necessary.
        /** @type {?} */
        const converted = +value;
        if (Number.isNaN(converted)) {
            return;
        }
        this._value = converted;
    }
    /**
     * @return {?}
     */
    get maximum() {
        return this._maximum;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maximum(value) {
        // Convert value from string to number where necessary.
        /** @type {?} */
        const converted = +value;
        if (Number.isNaN(converted)) {
            return;
        }
        this._maximum = converted;
    }
    /**
     * @return {?}
     */
    get precision() {
        return this._precision;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set precision(value) {
        // Convert value from string to number where necessary.
        /** @type {?} */
        const converted = +value;
        if (Number.isNaN(converted)) {
            return;
        }
        this._precision = Math.min(Math.max(converted, 0), 20);
    }
}
FuiProgress.decorators = [
    { type: Component, args: [{
                selector: 'fui-progress',
                template: `
<div class="bar"
    [style.width.%]="percentage"
    [style.minWidth]="canCompletelyEmpty ? 0 : null"
    [style.transitionTimingFunction]="transition"
    [style.transitionDuration.ms]="transitionDuration">
    <div class="progress" *ngIf="showProgress">{{ percentage }}%</div>
</div>
<div class="label">
    <ng-content></ng-content>
</div>
`,
                styles: [`
.bar {
    transition-duration: 300ms !important;
    z-index: 1;
}
`]
            }] }
];
/** @nocollapse */
FuiProgress.ctorParameters = () => [];
FuiProgress.propDecorators = {
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    canCompletelyEmpty: [{ type: Input }],
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.progress',] }],
    autoSuccess: [{ type: Input }],
    showProgress: [{ type: Input }],
    reachedMaximum: [{ type: HostBinding, args: ['class.success',] }],
    percentage: [{ type: HostBinding, args: ['attr.data-percent',] }],
    classValue: [{ type: Input, args: ['class',] }],
    value: [{ type: Input }],
    maximum: [{ type: Input }],
    precision: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiProgressModule {
}
FuiProgressModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiProgress
                ],
                exports: [
                    FuiProgress
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiMessageModule {
}
FuiMessageModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FuiTransitionModule,
                    FuiProgressModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiMessage,
                    FuiMessageContainer,
                    FuiMessageGlobalContainer
                ],
                exports: [
                    FuiMessage,
                    FuiMessageContainer
                ],
                providers: [
                    FuiMessageService
                ],
                entryComponents: [
                    FuiMessage,
                    FuiMessageGlobalContainer
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPagination {
    constructor() {
        this.hasClasses = true;
        this.pageChange = new EventEmitter();
        this.pageSize = 10;
        this._page = 1;
        this._pages = [];
        this.pageCount = 1;
        this.hasNavigationLinks = true;
        this.hasBoundaryLinks = false;
        this.canRotate = false;
        this.hasEllipses = true;
    }
    /**
     * @return {?}
     */
    get maxSize() {
        return this._maxSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxSize(value) {
        this._maxSize = (value != undefined) ? Math.max(value, 1) : undefined;
    }
    /**
     * @return {?}
     */
    get collectionSize() {
        return this._collectionSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set collectionSize(value) {
        this._collectionSize = Math.max(value, 0);
        this.pageCount = Math.max(1, Math.ceil(this._collectionSize / this.pageSize));
    }
    /**
     * @return {?}
     */
    get page() {
        return this._page;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        this.setPage(value);
    }
    /**
     * @return {?}
     */
    get pages() {
        return this._pages;
    }
    /**
     * @return {?}
     */
    get hasNavigationLinks() {
        /** @type {?} */
        const maxSize = this._maxSize || this.pageCount;
        return this._hasNavigationLinks || maxSize < this.pageCount;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set hasNavigationLinks(value) {
        this._hasNavigationLinks = value;
    }
    // Public methods
    /**
     * @return {?}
     */
    hasPrevious() {
        return this.page > 1;
    }
    /**
     * @return {?}
     */
    hasNext() {
        return this.page < this.pageCount;
    }
    /**
     * @param {?} newPage
     * @return {?}
     */
    setPage(newPage) {
        /** @type {?} */
        const value = (Number.isInteger(newPage)) ? Math.min(Math.max(newPage, 1), this.pageCount) : 1;
        if (value !== this._page) {
            this._page = value;
            this.pageChange.emit(this._page);
        }
    }
    // Lifecycle hooks
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.updatePages();
    }
    // Private methods
    /**
     * @private
     * @return {?}
     */
    updatePages() {
        this.pageCount = Math.max(1, Math.ceil(this._collectionSize / this.pageSize));
        const [start, end] = this.applyPagination();
        this._pages = Array(end - start)
            .fill(start + 1)
            .map((/**
         * @param {?} s
         * @param {?} i
         * @return {?}
         */
        (s, i) => s + i));
    }
    /**
     * @private
     * @return {?}
     */
    applyPagination() {
        /** @type {?} */
        const maxSize = (this.maxSize != undefined) ? Math.min(this.maxSize, this.pageCount) : this.pageCount;
        /** @type {?} */
        const page = Math.ceil(this.page / maxSize) - 1;
        /** @type {?} */
        let start = 0;
        /** @type {?} */
        let end = this.pageCount;
        if (this.canRotate) {
            /** @type {?} */
            const leftOffset = Math.floor(maxSize / 2);
            /** @type {?} */
            const rightOffset = maxSize % 2 === 0 ? leftOffset - 1 : leftOffset;
            if (this.page <= leftOffset) {
                end = maxSize;
            }
            else if (this.pageCount - this.page < leftOffset) {
                start = this.pageCount - maxSize;
            }
            else {
                start = this.page - leftOffset - 1;
                end = this.page + rightOffset;
            }
        }
        else {
            start = page * maxSize;
            end = start + maxSize;
        }
        return [start, Math.min(end, this.pageCount)];
    }
}
FuiPagination.decorators = [
    { type: Component, args: [{
                selector: 'fui-pagination',
                template: `
<a *ngIf="hasBoundaryLinks" class="item"  (click)="setPage(1)" [class.disabled]="page===1">
    <span><i class="angle double left icon"></i></span>
</a>
<a *ngIf="hasNavigationLinks" class="item" (click)="setPage(page-1)" [class.disabled]="!hasPrevious()">
    <span><i class="angle left icon"></i></span>
</a>
<ng-container *ngIf="hasEllipses">
    <a class="item" (click)="setPage(1)" *ngIf="pages[0] !== 1">
        <span>1</span>
    </a>
    <a class="disabled item" *ngIf="pages[0] > 2">...</a>
</ng-container>
<a *ngFor="let p of pages" class="item" [class.active]="p===page" (click)="setPage(p)">
    {{ p }}
</a>
<ng-container *ngIf="hasEllipses">
    <a class="disabled item" *ngIf="pages[pages.length - 1] < pageCount - 1">...</a>
    <a class="item" (click)="setPage(pageCount)" *ngIf="pages[pages.length - 1] !== pageCount">
        <span>{{ pageCount }}</span>
    </a>
</ng-container>
<a *ngIf="hasNavigationLinks" class="item" (click)="setPage(page+1)" [class.disabled]="!hasNext()">
    <span><i class="angle right icon"></i></span>
</a>
<a *ngIf="hasBoundaryLinks" class="item"  (click)="setPage(pageCount)" [class.disabled]="page===pageCount">
    <span><i class="angle double right icon"></i></span>
</a>
`,
                styles: [`
:host .item {
    transition: none;
}
`]
            }] }
];
/** @nocollapse */
FuiPagination.ctorParameters = () => [];
FuiPagination.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.pagination',] }, { type: HostBinding, args: ['class.menu',] }],
    pageChange: [{ type: Output }],
    pageSize: [{ type: Input }],
    hasBoundaryLinks: [{ type: Input }],
    canRotate: [{ type: Input }],
    hasEllipses: [{ type: Input }],
    maxSize: [{ type: Input }],
    collectionSize: [{ type: Input }],
    page: [{ type: Input }],
    hasNavigationLinks: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPaginationModule {
}
FuiPaginationModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [FuiPagination],
                declarations: [FuiPagination],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiAccordionPanel {
    /**
     * @param {?} _changeDetector
     */
    constructor(_changeDetector) {
        this._changeDetector = _changeDetector;
        this.transitionController = new TransitionController(false);
        this._isOpen = false;
        this.isOpenChange = new EventEmitter(false);
    }
    /**
     * @return {?}
     */
    get transition() {
        if (this._service) {
            return this._service.transition;
        }
        return 'fade';
    }
    /**
     * @return {?}
     */
    get transitionDuration() {
        if (this._service) {
            // Return the service defined transition duration.
            return this._service.transitionDuration;
        }
        // Revert to instantaneous if the service is not yet loaded.
        return 0;
    }
    /**
     * @param {?} service
     * @return {?}
     */
    set service(service) {
        this._service = service;
        this._changeDetector.detectChanges();
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        // Convert to boolean (fixes false != undefined)
        /** @type {?} */
        const isOpen = !!value;
        if (isOpen !== this.isOpen) {
            // Only update if the value has changed.
            this._isOpen = isOpen;
            if (isOpen && this._service) {
                // If we are opening this panel, we must close the other ones.
                this._service.closeOtherPanels(this);
            }
            this.isOpenChange.emit(this.isOpen);
            // Cancel all current animations, and fade the contents. The direction is automatic.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.transition, this.transitionDuration));
        }
    }
    /**
     * @return {?}
     */
    toggle() {
        if (!this.isDisabled) {
            this.isOpen = !this.isOpen;
        }
    }
}
FuiAccordionPanel.decorators = [
    { type: Component, args: [{
                selector: 'fui-accordion-panel',
                exportAs: 'fuiAccordionPanel',
                template: `
<!-- Title -->
<div class="title" [class.active]="isOpen" (click)="toggle()" >
    <ng-content select="[title]"></ng-content>
</div>
<!-- Content -->
<div [fuiCollapse]="!isOpen" [collapseDuration]="transitionDuration">
    <div class="content" [class.active]="isOpen" [fuiTransition]="transitionController">
        <ng-content select="[content]"></ng-content>
    </div>
</div>
`,
                styles: [`
/* Manual style as Fomantic UI relies on > selector */
.content {
    padding: .5em 0 1em;
}

/* Another > selector fix */
:host:first-child .title {
    border-top: none;
}
`]
            }] }
];
/** @nocollapse */
FuiAccordionPanel.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FuiAccordionPanel.propDecorators = {
    isDisabled: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    isOpen: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiAccordionService {
    constructor() {
        this.closeOthers = true;
        this.transition = 'fade';
        this.transitionDuration = 350;
        this.panels = [];
    }
    /**
     * @param {?} panel
     * @return {?}
     */
    addPanel(panel) {
        panel.service = this;
        this.panels.push(panel);
    }
    /**
     * @param {?} panel
     * @return {?}
     */
    closeOtherPanels(panel) {
        if (!this.closeOthers) {
            return;
        }
        this.panels.forEach((/**
         * @param {?} p
         * @return {?}
         */
        p => {
            if (p !== panel) {
                p.isOpen = false;
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiAccordion {
    constructor() {
        // Accordion service is unique to each set of panels.
        this._service = new FuiAccordionService();
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get closeOthers() {
        return this._service.closeOthers;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set closeOthers(value) {
        this._service.closeOthers = value;
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    set transition(transition) {
        this._service.transition = transition;
    }
    /**
     * @param {?} duration
     * @return {?}
     */
    set transitionDuration(duration) {
        this._service.transitionDuration = duration;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updatePanels();
        // Reconnect panels after they have updated.
        this._panels.changes.subscribe((/**
         * @return {?}
         */
        () => this.updatePanels()));
    }
    /**
     * @return {?}
     */
    updatePanels() {
        this._panels.forEach((/**
         * @param {?} p
         * @return {?}
         */
        p => this._service.addPanel(p)));
    }
}
FuiAccordion.decorators = [
    { type: Component, args: [{
                selector: 'fui-accordion',
                template: `
<ng-content></ng-content>
`,
                styles: [`
/* Fix for general styling issues */
:host {
    display: block;
}

/* Fix for styled border issue */
:host.styled fui-accordion-panel:first-child .title {
    border-top: none
}
`]
            }] }
];
/** @nocollapse */
FuiAccordion.ctorParameters = () => [];
FuiAccordion.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.accordion',] }],
    _panels: [{ type: ContentChildren, args: [FuiAccordionPanel,] }],
    closeOthers: [{ type: Input }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCollapse {
    /**
     * @param {?} _element
     * @param {?} _renderer
     */
    constructor(_element, _renderer) {
        this._element = _element;
        this._renderer = _renderer;
        this._pristine = true;
        // Collapse animation duration is 350ms by default.
        this.collapseDuration = 350;
        this._isExpanded = false;
        this._isCollapsing = false;
    }
    // Set when the collapse is closed, and not animating.
    /**
     * @return {?}
     */
    get isCollapsed() {
        return !this.isExpanded && !this.isCollapsing;
    }
    /**
     * @return {?}
     */
    get fuiCollapse() {
        return this._isExpanded;
    }
    // Sets the state of the collapse, `true` is collapsed.
    /**
     * @param {?} value
     * @return {?}
     */
    set fuiCollapse(value) {
        if (value) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    // Set when the collapse is open, and not animating.
    /**
     * @return {?}
     */
    get isExpanded() {
        return this._isExpanded;
    }
    // Set when the collapse is animating.
    /**
     * @return {?}
     */
    get isCollapsing() {
        return this._isCollapsing;
    }
    /**
     * @private
     * @return {?}
     */
    get _animationDuration() {
        return this._pristine ? 0 : this.collapseDuration;
    }
    /**
     * @return {?}
     */
    hide() {
        this._isCollapsing = true;
        this._isExpanded = false;
        // Forcibly hide the overflow so that content is not visible past the boundaries of its container.
        this._renderer.setStyle(this._element.nativeElement, 'overflow', 'hidden');
        // Animate the host element from its scroll height to 0.
        this.animate(this._element.nativeElement.scrollHeight, 0, false, (/**
         * @return {?}
         */
        () => {
            this._isCollapsing = false;
        }));
    }
    /**
     * @return {?}
     */
    show() {
        this._isCollapsing = true;
        // Animate the host element from its offset height to its scroll height.
        this.animate(this._element.nativeElement.offsetHeight, this._element.nativeElement.scrollHeight, true, (/**
         * @return {?}
         */
        () => {
            // Remove the overflow override to enable user styling once again.
            this._renderer.removeStyle(this._element.nativeElement, 'overflow');
            this._isCollapsing = false;
            this._isExpanded = true;
        }));
    }
    /**
     * @private
     * @param {?} startHeight
     * @param {?} endHeight
     * @param {?=} removeOnComplete
     * @param {?=} callback
     * @return {?}
     */
    animate(startHeight, endHeight, removeOnComplete = false, callback = (/**
     * @return {?}
     */
    () => {
    })) {
        /** @type {?} */
        const heightFrames = [
            {
                offset: 0,
                height: `${startHeight}px`
            },
            {
                offset: 1,
                height: `${endHeight}px`
            }
        ];
        if (removeOnComplete) {
            heightFrames.push({
                offset: 1,
                height: `auto`
            });
        }
        // Animate the collapse using the web animations API.
        // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
        this._element.nativeElement.animate(heightFrames, {
            delay: 0,
            // Disable animation on 1st collapse / expansion.
            duration: this._animationDuration,
            iterations: 1,
            easing: 'ease',
            fill: 'both'
        });
        if (this._pristine) {
            // Remove pristine flag when first hit.
            this._pristine = false;
        }
        setTimeout((/**
         * @return {?}
         */
        () => callback()), this.collapseDuration);
    }
}
FuiCollapse.decorators = [
    { type: Directive, args: [{
                selector: '[fuiCollapse]'
            },] }
];
/** @nocollapse */
FuiCollapse.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
FuiCollapse.propDecorators = {
    collapseDuration: [{ type: Input }],
    isCollapsed: [{ type: HostBinding, args: ['class.collapsed',] }],
    fuiCollapse: [{ type: Input }],
    isExpanded: [{ type: HostBinding, args: ['class.expanded',] }],
    isCollapsing: [{ type: HostBinding, args: ['class.collapsing',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCollapseModule {
}
FuiCollapseModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiCollapse
                ],
                exports: [
                    FuiCollapse
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiAccordionModule {
}
FuiAccordionModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FuiCollapseModule,
                    FuiTransitionModule
                ],
                declarations: [
                    FuiAccordion,
                    FuiAccordionPanel
                ],
                exports: [
                    FuiAccordion,
                    FuiAccordionPanel
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCheckbox {
    constructor() {
        this.isChecked = false;
        this.onCheckChange = new EventEmitter();
        this.onTouched = new EventEmitter();
        this.isDisabled = false;
        this.isReadonly = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get checkedAttribute() {
        return this.isChecked ? '' : undefined;
    }
    /**
     * @return {?}
     */
    get isDisabledAttribute() {
        return this.isDisabled ? 'disabled' : undefined;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseDown(e) {
        e.preventDefault();
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.isDisabled && !this.isReadonly) {
            this.toggle();
            this.focusCheckbox();
        }
    }
    /**
     * @return {?}
     */
    onFocusOut() {
        this.onTouched.emit();
    }
    /**
     * @return {?}
     */
    toggle() {
        this.isChecked = !this.isChecked;
        this.onCheckChange.emit(this.isChecked);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.isChecked = value;
    }
    /**
     * @private
     * @return {?}
     */
    focusCheckbox() {
        this._checkboxElement.nativeElement.focus();
    }
}
FuiCheckbox.decorators = [
    { type: Component, args: [{
                selector: 'fui-checkbox',
                exportAs: 'fuiCheckbox',
                template: `
<input class="hidden"
       type="checkbox"
       [attr.name]="name"
       [attr.checked]="checkedAttribute"
       [attr.disabled]="isDisabledAttribute"
       [(ngModel)]="isChecked"
       #checkbox>
<label>
    <ng-content></ng-content>
</label>
`
            }] }
];
/** @nocollapse */
FuiCheckbox.ctorParameters = () => [];
FuiCheckbox.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.checkbox',] }],
    name: [{ type: Input }],
    isChecked: [{ type: HostBinding, args: ['class.checked',] }],
    onCheckChange: [{ type: Output, args: ['checkChange',] }],
    onTouched: [{ type: Output, args: ['touched',] }],
    isDisabled: [{ type: Input }],
    isReadonly: [{ type: HostBinding, args: ['class.read-only',] }, { type: Input }],
    _checkboxElement: [{ type: ViewChild, args: ['checkbox', { static: false },] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout',] }]
};
class FuiCheckboxValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiCheckboxValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'fui-checkbox',
                host: {
                    '(checkChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiCheckboxValueAccessor)]
            },] }
];
/** @nocollapse */
FuiCheckboxValueAccessor.ctorParameters = () => [
    { type: FuiCheckbox }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiRadio {
    constructor() {
        this.isChecked = false;
        this.onCurrentValueChange = new EventEmitter();
        this.onTouched = new EventEmitter();
        this.isDisabled = false;
        this.isReadonly = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get checkedAttribute() {
        return this.isChecked ? '' : undefined;
    }
    /**
     * @return {?}
     */
    get isDisabledAttribute() {
        return this.isDisabled ? 'disabled' : undefined;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseDown(e) {
        e.preventDefault();
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.isDisabled && !this.isReadonly) {
            this.currentValue = this.value;
            this.onCurrentValueChange.emit(this.currentValue);
            this.update();
            this.focusRadio();
        }
    }
    /**
     * @return {?}
     */
    onFocusOut() {
        this.onTouched.emit();
    }
    /**
     * @return {?}
     */
    update() {
        this.isChecked = this.currentValue === this.value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.currentValue = value;
        this.update();
    }
    /**
     * @private
     * @return {?}
     */
    focusRadio() {
        this._radioElement.nativeElement.focus();
    }
}
FuiRadio.decorators = [
    { type: Component, args: [{
                selector: 'fui-radio-button',
                template: `
<input class="hidden"
       type="checkbox"
       [attr.name]="name"
       [attr.checked]="checkedAttribute"
       [attr.disabled]="isDisabledAttribute"
       [ngModel]="isChecked"
       (ngModel)="currentValue = value"
       #radio>
<label>
    <ng-content></ng-content>
</label>
`
            }] }
];
/** @nocollapse */
FuiRadio.ctorParameters = () => [];
FuiRadio.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.radio',] }, { type: HostBinding, args: ['class.checkbox',] }],
    name: [{ type: Input }],
    value: [{ type: Input }],
    isChecked: [{ type: HostBinding, args: ['class.checked',] }],
    onCurrentValueChange: [{ type: Output, args: ['currentValueChange',] }],
    onTouched: [{ type: Output, args: ['touched',] }],
    isDisabled: [{ type: Input }],
    isReadonly: [{ type: HostBinding, args: ['class.read-only',] }, { type: Input }],
    _radioElement: [{ type: ViewChild, args: ['radio', { static: false },] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout',] }]
};
/**
 * @template T
 */
class FuiRadioValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiRadioValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'fui-radio-button',
                host: {
                    '(currentValueChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiRadioValueAccessor)]
            },] }
];
/** @nocollapse */
FuiRadioValueAccessor.ctorParameters = () => [
    { type: FuiRadio }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiRadioManager {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.isNested = false;
        this._radioSubs = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateNesting();
        this._subManagers.changes.subscribe((/**
         * @return {?}
         */
        () => this.updateNesting()));
        this.updateRadios();
        this._renderedRadios.changes.subscribe((/**
         * @return {?}
         */
        () => this.updateRadios()));
    }
    /**
     * @private
     * @return {?}
     */
    updateNesting() {
        this._subManagers
            .filter((/**
         * @param {?} m
         * @return {?}
         */
        m => m !== this))
            .forEach((/**
         * @param {?} m
         * @return {?}
         */
        m => m.isNested = true));
    }
    /**
     * @private
     * @return {?}
     */
    updateRadios() {
        this._radioSubs.forEach((/**
         * @param {?} s
         * @return {?}
         */
        s => s.unsubscribe()));
        this._radioSubs = [];
        /** @type {?} */
        const groups = Util.Array.groupBy(this._renderedRadios.toArray(), 'name');
        Object
            .keys(groups)
            .map((/**
         * @param {?} k
         * @return {?}
         */
        k => groups[k]))
            .forEach((/**
         * @param {?} g
         * @return {?}
         */
        g => g
            .forEach((/**
         * @param {?} r
         * @return {?}
         */
        r => this._radioSubs
            .push(r.onCurrentValueChange
            .subscribe((/**
         * @param {?} v
         * @return {?}
         */
        (v) => {
            if (!this.isNested) {
                g.forEach((/**
                 * @param {?} radio
                 * @return {?}
                 */
                radio => radio.writeValue(v)));
            }
        })))))));
    }
}
FuiRadioManager.decorators = [
    { type: Directive, args: [{
                selector: 'form:not([ngForm]):not([[ngForm]]),ngForm,[ngForm]'
            },] }
];
/** @nocollapse */
FuiRadioManager.ctorParameters = () => [
    { type: ElementRef }
];
FuiRadioManager.propDecorators = {
    _subManagers: [{ type: ContentChildren, args: [FuiRadioManager, { descendants: true },] }],
    _renderedRadios: [{ type: ContentChildren, args: [FuiRadio, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCheckboxModule {
}
FuiCheckboxModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule
                ],
                declarations: [
                    FuiCheckbox,
                    FuiCheckboxValueAccessor,
                    FuiRadio,
                    FuiRadioValueAccessor,
                    FuiRadioManager
                ],
                exports: [
                    FuiCheckbox,
                    FuiCheckboxValueAccessor,
                    FuiRadio,
                    FuiRadioValueAccessor,
                    FuiRadioManager
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const CalendarMode = {
    DateOnly: 0,
    TimeOnly: 1,
    Both: 2,
};
CalendarMode[CalendarMode.DateOnly] = 'DateOnly';
CalendarMode[CalendarMode.TimeOnly] = 'TimeOnly';
CalendarMode[CalendarMode.Both] = 'Both';
class CalendarService {
    /**
     * @param {?} config
     * @param {?} localeValues
     */
    constructor(config, localeValues) {
        this.localeValues = localeValues;
        this.onManualUpdate = (/**
         * @return {?}
         */
        () => {
        });
        this.config = config;
        this.currentDate = new Date();
        this.firstDayOfWeek = this.localeValues.firstDayOfWeek;
        this.onDateChange = new EventEmitter();
        this.reset();
    }
    /**
     * @return {?}
     */
    get inFinalView() {
        return this.currentView === this.config.mappings.finalView;
    }
    /**
     * @return {?}
     */
    get config() {
        return this._config;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    set config(config) {
        this._config = config;
        config.updateBounds(this._selectedDate || this.currentDate);
    }
    /**
     * @return {?}
     */
    get selectedDate() {
        return this._selectedDate;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    set selectedDate(date) {
        if (date) {
            this._selectedDate = DateUtil.clone(date);
            this.currentDate = DateUtil.clone(date);
        }
        else {
            this._selectedDate = undefined;
        }
        this.config.updateBounds(this._selectedDate || this.currentDate);
        this.onManualUpdate();
    }
    /**
     * @return {?}
     */
    get minDate() {
        if (this._minDate && this.config.dateMinBound) {
            return this._minDate > this.config.dateMinBound ? this._minDate : this.config.dateMinBound;
        }
        return this._minDate || this.config.dateMinBound;
    }
    /**
     * @param {?} min
     * @return {?}
     */
    set minDate(min) {
        this._minDate = min;
    }
    /**
     * @return {?}
     */
    get maxDate() {
        if (this._maxDate && this.config.dateMaxBound) {
            return this._maxDate < this.config.dateMaxBound ? this._maxDate : this.config.dateMaxBound;
        }
        return this._maxDate || this.config.dateMaxBound;
    }
    /**
     * @param {?} max
     * @return {?}
     */
    set maxDate(max) {
        this._maxDate = max;
    }
    /**
     * @return {?}
     */
    get firstDayOfWeek() {
        return this._firstDayOfWeek;
    }
    /**
     * @param {?} firstDayOfWeek
     * @return {?}
     */
    set firstDayOfWeek(firstDayOfWeek) {
        if (firstDayOfWeek != undefined) {
            this._firstDayOfWeek = Math.max(0, Math.min(6, firstDayOfWeek));
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.currentView = this.config.mappings.finalView;
        if (!this._selectedDate) {
            /** @type {?} */
            let current = this.currentDate.getTime();
            if (this._minDate) {
                current = Math.max(current, this._minDate.getTime());
            }
            if (this._maxDate) {
                current = Math.min(current, this._maxDate.getTime());
            }
            this.currentDate = new Date(current);
            this.config.updateBounds(this.currentDate);
            this.currentView = this.config.mappings.initialView;
        }
    }
    /**
     * @param {?} date
     * @param {?} fromView
     * @return {?}
     */
    changeDate(date, fromView) {
        this.currentDate = date;
        if (fromView === this.config.mappings.finalView) {
            this.selectedDate = date;
            return this.onDateChange.emit(date);
        }
        this.updateView(this.config.mappings.changed, fromView);
    }
    /**
     * @param {?} fromView
     * @return {?}
     */
    zoomOut(fromView) {
        this.updateView(this.config.mappings.zoom, fromView);
    }
    /**
     * @private
     * @param {?} mappings
     * @param {?} fromView
     * @return {?}
     */
    updateView(mappings, fromView) {
        /** @type {?} */
        const mapping = mappings.get(fromView);
        if (mapping == undefined) {
            throw new Error('Unknown view type.');
        }
        this.currentView = mapping;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarItem {
    /**
     * @param {?} date
     */
    constructor(date) {
        this.date = date;
    }
}
class FuiCalendarItem {
    /**
     * @param {?} changeDetector
     */
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.hasFocus = false;
        this.onFocussed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get isSelectable() {
        return this.item.isSelectable;
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this.item.isActive;
    }
    /**
     * @return {?}
     */
    get isToday() {
        return this.item.isToday;
    }
    /**
     * @return {?}
     */
    onMouseMove() {
        if (!this.hasFocus) {
            this.hasFocus = true;
            this.onFocussed.emit(this.hasFocus);
        }
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        this.hasFocus = false;
        this.onFocussed.emit(this.hasFocus);
    }
}
FuiCalendarItem.decorators = [
    { type: Directive, args: [{
                selector: '[calendarItem]'
            },] }
];
/** @nocollapse */
FuiCalendarItem.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FuiCalendarItem.propDecorators = {
    item: [{ type: Input, args: ['calendarItem',] }],
    hasFocus: [{ type: HostBinding, args: ['class.focus',] }],
    isSelectable: [{ type: HostBinding, args: ['class.disabled',] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    isToday: [{ type: HostBinding, args: ['class.today',] }],
    onMouseMove: [{ type: HostListener, args: ['mousemove',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const CalendarViewType = {
    Year: 0,
    Month: 1,
    Date: 2,
    Hour: 3,
    Minute: 4,
};
CalendarViewType[CalendarViewType.Year] = 'Year';
CalendarViewType[CalendarViewType.Month] = 'Month';
CalendarViewType[CalendarViewType.Date] = 'Date';
CalendarViewType[CalendarViewType.Hour] = 'Hour';
CalendarViewType[CalendarViewType.Minute] = 'Minute';
/**
 * @abstract
 */
class CalendarView {
    /**
     * @param {?} renderer
     * @param {?} viewType
     * @param {?} ranges
     */
    constructor(renderer, viewType, ranges) {
        this._type = viewType;
        this.ranges = ranges;
        this._documentKeyDownListener = renderer.listen('document', 'keydown', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.onDocumentKeyDown(e)));
    }
    /**
     * @return {?}
     */
    get currentDate() {
        return this.service.currentDate;
    }
    /**
     * @return {?}
     */
    get selectedDate() {
        return this.service.selectedDate;
    }
    /**
     * @return {?}
     */
    get service() {
        return this._service;
    }
    /**
     * @param {?} service
     * @return {?}
     */
    set service(service) {
        this._service = service;
        this.ranges.loadService(service);
        this.service.onManualUpdate = (/**
         * @return {?}
         */
        () => {
            this.ranges.refresh();
            delete this._highlightedItem;
            this.autoHighlight();
        });
    }
    // Template Methods
    /**
     * @param {?} item
     * @return {?}
     */
    setDate(item) {
        this.service.changeDate(item.date, this._type);
    }
    /**
     * @return {?}
     */
    zoomOut() {
        this.service.zoomOut(this._type);
    }
    // Keyboard Control
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._renderedItems.changes.subscribe((/**
         * @return {?}
         */
        () => this.onRenderedItemsChanged()));
        this.onRenderedItemsChanged();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._documentKeyDownListener();
    }
    /**
     * @private
     * @return {?}
     */
    onRenderedItemsChanged() {
        this._renderedItems.forEach((/**
         * @param {?} i
         * @return {?}
         */
        i => i.onFocussed.subscribe((/**
         * @param {?} hasFocus
         * @return {?}
         */
        (hasFocus) => {
            if (hasFocus) {
                this.highlightItem(i.item);
            }
        }))));
        this.autoHighlight();
        this.highlightItem(this._highlightedItem);
    }
    /**
     * @private
     * @return {?}
     */
    autoHighlight() {
        /** @type {?} */
        let date = this.selectedDate && this.ranges.current.containsDate(this.selectedDate) ? this.selectedDate : this.currentDate;
        if (this._highlightedItem && this.ranges.current.containsDate(this._highlightedItem.date)) {
            date = this._highlightedItem.date;
        }
        /** @type {?} */
        const initiallyHighlighted = this.ranges.current.items.find((/**
         * @param {?} i
         * @return {?}
         */
        i => this.ranges.dateComparer.equal(i.date, date)));
        if (initiallyHighlighted && !initiallyHighlighted.isDisabled) {
            this._highlightedItem = initiallyHighlighted;
        }
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    highlightItem(item) {
        if (item) {
            this._renderedItems.forEach((/**
             * @param {?} i
             * @return {?}
             */
            i => i.hasFocus = false));
            /** @type {?} */
            const rendered = this._renderedItems.find((/**
             * @param {?} ri
             * @return {?}
             */
            ri => ri.item === item));
            if (rendered && !rendered.hasFocus) {
                rendered.hasFocus = true;
                rendered.changeDetector.detectChanges();
            }
            this._highlightedItem = item;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    onDocumentKeyDown(e) {
        if (this._highlightedItem && e.keyCode === KeyCode.Enter) {
            this.setDate(this._highlightedItem);
            return;
        }
        if (!this._highlightedItem) {
            this.autoHighlight();
        }
        /** @type {?} */
        const index = this.ranges.current.findIndex(this._highlightedItem);
        /** @type {?} */
        let isMovingForward = true;
        /** @type {?} */
        let delta = 0;
        switch (e.keyCode) {
            case KeyCode.Right:
                delta += 1;
                break;
            case KeyCode.Left:
                delta -= 1;
                isMovingForward = false;
                break;
            case KeyCode.Down:
                delta += this.ranges.columns;
                break;
            case KeyCode.Up:
                delta -= this.ranges.columns;
                isMovingForward = false;
                break;
            default:
                return;
        }
        // Stop these keypresses being captured elsewhere.
        e.preventDefault();
        /** @type {?} */
        let nextItem = this.ranges.current.items[index + delta];
        if (nextItem && nextItem.isDisabled) {
            return;
        }
        if (nextItem && !nextItem.isOutsideRange) {
            return this.highlightItem(nextItem);
        }
        if (nextItem && nextItem.isOutsideRange) {
            if (index + delta >= this.ranges.current.inRange.length) {
                isMovingForward = true;
            }
        }
        if (!nextItem) {
            /** @type {?} */
            let adjustedIndex = this.ranges.current.findIndex(this._highlightedItem);
            /** @type {?} */
            const nextItems = this.ranges.calc(isMovingForward).inRange;
            if (isMovingForward) {
                adjustedIndex -= this.ranges.current.inRange.length;
            }
            else {
                adjustedIndex += nextItems.length;
            }
            nextItem = nextItems[adjustedIndex + delta];
            if (nextItem.isDisabled) {
                return;
            }
        }
        this.ranges.move(isMovingForward);
        this._highlightedItem = this.ranges.current.find(nextItem);
    }
}
CalendarView.propDecorators = {
    _renderedItems: [{ type: ViewChildren, args: [FuiCalendarItem,] }],
    service: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CalendarMappings {
}
class DateMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Date;
        this.finalView = CalendarViewType.Date;
        this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Date],
            [CalendarViewType.Date, CalendarViewType.Date]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Date],
            [CalendarViewType.Month, CalendarViewType.Year],
            [CalendarViewType.Date, CalendarViewType.Month]
        ]);
    }
}
class TimeMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Hour;
        this.finalView = CalendarViewType.Minute;
        this.changed = new Map([
            [CalendarViewType.Hour, CalendarViewType.Minute],
            [CalendarViewType.Minute, CalendarViewType.Minute]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Hour, CalendarViewType.Minute],
            [CalendarViewType.Minute, CalendarViewType.Hour]
        ]);
    }
}
class DatetimeMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Date;
        this.finalView = CalendarViewType.Minute;
        this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Date],
            [CalendarViewType.Date, CalendarViewType.Hour],
            [CalendarViewType.Hour, CalendarViewType.Minute],
            [CalendarViewType.Minute, CalendarViewType.Minute]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Date],
            [CalendarViewType.Month, CalendarViewType.Year],
            [CalendarViewType.Date, CalendarViewType.Month],
            [CalendarViewType.Hour, CalendarViewType.Date],
            [CalendarViewType.Minute, CalendarViewType.Hour]
        ]);
    }
}
class MonthMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Month;
        this.finalView = CalendarViewType.Month;
        this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Month]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Month],
            [CalendarViewType.Month, CalendarViewType.Year]
        ]);
    }
}
class YearMappings extends CalendarMappings {
    constructor() {
        super();
        this.initialView = CalendarViewType.Year;
        this.finalView = CalendarViewType.Year;
        this.changed = new Map([
            [CalendarViewType.Year, CalendarViewType.Year]
        ]);
        this.zoom = new Map([
            [CalendarViewType.Year, CalendarViewType.Year]
        ]);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CalendarConfig {
    /**
     * @param {?} mode
     * @param {?} precision
     * @param {?} mappings
     * @param {?} fallback
     */
    constructor(mode, precision, mappings, fallback) {
        this.mode = mode;
        this.precision = precision;
        this.mappings = mappings;
        this.fallback = fallback;
    }
    /**
     * @param {?} providedDate
     * @return {?}
     */
    updateBounds(providedDate) {
        this.dateMinBound = DateUtil.startOf(DatePrecision.Year, new Date(), true);
        this.dateMinBound.setFullYear(0);
    }
}
class DateConfigBase extends CalendarConfig {
    /**
     * @param {?} precision
     * @param {?} mappings
     * @param {?} fallback
     */
    constructor(precision, mappings, fallback) {
        super(CalendarMode.DateOnly, precision, mappings, fallback);
    }
}
class YearConfig extends DateConfigBase {
    constructor() {
        super(DatePrecision.Year, new YearMappings(), 'number');
    }
}
class MonthConfig extends DateConfigBase {
    constructor() {
        super(DatePrecision.Month, new MonthMappings(), 'month');
    }
}
class DateConfig extends DateConfigBase {
    constructor() {
        super(DatePrecision.Date, new DateMappings(), 'date');
    }
}
class DatetimeConfig extends CalendarConfig {
    constructor() {
        super(CalendarMode.Both, DatePrecision.Minute, new DatetimeMappings(), 'datetime-local');
    }
}
class TimeConfig extends CalendarConfig {
    constructor() {
        super(CalendarMode.TimeOnly, DatePrecision.Minute, new TimeMappings(), 'time');
    }
    /**
     * @param {?} providedDate
     * @return {?}
     */
    updateBounds(providedDate) {
        this.dateMaxBound = DateUtil.endOf(DatePrecision.Date, DateUtil.clone(providedDate));
        this.dateMinBound = DateUtil.previous(DatePrecision.Date, DateUtil.clone(this.dateMaxBound));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateComparer {
    /**
     * @param {?} precision
     * @param {?} isSmallest
     */
    constructor(precision, isSmallest) {
        this._precision = precision;
        this._isSmallest = isSmallest;
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    equal(a, b) {
        if (this._precision === DatePrecision.Minute) {
            return !!b &&
                DateUtil.equal(DatePrecision.Hour, b, a) &&
                Util.Math.roundDown(b.getMinutes(), 5) === Util.Math.roundDown(a.getMinutes(), 5);
        }
        return !!b && DateUtil.equal(this._precision, a, b);
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    lessThan(a, b) {
        if (this._isSmallest) {
            return !b || (b >= a);
        }
        return !b || (DateUtil.endOf(this._precision, DateUtil.clone(b)) >= a);
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    greaterThan(a, b) {
        if (this._isSmallest) {
            return !b || (b <= a);
        }
        return !b || (DateUtil.startOf(this._precision, DateUtil.clone(b)) <= a);
    }
    /**
     * @param {?} date
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    between(date, left, right) {
        return this.greaterThan(date, left) && this.lessThan(date, right);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} values
 * @param {?} defaultType
 * @param {?=} indexCallback
 * @return {?}
 */
function buildLocalizeFn(values, defaultType, indexCallback) {
    return (/**
     * @param {?} dirtyIndex
     * @param {?=} __1
     * @return {?}
     */
    (dirtyIndex, { type } = { type: defaultType }) => {
        /** @type {?} */
        const index = indexCallback ? indexCallback(dirtyIndex) : dirtyIndex;
        return values[`${type}`][index];
    });
}
/**
 * @param {?} values
 * @param {?} defaultType
 * @return {?}
 */
function buildLocalizeArrayFn(values, defaultType) {
    return (/**
     * @param {?=} __0
     * @return {?}
     */
    ({ type } = { type: defaultType }) => values[`${type}`]);
}
/**
 * @param {?} patterns
 * @param {?} defaultType
 * @return {?}
 */
function buildMatchFn(patterns, defaultType) {
    return (/**
     * @param {?} dirtyString
     * @param {?=} __1
     * @return {?}
     */
    (dirtyString, { type } = { type: defaultType }) => dirtyString.match(`^(${patterns[`${type}`].join('|')})`));
}
/**
 * @param {?} patterns
 * @param {?} defaultType
 * @return {?}
 */
function buildParseFn(patterns, defaultType) {
    return (/**
     * @param {?} __0
     * @param {?=} __1
     * @return {?}
     */
    ([, result], { type } = { type: defaultType }) => (patterns[`${type}`] || patterns[defaultType])
        .map((/**
     * @param {?} p
     * @return {?}
     */
    p => new RegExp(`^${p}`)))
        .findIndex((/**
     * @param {?} pattern
     * @return {?}
     */
    pattern => pattern.test(result))));
}
class DateFnsParser {
    /**
     * @param {?} locale
     */
    constructor(locale) {
        this._weekStartsOn = (/** @type {?} */ (locale.firstDayOfWeek));
        /** @type {?} */
        const weekdayValues = {
            long: locale.weekdays,
            short: locale.weekdaysShort,
            narrow: locale.weekdaysNarrow
        };
        /** @type {?} */
        const monthValues = {
            long: locale.months,
            short: locale.monthsShort
        };
        /** @type {?} */
        const timeOfDayValues = {
            long: locale.timesOfDay,
            uppercase: locale.timesOfDayUppercase,
            lowercase: locale.timesOfDayLowercase
        };
        /** @type {?} */
        const timeOfDayMatchValues = {
            long: locale.timesOfDay,
            short: locale.timesOfDayUppercase.concat(locale.timesOfDayLowercase)
        };
        this._locale = (/** @type {?} */ (defaultLocale));
        this._locale.localize = Object.assign({}, this._locale.localize, {
            weekday: buildLocalizeFn(weekdayValues, 'long'),
            weekdays: buildLocalizeArrayFn(weekdayValues, 'long'),
            month: buildLocalizeFn(monthValues, 'long'),
            months: buildLocalizeArrayFn(monthValues, 'long'),
            timeOfDay: buildLocalizeFn(timeOfDayValues, 'long', (/**
             * @param {?} hours
             * @return {?}
             */
            (hours) => {
                return hours / 12 >= 1 ? 1 : 0;
            })),
            timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'long')
        });
        this._locale.match = Object.assign({}, this._locale.match, {
            weekdays: buildMatchFn(weekdayValues, 'long'),
            weekday: buildParseFn(weekdayValues, 'long'),
            months: buildMatchFn(monthValues, 'long'),
            month: buildParseFn(monthValues, 'long'),
            timesOfDay: buildMatchFn(timeOfDayMatchValues, 'long'),
            timeOfDay: buildParseFn(timeOfDayMatchValues, 'long')
        });
    }
    /**
     * @private
     * @return {?}
     */
    get _config() {
        return {
            weekStartsOn: this._weekStartsOn,
            locale: this._locale
        };
    }
    /**
     * @param {?} d
     * @param {?} f
     * @return {?}
     */
    format(d, f) {
        return format(d, f, this._config);
    }
    /**
     * @param {?} dS
     * @param {?} f
     * @param {?} bD
     * @return {?}
     */
    parse(dS, f, bD) {
        return parse(dS, this._config);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateParser {
    /**
     * @param {?} format
     * @param {?} locale
     */
    constructor(format, locale) {
        this._format = format;
        this._parser = new DateFnsParser(locale);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    format(date) {
        return this._parser.format(date, this._format);
    }
    /**
     * @param {?} dateString
     * @param {?=} baseDate
     * @return {?}
     */
    parse(dateString, baseDate = new Date()) {
        return this._parser.parse(dateString, this._format, baseDate);
    }
}
class InternalDateParser extends DateParser {
    /**
     * @param {?} mode
     * @param {?} locale
     */
    constructor(mode, locale) {
        /** @type {?} */
        const internalFormats = {
            time: 'HH:mm',
            datetime: 'YYYY-MM-DDTHH:mm',
            date: 'YYYY-MM-DD',
            month: 'YYYY-MM',
            year: 'YYYY'
        };
        super(internalFormats[mode], locale);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRange {
    /**
     * @param {?} start
     * @param {?} dates
     * @param {?} items
     * @param {?} grouped
     * @param {?} comparer
     */
    constructor(start, dates, items, grouped, comparer) {
        this.start = start;
        this.dates = dates;
        this.items = items;
        this.groupedItems = grouped;
        this._comparer = comparer;
    }
    /**
     * @return {?}
     */
    get inRange() {
        return this.items.filter((/**
         * @param {?} i
         * @return {?}
         */
        i => !i.isOutsideRange));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    find(item) {
        return this.items.find((/**
         * @param {?} i
         * @return {?}
         */
        i => this._comparer.equal(i.date, item.date)));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    findIndex(item) {
        if (!item) {
            return -1;
        }
        return this.items.findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => this._comparer.equal(i.date, item.date)));
    }
    /**
     * @param {?} date
     * @return {?}
     */
    containsDate(date) {
        return !!this.inRange.find((/**
         * @param {?} i
         * @return {?}
         */
        i => this._comparer.equal(i.date, date)));
    }
}
/**
 * @abstract
 */
class CalendarRangeService {
    /**
     * @param {?} interval
     * @param {?} rows
     * @param {?} columns
     */
    constructor(interval, rows, columns) {
        this.interval = interval;
        this.marginal = (/** @type {?} */ (interval)) + 1;
        this.rows = rows;
        this.columns = columns;
    }
    /**
     * @return {?}
     */
    get dateComparer() {
        return new DateComparer(this.marginal, this.service.inFinalView);
    }
    /**
     * @return {?}
     */
    get length() {
        return this.rows * this.columns;
    }
    /**
     * @return {?}
     */
    get canMoveNext() {
        /** @type {?} */
        const firstItem = this.next.inRange[0];
        if (firstItem && this.service.maxDate) {
            return firstItem.date <= this.service.maxDate;
        }
        return true;
    }
    /**
     * @return {?}
     */
    get canMovePrevious() {
        /** @type {?} */
        const lastItem = this.previous.inRange.slice(-1).pop();
        if (lastItem && this.service.minDate) {
            return lastItem.date >= this.service.minDate;
        }
        return true;
    }
    /**
     * @param {?} service
     * @return {?}
     */
    loadService(service) {
        this.service = service;
        this.refresh();
    }
    /**
     * @return {?}
     */
    refresh() {
        this.current = this.calcRange(this.service.currentDate);
        this.next = this.calcRange(DateUtil.next(this.interval, DateUtil.clone(this.service.currentDate)));
        this.previous = this.calcRange(DateUtil.previous(this.interval, DateUtil.clone(this.service.currentDate)));
    }
    /**
     * @param {?} forwards
     * @return {?}
     */
    move(forwards) {
        if (forwards) {
            return this.moveNext();
        }
        return this.movePrevious();
    }
    /**
     * @return {?}
     */
    moveNext() {
        DateUtil.next(this.interval, this.service.currentDate);
        this.previous = this.current;
        this.current = this.next;
        this.next = this.calcRange(DateUtil.next(this.interval, DateUtil.clone(this.service.currentDate)));
    }
    /**
     * @return {?}
     */
    movePrevious() {
        DateUtil.previous(this.interval, this.service.currentDate);
        this.next = this.current;
        this.current = this.previous;
        this.previous = this.calcRange(DateUtil.previous(this.interval, DateUtil.clone(this.service.currentDate)));
    }
    /**
     * @param {?} forwards
     * @return {?}
     */
    calc(forwards) {
        if (forwards) {
            return this.next;
        }
        return this.previous;
    }
    /**
     * @protected
     * @param {?} date
     * @return {?}
     */
    calcStart(date) {
        return DateUtil.startOf(this.interval, DateUtil.clone(date));
    }
    /**
     * @protected
     * @param {?} rangeStart
     * @return {?}
     */
    calcDates(rangeStart) {
        return Util.Array
            .range(this.length)
            .map((/**
         * @param {?} i
         * @return {?}
         */
        i => DateUtil.add(this.marginal, DateUtil.clone(rangeStart), i)));
    }
    /**
     * @protected
     * @param {?} dateRange
     * @param {?} baseDate
     * @return {?}
     */
    calcItems(dateRange, baseDate) {
        return dateRange.map((/**
         * @param {?} date
         * @return {?}
         */
        date => {
            /** @type {?} */
            const item = new CalendarItem(date);
            item.isDisabled = !this.dateComparer.between(item.date, this.service.minDate, this.service.maxDate);
            item.isActive = this.dateComparer.equal(item.date, this.service.selectedDate);
            item.isToday = this.dateComparer.equal(item.date, new Date());
            item.isSelectable = item.isDisabled;
            this.configureItem(item, baseDate);
            return item;
        }));
    }
    /**
     * @private
     * @param {?} startDate
     * @return {?}
     */
    calcRange(startDate) {
        /** @type {?} */
        const start = this.calcStart(startDate);
        if (this.service.inFinalView) {
            DateUtil.startOf(this.marginal, start, true);
        }
        /** @type {?} */
        const dates = this.calcDates(start);
        /** @type {?} */
        const items = this.calcItems(dates, startDate);
        return new CalendarRange(start, dates, items, Util.Array.group(items, this.columns), this.dateComparer);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiCalendarViewTitle {
    constructor() {
        this.onZoomOut = new EventEmitter();
    }
}
FuiCalendarViewTitle.decorators = [
    { type: Component, args: [{
                selector: 'fui-calendar-view-title',
                template: `
<span class="title link" (click)="onZoomOut.emit()">
    <ng-content></ng-content>
</span>
<span class="prev link" [class.disabled]="!ranges?.canMovePrevious" (click)="ranges?.movePrevious()">
    <i class="chevron left icon"></i>
</span>
<span class="next link" [class.disabled]="!ranges?.canMoveNext" (click)="ranges?.moveNext()">
    <i class="chevron right icon"></i>
</span>
`,
                styles: [`
.title.link {
    display: inline-block;
    margin-left: 2rem;
    margin-right: 2rem;
}
`]
            }] }
];
/** @nocollapse */
FuiCalendarViewTitle.ctorParameters = () => [];
FuiCalendarViewTitle.propDecorators = {
    ranges: [{ type: Input }],
    onZoomOut: [{ type: Output, args: ['zoomOut',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DatepickerMode = {
    Year: (/** @type {?} */ ('year')),
    Month: (/** @type {?} */ ('month')),
    Date: (/** @type {?} */ ('date')),
    Datetime: (/** @type {?} */ ('datetime')),
    Time: (/** @type {?} */ ('time'))
};
class FuiDatepicker {
    /**
     * @param {?} localizationService
     */
    constructor(localizationService) {
        this.service = new CalendarService(new DatetimeConfig(), localizationService.get().datepicker);
        this.hasClasses = true;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseDown(e) {
        e.preventDefault();
    }
}
FuiDatepicker.decorators = [
    { type: Component, args: [{
                selector: 'fui-datepicker',
                template: `
<ng-container [ngSwitch]="service.currentView">
    <fui-calendar-year-view [service]="service" *ngSwitchCase="0"></fui-calendar-year-view>
    <fui-calendar-month-view [service]="service" *ngSwitchCase="1"></fui-calendar-month-view>
    <fui-calendar-date-view [service]="service" *ngSwitchCase="2"></fui-calendar-date-view>
    <fui-calendar-hour-view [service]="service" *ngSwitchCase="3"></fui-calendar-hour-view>
    <fui-calendar-minute-view [service]="service" *ngSwitchCase="4"></fui-calendar-minute-view>
</ng-container>
`,
                styles: [`
:host {
    user-select: none;
}
`]
            }] }
];
/** @nocollapse */
FuiDatepicker.ctorParameters = () => [
    { type: FuiLocalizationService }
];
FuiDatepicker.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.active',] }, { type: HostBinding, args: ['class.calendar',] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PopupTrigger = {
    Hover: (/** @type {?} */ ('hover')),
    Click: (/** @type {?} */ ('click')),
    OutsideClick: (/** @type {?} */ ('outsideClick')),
    Focus: (/** @type {?} */ ('focus')),
    Manual: (/** @type {?} */ ('manual'))
};
class PopupConfig {
    /**
     * @param {?=} defaults
     */
    constructor(defaults = {}) {
        this.placement = PositioningPlacement.TopLeft;
        this.trigger = PopupTrigger.Hover;
        this.isInverted = false;
        this.delay = 0;
        this.isBasic = false;
        this.transition = 'scale';
        this.transitionDuration = 200;
        this.isFlowing = false;
        this.isInline = false;
        Object.assign(this, defaults);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPopup {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.transitionController = new TransitionController(false);
        this._isOpen = false;
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this.tabindex = 0;
    }
    // Returns the direction (`top`, `left`, `right`, `bottom`) of the current placement.
    /**
     * @return {?}
     */
    get direction() {
        // We need to set direction attribute before popper init to allow correct positioning
        return this.config.placement.split(' ').shift();
    }
    // Returns the alignment (`top`, `left`, `right`, `bottom`) of the current placement.
    /**
     * @return {?}
     */
    get alignment() {
        return this.config.placement.split(' ').pop();
    }
    /**
     * @return {?}
     */
    get dynamicClasses() {
        /** @type {?} */
        const classes = {};
        if (this.direction) {
            classes[this.direction] = true;
        }
        if (this.alignment) {
            classes[this.alignment] = true;
        }
        if (this.config.isInverted) {
            classes.inverted = true;
        }
        if (this.config.isBasic) {
            classes.basic = true;
        }
        if (this.config.isFlowing) {
            classes.flowing = true;
        }
        if (this.config.size) {
            classes[this.config.size] = true;
        }
        if (this.config.width) {
            classes[this.config.width] = true;
        }
        return classes;
    }
    /**
     * @param {?} anchor
     * @return {?}
     */
    set anchor(anchor) {
        this._anchor = anchor;
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @return {?}
     */
    open() {
        // Only attempt to open if currently closed.
        if (!this.isOpen) {
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Create positioning service after a brief delay.
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.positioningService = new PositioningService(this._anchor, this._container.element, this.config.placement, '.dynamic.arrow');
                this.positioningService.hasArrow = !this.config.isBasic;
            }));
            // Cancel all other transitions, and initiate the opening transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.In, (/**
             * @return {?}
             */
            () => {
                // Focus any element with [autofocus] attribute.
                /** @type {?} */
                const autoFocus = (/** @type {?} */ (this.elementRef.nativeElement.querySelector('[autofocus]')));
                if (autoFocus) {
                    // Autofocus after the browser has had time to process other event handlers.
                    setTimeout((/**
                     * @return {?}
                     */
                    () => autoFocus.focus()), 10);
                    // Try to focus again when the modal has opened so that autofocus works in IE11.
                    setTimeout((/**
                     * @return {?}
                     */
                    () => autoFocus.focus()), this.config.transitionDuration);
                }
            })));
            // Finally, set the popup to be open.
            this._isOpen = true;
            this.onOpen.emit();
        }
    }
    /**
     * @return {?}
     */
    toggle() {
        if (!this.isOpen) {
            return this.open();
        }
        return this.close();
    }
    /**
     * @return {?}
     */
    close() {
        // Only attempt to close if currently open.
        if (this.isOpen) {
            // Cancel all other transitions, and initiate the closing transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.Out));
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Start the closing timer, that fires the `onClose` event after the transition duration number of milliseconds.
            this.closingTimeout = window.setTimeout((/**
             * @return {?}
             */
            () => this.onClose.emit()), this.config.transitionDuration);
            // Finally, set the popup to be closed.
            this._isOpen = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        // Makes sense here, as the popup shouldn't be attached to any DOM element.
        event.stopPropagation();
    }
}
FuiPopup.decorators = [
    { type: Component, args: [{
                selector: 'fui-popup',
                template: `
<div class="ui popup"
     [ngClass]="dynamicClasses"
     [fuiTransition]="transitionController"
     [attr.direction]="direction"
     #container>

    <ng-container *ngIf="!config.template && (!!config.header || !!config.text)">
        <div class="header" *ngIf="config.header">{{ config.header }}</div>
        <div class="content">{{ config.text }}</div>
    </ng-container>
    <div #templateSibling></div>

    <fui-popup-arrow *ngIf="!config.isBasic"
                     [placement]="config.placement"
                     [inverted]="config.isInverted"></fui-popup-arrow>
</div>
`,
                styles: [`
.ui.popup {
    /* Autofit popup to the contents. */
    right: auto;
    margin: 0;
}

.ui.animating.popup {
    /* When the popup is animating, it may not initially be in the correct position.
       This fires a mouse event, causing the anchor's mouseleave to fire - making the popup flicker.
       Setting pointer-events to none while animating fixes this bug. */
    pointer-events: none;
}

.ui.popup::before {
    /* Hide the Fomantic UI CSS arrow. */
    display: none;
}

/* Offset popup by 0.75em above and below when placed 'vertically'. */
.ui.popup[direction="top"],
.ui.popup[direction="bottom"] {
    margin-top: 0.75em;
    margin-bottom: 0.75em;
}

/* Offset popup by 0.75em either side when placed 'horizontally'. */
.ui.popup[direction="left"],
.ui.popup[direction="right"] {
    margin-left: 0.75em;
    margin-right: 0.75em;
}
`]
            }] }
];
/** @nocollapse */
FuiPopup.ctorParameters = () => [
    { type: ElementRef }
];
FuiPopup.propDecorators = {
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: true },] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    _container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: false },] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FuiPopupController {
    /**
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} _componentFactory
     * @param {?} config
     */
    constructor(_renderer, _element, _componentFactory, config) {
        this._renderer = _renderer;
        this._element = _element;
        this._componentFactory = _componentFactory;
        // Generate a new FuiPopup component and attach it to the application view.
        this._componentRef = this._componentFactory.createComponent(FuiPopup);
        // Configure popup with provided config.
        this.popup.config = config;
        // When the popup is closed (onClose fires on animation complete),
        this.popup.onClose.subscribe((/**
         * @return {?}
         */
        () => this.cleanup()));
    }
    // Returns generated popup instance.
    /**
     * @return {?}
     */
    get popup() {
        // Use non-null assertion as we only access this when a popup exists.
        return this._componentRef.instance;
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    configure(config) {
        if (config) {
            Object.assign(this.popup.config, config);
        }
    }
    /**
     * @return {?}
     */
    openDelayed() {
        // Cancel the opening timer.
        clearTimeout(this._openingTimeout);
        // Start the popup opening after the specified delay interval.
        this._openingTimeout = window.setTimeout((/**
         * @return {?}
         */
        () => this.open()), this.popup.config.delay);
    }
    /**
     * @return {?}
     */
    open() {
        // Attach the generated component to the current application.
        this._componentFactory.attachToApplication(this._componentRef);
        if (this.popup.config.isInline) {
            this._componentFactory.moveToElement(this._componentRef, this._element.nativeElement.parentElement);
        }
        else {
            // Move the generated element to the body to avoid any positioning issues.
            this._componentFactory.moveToDocumentBody(this._componentRef);
        }
        // Attach a reference to the anchor element. We do it here because IE11 loves to complain.
        this.popup.anchor = this._element;
        // Add a listener to the document body to handle closing.
        this._documentListener = this._renderer
            .listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.onDocumentClick(e)));
        // Start popup open transition.
        this.popup.open();
        // Call lifecyle hook
        /** @type {?} */
        const lifecycle = ((/** @type {?} */ (this))).popupOnOpen;
        if (lifecycle) {
            lifecycle.call(this);
        }
    }
    /**
     * @return {?}
     */
    close() {
        // Cancel the opening timer to stop the popup opening after close has been called.
        clearTimeout(this._openingTimeout);
        if (this._componentRef) {
            // Start popup close transition.
            this.popup.close();
        }
        // Call lifecyle hook
        /** @type {?} */
        const lifecycle = ((/** @type {?} */ (this))).popupOnClose;
        if (lifecycle) {
            lifecycle.call(this);
        }
    }
    /**
     * @return {?}
     */
    toggleDelayed() {
        // If the popup hasn't been created, or it has but it isn't currently open, open the popup.
        if (!this._componentRef || (this._componentRef && !this.popup.isOpen)) {
            return this.openDelayed();
        }
        // O'wise, close it.
        return this.close();
    }
    /**
     * @return {?}
     */
    toggle() {
        // If the popup hasn't been created, or it has but it isn't currently open, open the popup.
        if (!this._componentRef || (this._componentRef && !this.popup.isOpen)) {
            return this.open();
        }
        // O'wise, close it.
        return this.close();
    }
    /**
     * @return {?}
     */
    onMouseEnter() {
        if (this.popup.config.trigger === PopupTrigger.Hover) {
            this.openDelayed();
        }
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        if (this.popup.config.trigger === PopupTrigger.Hover) {
            this.close();
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.popup.config.trigger === PopupTrigger.Click ||
            this.popup.config.trigger === PopupTrigger.OutsideClick) {
            // Repeated clicks require a toggle, rather than just opening the popup each time.
            this.toggleDelayed();
        }
        else if (this.popup.config.trigger === PopupTrigger.Focus &&
            (!this._componentRef || (this._componentRef && !this.popup.isOpen))) {
            // Repeated clicks with a focus trigger requires an open (as focus isn't ever lost on repeated click).
            this.openDelayed();
        }
    }
    /**
     * @return {?}
     */
    onFocusIn() {
        if (this.popup.config.trigger === PopupTrigger.Focus) {
            this.openDelayed();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocusOut(e) {
        if (!this._element.nativeElement.contains(e.relatedTarget) &&
            !this.popup.elementRef.nativeElement.contains(e.relatedTarget) &&
            this.popup.config.trigger === PopupTrigger.Focus) {
            this.close();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.cleanup();
    }
    /**
     * @protected
     * @return {?}
     */
    cleanup() {
        clearTimeout(this._openingTimeout);
        if (this._componentRef.instance && this._componentRef.instance.positioningService) {
            this._componentRef.instance.positioningService.destroy();
        }
        this._componentFactory.detachFromApplication(this._componentRef);
        if (this._documentListener) {
            this._documentListener();
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    onDocumentClick(e) {
        // If the popup trigger is outside click,
        if (this._componentRef && this.popup.config.trigger === PopupTrigger.OutsideClick) {
            /** @type {?} */
            const target = (/** @type {?} */ (e.target));
            // Close the popup if the click is outside of the popup element.
            if (!((/** @type {?} */ (this._element.nativeElement))).contains(target)) {
                this.close();
            }
        }
    }
}
FuiPopupController.propDecorators = {
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onFocusIn: [{ type: HostListener, args: ['focusin',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiPopupComponentController extends FuiPopupController {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} componentFactory
     * @param {?} _component
     * @param {?} config
     */
    constructor(renderer, element, componentFactory, _component, config) {
        super(renderer, element, componentFactory, config);
        this._component = _component;
    }
    /**
     * @return {?}
     */
    get componentInstance() {
        if (this._contentComponentRef) {
            return this._contentComponentRef.instance;
        }
    }
    /**
     * @return {?}
     */
    open() {
        if (!this._contentComponentRef) {
            this._contentComponentRef = this._componentFactory.createComponent((/** @type {?} */ (this._component)));
            this._componentFactory.attachToView(this._contentComponentRef, this.popup.templateSibling);
        }
        super.open();
    }
    /**
     * @protected
     * @return {?}
     */
    cleanup() {
        super.cleanup();
        if (this._contentComponentRef) {
            this._contentComponentRef.destroy();
            this._contentComponentRef = undefined;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiPopupTemplateController extends FuiPopupController {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} componentFactory
     * @param {?} config
     */
    constructor(renderer, element, componentFactory, config) {
        super(renderer, element, componentFactory, config);
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    configure(config) {
        super.configure(config);
        if (config) {
            this.template = config.template;
            this.context = config.context;
        }
    }
    /**
     * @return {?}
     */
    open() {
        // If there is a template, inject it into the view.
        if (this.template) {
            this.popup.templateSibling.clear();
            this._componentFactory.createView(this.popup.templateSibling, this.template, {
                $implicit: this.popup,
                context: this.context
            });
        }
        super.open();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPopupArrow {
    /**
     * @return {?}
     */
    get direction() {
        if (this.placement) {
            return this.placement.split(' ').shift();
        }
    }
    /**
     * @return {?}
     */
    get alignment() {
        if (this.placement) {
            /** @type {?} */
            const alignment = this.placement.split(' ').pop();
            if (alignment === this.direction) {
                return 'center';
            }
            return alignment;
        }
    }
}
FuiPopupArrow.decorators = [
    { type: Component, args: [{
                selector: 'fui-popup-arrow',
                template: `
<div class="dynamic arrow" [attr.direction]="direction" *ngIf="alignment == 'center'"></div>
<div class="static arrow" [attr.direction]="direction" [attr.alignment]="alignment" *ngIf="alignment != 'center'"></div>
`,
                styles: [`
.arrow {
    position: absolute;
    width: 0.71428571em;
    height: 0.71428571em;
    background: #ffffff;
    -webkit-transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    transform: rotate(45deg);
    z-index: 2;
}

:host.inverted .arrow {
    background: #1b1c1d;
}

.arrow[direction="top"] {
    bottom: -0.30714286em;
    box-shadow: 1px 1px 0 0 #bababc;
}

.arrow[direction="left"] {
    right: -0.30714286em;
    box-shadow: 1px -1px 1px 0 #bababc;
}

.arrow[direction="bottom"] {
    top: -0.30714286em;
    box-shadow: -1px -1px 0 0 #bababc;
}

.arrow[direction="right"] {
    left: -0.30714286em;
    box-shadow: -1px 1px 1px 0 #bababc;
}

.static.arrow[direction="bottom"][alignment="left"],
.static.arrow[direction="top"][alignment="left"] {
    left: 1em;
    right: auto;
}

.static.arrow[direction="left"][alignment="top"],
.static.arrow[direction="right"][alignment="top"] {
    top: 1em;
    bottom: auto;
}

.static.arrow[direction="bottom"][alignment="right"],
.static.arrow[direction="top"][alignment="right"] {
    left: auto;
    right: 1em;
}

.static.arrow[direction="left"][alignment="bottom"],
.static.arrow[direction="right"][alignment="bottom"] {
    top: auto;
    bottom: 1em;
}
`]
            }] }
];
FuiPopupArrow.propDecorators = {
    placement: [{ type: Input }],
    inverted: [{ type: HostBinding, args: ['class.inverted',] }, { type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPopupConfig extends PopupConfig {
    constructor() {
        // We use an empty constructor to ensure Angular DI works correctly.
        super();
    }
}
FuiPopupConfig.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FuiPopupConfig.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiPopupDirective extends FuiPopupTemplateController {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} componentFactory
     * @param {?} popupDefaults
     */
    constructor(renderer, element, componentFactory, popupDefaults) {
        super(renderer, element, componentFactory, new PopupConfig(popupDefaults));
    }
    /**
     * @param {?} header
     * @return {?}
     */
    set popupHeader(header) {
        this.popup.config.header = header;
    }
    /**
     * @param {?} text
     * @return {?}
     */
    set popupText(text) {
        this.popup.config.text = text;
    }
    /**
     * @param {?} inverted
     * @return {?}
     */
    set popupInverted(inverted) {
        this.popup.config.isInverted = Util.DOM.parseBooleanAttribute(inverted);
    }
    /**
     * @param {?} basic
     * @return {?}
     */
    set popupBasic(basic) {
        this.popup.config.isBasic = Util.DOM.parseBooleanAttribute(basic);
    }
    /**
     * @param {?} inline
     * @return {?}
     */
    set popupInline(inline) {
        this.popup.config.isInline = Util.DOM.parseBooleanAttribute(inline);
    }
    /**
     * @param {?} flowing
     * @return {?}
     */
    set popupFlowing(flowing) {
        this.popup.config.isFlowing = Util.DOM.parseBooleanAttribute(flowing);
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    set popupTransition(transition) {
        this.popup.config.transition = transition;
    }
    /**
     * @param {?} duration
     * @return {?}
     */
    set popupTransitionDuration(duration) {
        this.popup.config.transitionDuration = duration;
    }
    /**
     * @param {?} placement
     * @return {?}
     */
    set popupPlacement(placement) {
        this.popup.config.placement = placement;
    }
    /**
     * @param {?} width
     * @return {?}
     */
    set popupWidth(width) {
        this.popup.config.width = width;
    }
    /**
     * @param {?} size
     * @return {?}
     */
    set popupSize(size) {
        this.popup.config.size = size;
    }
    /**
     * @param {?} delay
     * @return {?}
     */
    set popupDelay(delay) {
        this.popup.config.delay = delay;
    }
    /**
     * @return {?}
     */
    get popupTrigger() {
        return this.popup.config.trigger;
    }
    /**
     * @param {?} trigger
     * @return {?}
     */
    set popupTrigger(trigger) {
        this.popup.config.trigger = trigger;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    set popupTemplate(template) {
        this.template = template;
    }
    /**
     * @param {?} context
     * @return {?}
     */
    set popupTemplateContext(context) {
        this.context = context;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    set popupConfig(config) {
        this.configure(config);
    }
}
FuiPopupDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fuiPopup]',
                exportAs: 'fuiPopup'
            },] }
];
/** @nocollapse */
FuiPopupDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: FuiComponentFactory },
    { type: FuiPopupConfig }
];
FuiPopupDirective.propDecorators = {
    popupHeader: [{ type: Input }],
    popupText: [{ type: Input }],
    popupInverted: [{ type: Input }],
    popupBasic: [{ type: Input }],
    popupInline: [{ type: Input }],
    popupFlowing: [{ type: Input }],
    popupTransition: [{ type: Input }],
    popupTransitionDuration: [{ type: Input }],
    popupPlacement: [{ type: Input }],
    popupWidth: [{ type: Input }],
    popupSize: [{ type: Input }],
    popupDelay: [{ type: Input }],
    popupTrigger: [{ type: Input }],
    popupTemplate: [{ type: Input }],
    popupTemplateContext: [{ type: Input }],
    popupConfig: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiPopupModule {
}
FuiPopupModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FuiTransitionModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiPopupDirective,
                    FuiPopupArrow,
                    FuiPopup
                ],
                exports: [
                    FuiPopupDirective,
                    FuiPopup
                ],
                providers: [
                    FuiPopupConfig
                ],
                entryComponents: [
                    FuiPopup
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDatepickerDirective extends FuiPopupComponentController {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} componentFactory
     * @param {?} localizationService
     */
    constructor(renderer, element, componentFactory, localizationService) {
        super(renderer, element, componentFactory, FuiDatepicker, new PopupConfig({
            trigger: PopupTrigger.Focus,
            placement: PositioningPlacement.BottomLeft,
            transition: 'scale',
            transitionDuration: 200
        }));
        this.localizationService = localizationService;
        // This ensures the popup is drawn correctly (i.e. no border).
        this._renderer.addClass(this.popup.elementRef.nativeElement, 'ui');
        this._renderer.addClass(this.popup.elementRef.nativeElement, 'calendar');
        this.onLocaleUpdate();
        this.localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        () => this.onLocaleUpdate()));
        this.onSelectedDateChange = new EventEmitter();
        this.onValidatorChange = new EventEmitter();
        this.mode = DatepickerMode.Datetime;
    }
    /**
     * @param {?} placement
     * @return {?}
     */
    set placement(placement) {
        this.popup.config.placement = placement;
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    set transition(transition) {
        this.popup.config.transition = transition;
    }
    /**
     * @param {?} duration
     * @return {?}
     */
    set transitionDuration(duration) {
        this.popup.config.transitionDuration = duration;
    }
    /**
     * @return {?}
     */
    get selectedDate() {
        return this._selectedDate;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    set selectedDate(date) {
        this._selectedDate = date;
        this.onSelectedDateChange.emit(date);
    }
    /**
     * @return {?}
     */
    get mode() {
        return this._mode;
    }
    /**
     * @param {?} mode
     * @return {?}
     */
    set mode(mode) {
        this._mode = mode || DatepickerMode.Datetime;
        switch (this._mode) {
            case DatepickerMode.Year:
                this.config = new YearConfig();
                break;
            case DatepickerMode.Month:
                this.config = new MonthConfig();
                break;
            case DatepickerMode.Date:
            default:
                this.config = new DateConfig();
                break;
            case DatepickerMode.Datetime:
                this.config = new DatetimeConfig();
                break;
            case DatepickerMode.Time:
                this.config = new TimeConfig();
                break;
        }
        this.writeValue(this.selectedDate);
    }
    /**
     * @return {?}
     */
    get localeValues() {
        return this.localizationService.override(this._localeValues, this.localeOverrides);
    }
    /**
     * @return {?}
     */
    popupOnOpen() {
        if (this.componentInstance) {
            this.componentInstance.service.config = this.config;
            this.componentInstance.service.localeValues = this.localeValues;
            this.componentInstance.service.currentDate = this.initialDate || new Date();
            this.componentInstance.service.selectedDate = this.selectedDate;
            this.componentInstance.service.maxDate = this.maxDate;
            this.componentInstance.service.minDate = this.minDate;
            if (this.firstDayOfWeek != undefined) {
                this.componentInstance.service.firstDayOfWeek = this.firstDayOfWeek;
            }
            this.componentInstance.service.reset();
            this.componentInstance.service.onDateChange.subscribe((/**
             * @param {?} d
             * @return {?}
             */
            (d) => {
                this.selectedDate = d;
                this.close();
            }));
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    ngOnChanges({ maxDate, minDate, mode }) {
        if (maxDate || minDate || mode) {
            this.onValidatorChange.emit();
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        /** @type {?} */
        const value = c.value;
        if (value != undefined) {
            // We post process the min & max date because sometimes this puts the date outside of the allowed range.
            if (this.minDate && value < this.minDate) {
                return { fuiMinDate: { required: this.minDate, actual: value } };
            }
            if (this.maxDate && value > this.maxDate) {
                return { fuiMaxDate: { required: this.maxDate, actual: value } };
            }
        }
        // Angular expects null
        // tslint:disable-next-line:no-null-keyword
        return null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.selectedDate = value;
        if (this.componentInstance) {
            this.componentInstance.service.selectedDate = value;
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        if (e.keyCode === KeyCode.Escape) {
            this.close();
        }
    }
    /**
     * @private
     * @return {?}
     */
    onLocaleUpdate() {
        this._localeValues = this.localizationService.get().datepicker;
    }
}
FuiDatepickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fuiDatepicker]',
                providers: [customValidatorFactory(FuiDatepickerDirective)]
            },] }
];
/** @nocollapse */
FuiDatepickerDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: FuiComponentFactory },
    { type: FuiLocalizationService }
];
FuiDatepickerDirective.propDecorators = {
    initialDate: [{ type: Input, args: ['pickerInitialDate',] }],
    maxDate: [{ type: Input, args: ['pickerMaxDate',] }],
    minDate: [{ type: Input, args: ['pickerMinDate',] }],
    firstDayOfWeek: [{ type: Input, args: ['pickerFirstDayOfWeek',] }],
    localeOverrides: [{ type: Input, args: ['pickerLocaleOverrides',] }],
    onSelectedDateChange: [{ type: Output, args: ['pickerSelectedDateChange',] }],
    onValidatorChange: [{ type: Output, args: ['pickerValidatorChange',] }],
    placement: [{ type: Input, args: ['pickerPlacement',] }],
    transition: [{ type: Input, args: ['pickerTransition',] }],
    transitionDuration: [{ type: Input, args: ['pickerTransitionDuration',] }],
    mode: [{ type: Input, args: ['pickerMode',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
class FuiDatepickerDirectiveValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
        this.host = host;
    }
}
FuiDatepickerDirectiveValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: '[fuiDatepicker]',
                host: { '(pickerSelectedDateChange)': 'onChange($event)' },
                providers: [customValueAccessorFactory(FuiDatepickerDirectiveValueAccessor)]
            },] }
];
/** @nocollapse */
FuiDatepickerDirectiveValueAccessor.ctorParameters = () => [
    { type: FuiDatepickerDirective }
];
class FuiDatepickerDirectiveValidator extends CustomValidator {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
        this.host = host;
    }
}
FuiDatepickerDirectiveValidator.decorators = [
    { type: Directive, args: [{
                selector: '[fuiDatepicker]',
                host: { '(pickerValidatorChange)': 'onValidatorChange()' },
                providers: [customValidatorFactory(FuiDatepickerDirectiveValidator)]
            },] }
];
/** @nocollapse */
FuiDatepickerDirectiveValidator.ctorParameters = () => [
    { type: FuiDatepickerDirective }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDatepickerInputDirective {
    /**
     * @param {?} datepicker
     * @param {?} valueAccessor
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} localizationService
     */
    constructor(datepicker, valueAccessor, _renderer, _element, localizationService) {
        this.datepicker = datepicker;
        this.valueAccessor = valueAccessor;
        this._renderer = _renderer;
        this._element = _element;
        this.useNativeOnMobile = true;
        this.fallbackActive = false;
        // Whenever the datepicker value updates, update the input text alongside it.
        this.datepicker.onSelectedDateChange.subscribe((/**
         * @return {?}
         */
        () => this.updateValue(this.selectedDateString)));
        localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        () => this.updateValue(this.selectedDateString)));
    }
    /**
     * @return {?}
     */
    get parser() {
        if (this.fallbackActive) {
            return new InternalDateParser(this.datepicker.mode, this.datepicker.localeValues);
        }
        return new DateParser(this.datepicker.localeValues.formats[this.datepicker.mode], this.datepicker.localeValues);
    }
    /**
     * @return {?}
     */
    get selectedDateString() {
        if (this.datepicker.selectedDate) {
            return this.parser.format(this.datepicker.selectedDate);
        }
    }
    /**
     * @return {?}
     */
    get type() {
        if (this.fallbackActive) {
            return this.datepicker.config.fallback;
        }
        return 'text';
    }
    /**
     * @return {?}
     */
    get max() {
        if (this.fallbackActive && this.datepicker.maxDate) {
            // Since HTML doesn't use a date object max is somewhat tricky.
            // Our Datepicker will always choose the 1st date on the provided precision,
            // meaning anything below the maxDate will work, hence endOf.
            /** @type {?} */
            const max = DateUtil.endOf(this.datepicker.config.precision, DateUtil.clone(this.datepicker.maxDate));
            return this.parser.format(max);
        }
    }
    /**
     * @return {?}
     */
    get min() {
        if (this.fallbackActive && this.datepicker.minDate) {
            // Since HTML doesn't use a date object min is somewhat tricky.
            // We use 1 minute before the next date at the configured precision since
            // our Datepicker picks the first available date at that precision.
            /** @type {?} */
            const min = DateUtil.clone(this.datepicker.minDate);
            return this.parser.format(min);
        }
    }
    /**
     * @return {?}
     */
    get useNativeOnMobile() {
        return this._useNativeOnMobile;
    }
    /**
     * @param {?} fallback
     * @return {?}
     */
    set useNativeOnMobile(fallback) {
        this._useNativeOnMobile = fallback;
        /** @type {?} */
        const isOnMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(navigator.userAgent);
        this.fallbackActive = this.useNativeOnMobile && isOnMobile;
    }
    /**
     * @return {?}
     */
    get fallbackActive() {
        return this._fallbackActive;
    }
    /**
     * @param {?} active
     * @return {?}
     */
    set fallbackActive(active) {
        this._fallbackActive = active;
        // If the fallback is active, then the trigger must be manual so the datepicker never opens.
        this.datepicker.popup.config.trigger = this.fallbackActive ? PopupTrigger.Manual : PopupTrigger.Focus;
        // Update the input value (this will insert the `T` as required).
        this.updateValue(this.selectedDateString);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    typeValue(value) {
        this._lastUpdateTyped = true;
        this._currentInputValue = value;
        if (!value) {
            // Delete the selected date if no date was entered manually.
            return this.datepicker.writeValue(undefined);
        }
        /** @type {?} */
        const parsed = this.parser.parse(value, this.datepicker.selectedDate);
        if (!isNaN(parsed.getTime()) && value === this.parser.format(parsed)) {
            return this.datepicker.writeValue(parsed);
        }
        return this.datepicker.writeValue(undefined);
    }
    /**
     * @return {?}
     */
    onFocusOut() {
        this.valueAccessor.onTouched();
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        // Only update the current value if it is different to what it's being updated to.
        // This is so that the editing position isn't changed when manually typing the date.
        if (!this._lastUpdateTyped) {
            this._renderer.setProperty(this._element.nativeElement, 'value', value || '');
        }
        this._lastUpdateTyped = false;
    }
}
FuiDatepickerInputDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[fuiDatepicker]'
            },] }
];
/** @nocollapse */
FuiDatepickerInputDirective.ctorParameters = () => [
    { type: FuiDatepickerDirective, decorators: [{ type: Host }] },
    { type: FuiDatepickerDirectiveValueAccessor, decorators: [{ type: Host }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: FuiLocalizationService }
];
FuiDatepickerInputDirective.propDecorators = {
    type: [{ type: HostBinding, args: ['attr.type',] }],
    max: [{ type: HostBinding, args: ['attr.max',] }],
    min: [{ type: HostBinding, args: ['attr.min',] }],
    useNativeOnMobile: [{ type: Input, args: ['pickerUseNativeOnMobile',] }],
    typeValue: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
    onFocusOut: [{ type: HostListener, args: ['focusout',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeDateService extends CalendarRangeService {
    /**
     * @param {?} start
     * @return {?}
     */
    calcStart(start) {
        /** @type {?} */
        const monthStart = DateUtil.startOf(DatePrecision.Month, DateUtil.clone(start));
        monthStart.setDate((1 - monthStart.getDay() + this.service.firstDayOfWeek - 7) % 7);
        return monthStart;
    }
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        item.humanReadable = item.date.getDate().toString();
        item.isOutsideRange = item.date.getMonth() !== baseDate.getMonth();
        item.isSelectable = item.isDisabled;
    }
}
class FuiCalendarDateView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Date, new CalendarRangeDateService(DatePrecision.Month, 6, 7));
    }
    /**
     * @return {?}
     */
    get days() {
        /** @type {?} */
        const days = this.service.localeValues.weekdaysNarrow;
        return days.map((/**
         * @param {?} d
         * @param {?} i
         * @return {?}
         */
        (d, i) => days[(i + this.service.firstDayOfWeek) % days.length]));
    }
    /**
     * @return {?}
     */
    get date() {
        return new DateParser(this.service.localeValues.formats.month, this.service.localeValues).format(this.currentDate);
    }
}
FuiCalendarDateView.decorators = [
    { type: Component, args: [{
                selector: 'fui-calendar-date-view',
                template: `
<table class="ui celled center aligned unstackable table seven column day">
<thead>
    <tr>
        <th colspan="7">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ date }}
            </fui-calendar-view-title>
        </th>
    </tr>
    <tr>
        <th *ngFor="let day of days">{{ day }}</th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }] }
];
/** @nocollapse */
FuiCalendarDateView.ctorParameters = () => [
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeHourService extends CalendarRangeService {
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        // Set minutes and seconds to 0
        /** @type {?} */
        const customFormat = this.service.localeValues.formats.time.replace(/[ms]/g, '0');
        item.humanReadable = new DateParser(customFormat, this.service.localeValues).format(item.date);
        item.isOutsideRange = false;
    }
}
class FuiCalendarHourView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Hour, new CalendarRangeHourService(DatePrecision.Date, 6, 4));
    }
    /**
     * @return {?}
     */
    get date() {
        return new DateParser(this.service.localeValues.formats.date, this.service.localeValues).format(this.currentDate);
    }
}
FuiCalendarHourView.decorators = [
    { type: Component, args: [{
                selector: 'fui-calendar-hour-view',
                template: `
<table class="ui celled center aligned unstackable table four column hour">
<thead *ngIf="service.config.mode != 1">
    <tr>
        <th colspan="4">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ date }}
            </fui-calendar-view-title>
        </th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }] }
];
/** @nocollapse */
FuiCalendarHourView.ctorParameters = () => [
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeMinuteService extends CalendarRangeService {
    /**
     * @param {?} start
     * @return {?}
     */
    calcStart(start) {
        return DateUtil.startOf(DatePrecision.Hour, DateUtil.clone(start), true);
    }
    /**
     * @param {?} start
     * @return {?}
     */
    calcDates(start) {
        return Util.Array
            .range(this.length)
            .map((/**
         * @param {?} i
         * @return {?}
         */
        i => DateUtil.add(DatePrecision.Minute, DateUtil.clone(start), i * 5)));
    }
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        item.humanReadable = new DateParser(this.service.localeValues.formats.time, this.service.localeValues).format(item.date);
        item.isOutsideRange = false;
    }
}
class FuiCalendarMinuteView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Minute, new CalendarRangeMinuteService(DatePrecision.Hour, 4, 3));
    }
    /**
     * @return {?}
     */
    get date() {
        if (this.service.config.mode !== CalendarMode.TimeOnly) {
            // Set minutes and seconds to 0
            /** @type {?} */
            const dateTimeFormat = this.service.localeValues.formats.datetime.replace(/[ms]/g, '0');
            return new DateParser(dateTimeFormat, this.service.localeValues).format(this.currentDate);
        }
        else {
            // Set minutes and seconds to 0
            /** @type {?} */
            const timeFormat = this.service.localeValues.formats.time.replace(/[ms]/g, '0');
            return new DateParser(timeFormat, this.service.localeValues).format(this.currentDate);
        }
    }
}
FuiCalendarMinuteView.decorators = [
    { type: Component, args: [{
                selector: 'fui-calendar-minute-view',
                template: `
<table class="ui celled center aligned unstackable table three column minute">
<thead>
    <tr>
        <th colspan="4">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ date }}
            </fui-calendar-view-title>
        </th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }] }
];
/** @nocollapse */
FuiCalendarMinuteView.ctorParameters = () => [
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeMonthService extends CalendarRangeService {
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        item.humanReadable = this.service.localeValues.monthsShort[item.date.getMonth()];
        item.isOutsideRange = false;
    }
}
class FuiCalendarMonthView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Month, new CalendarRangeMonthService(DatePrecision.Year, 4, 3));
    }
    /**
     * @return {?}
     */
    get year() {
        return new DateParser(this.service.localeValues.formats.year, this.service.localeValues).format(this.currentDate);
    }
}
FuiCalendarMonthView.decorators = [
    { type: Component, args: [{
                selector: 'fui-calendar-month-view',
                template: `
<table class="ui celled center aligned unstackable table three column month">
<thead>
    <tr>
        <th colspan="3">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ year }}
            </fui-calendar-view-title>
        </th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }] }
];
/** @nocollapse */
FuiCalendarMonthView.ctorParameters = () => [
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarRangeYearService extends CalendarRangeService {
    /**
     * @param {?} item
     * @param {?} baseDate
     * @return {?}
     */
    configureItem(item, baseDate) {
        item.humanReadable = Util.String.padLeft(item.date.getFullYear().toString(), 4, '0');
        item.isOutsideRange = item.date.getFullYear() >= this.calcStart(baseDate).getFullYear() + 10;
    }
}
class FuiCalendarYearView extends CalendarView {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super(renderer, CalendarViewType.Year, new CalendarRangeYearService(DatePrecision.Decade, 4, 3));
    }
    /**
     * @return {?}
     */
    get decadeStart() {
        return DateUtil
            .startOf(DatePrecision.Decade, DateUtil.clone(this.service.currentDate))
            .getFullYear();
    }
    /**
     * @param {?} year
     * @return {?}
     */
    pad(year) {
        return Util.String.padLeft(year.toString(), 4, '0');
    }
}
FuiCalendarYearView.decorators = [
    { type: Component, args: [{
                selector: 'fui-calendar-year-view',
                template: `
<table class="ui celled center aligned unstackable table three column year">
<thead>
    <tr>
        <th colspan="3">
            <fui-calendar-view-title [ranges]="ranges" (zoomOut)="zoomOut()">
                {{ pad(decadeStart) }} - {{ pad(decadeStart + 10) }}
            </fui-calendar-view-title>
        </th>
    </tr>
</thead>
<tbody>
    <tr *ngFor="let group of ranges.current.groupedItems">
        <td class="link"
            *ngFor="let item of group"
            [calendarItem]="item"
            (click)="setDate(item)">{{ item.humanReadable }}
        </td>
    </tr>
</tbody>
</table>
`
            }] }
];
/** @nocollapse */
FuiCalendarYearView.ctorParameters = () => [
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDatepickerModule {
}
FuiDatepickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FuiPopupModule,
                    FuiLocalizationModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiCalendarItem,
                    FuiCalendarViewTitle,
                    FuiCalendarYearView,
                    FuiCalendarMonthView,
                    FuiCalendarDateView,
                    FuiCalendarHourView,
                    FuiCalendarMinuteView,
                    FuiDatepicker,
                    FuiDatepickerDirective,
                    FuiDatepickerDirectiveValueAccessor,
                    FuiDatepickerDirectiveValidator,
                    FuiDatepickerInputDirective
                ],
                exports: [
                    FuiDatepickerDirective,
                    FuiDatepickerDirectiveValueAccessor,
                    FuiDatepickerDirectiveValidator,
                    FuiDatepickerInputDirective
                ],
                entryComponents: [
                    FuiDatepicker
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDimmer extends FuiTransition {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(renderer, element, changeDetector) {
        super(renderer, element, changeDetector);
        this._isDimmed = false;
        this.isDimmedChange = new EventEmitter();
        this.isClickable = true;
        this.wrapContent = true;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get isDimmed() {
        return this._isDimmed;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isDimmed(value) {
        /** @type {?} */
        const isDimmed = !!value;
        if (!this._transitionController) {
            // Initialise transition functionality when first setting dimmed, to ensure initial state doesn't transition.
            this._transitionController = new TransitionController(isDimmed, 'block');
            this.setTransitionController(this._transitionController);
            this._isDimmed = isDimmed;
        }
        else if (this._isDimmed !== isDimmed) {
            this._isDimmed = isDimmed;
            this._transitionController.stopAll();
            this._transitionController.animate(new Transition('fade', this.transitionDuration, isDimmed ? TransitionDirection.In : TransitionDirection.Out));
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.isClickable) {
            this.isDimmed = false;
            this.isDimmedChange.emit(this.isDimmed);
        }
    }
}
FuiDimmer.decorators = [
    { type: Component, args: [{
                selector: 'fui-dimmer',
                template: `
<div [class.content]="wrapContent">
    <ng-content></ng-content>
</div>
`,
                styles: [`
:host.dimmer:not(.hidden) {
    transition: none;
    display: flex !important;
}
`]
            }] }
];
/** @nocollapse */
FuiDimmer.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiDimmer.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.dimmer',] }],
    isDimmedChange: [{ type: Output }],
    isClickable: [{ type: Input }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    wrapContent: [{ type: Input }],
    isDimmed: [{ type: HostBinding, args: ['class.active',] }, { type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDimmerModule {
}
FuiDimmerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FuiTransitionModule
                ],
                declarations: [
                    FuiDimmer
                ],
                exports: [
                    FuiDimmer
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Creates essentially a 'string' enum.
/** @type {?} */
const DropdownAutoCloseType = {
    ItemClick: (/** @type {?} */ ('itemClick')),
    OutsideClick: (/** @type {?} */ ('outsideClick')),
    Disabled: (/** @type {?} */ ('disabled'))
};
class DropdownService {
    /**
     * @param {?=} autoCloseMode
     */
    constructor(autoCloseMode = DropdownAutoCloseType.ItemClick) {
        this.isOpen = false;
        this.isOpenChange = new EventEmitter();
        this.isDisabled = false;
        this.autoCloseMode = autoCloseMode;
        this.children = [];
    }
    /**
     * @return {?}
     */
    get isNested() {
        return !!this.parent;
    }
    /**
     * @param {?} isOpen
     * @param {?=} reflectInParent
     * @return {?}
     */
    setOpenState(isOpen, reflectInParent = false) {
        if (this.isOpen !== isOpen && !this.isDisabled) {
            // Only update the state if it has changed, and the dropdown isn't disabled.
            this.isOpen = !!isOpen;
            this.isAnimating = true;
            // We must delay the emitting to avoid the 'changed after checked' Angular errors.
            this.delay((/**
             * @return {?}
             */
            () => this.isOpenChange.emit(this.isOpen)));
            if (!this.isOpen) {
                // Close the child dropdowns when this one closes.
                this.children.forEach((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => c.setOpenState(this.isOpen)));
            }
            if (this.parent && reflectInParent) {
                // Open the parent dropdowns when this one opens.
                this.parent.setOpenState(this.isOpen, true);
            }
        }
        else if (this.isOpen !== isOpen && this.isDisabled) {
            // If the state has changed, but the dropdown is disabled, re-emit the original isOpen value.
            this.delay((/**
             * @return {?}
             */
            () => this.isOpenChange.emit(this.isOpen)));
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        if (this.isDisabled !== isDisabled) {
            if (!!isDisabled) {
                // Close the dropdown as it is now disabled
                this.setOpenState(false);
            }
            this.isDisabled = !!isDisabled;
        }
    }
    /**
     * @return {?}
     */
    toggleOpenState() {
        this.setOpenState(!this.isOpen);
    }
    // Registers a dropdown service as a child of this service.
    /**
     * @param {?} child
     * @return {?}
     */
    registerChild(child) {
        if (!this.isChildRegistered(child)) {
            this.children.push(child);
            child.parent = this;
        }
    }
    // Recursive method to check if the provided dropdown is already registered as a child, or is a descendant of a child.
    /**
     * @param {?} child
     * @return {?}
     */
    isChildRegistered(child) {
        return this === child || !!this.children
            .find((/**
         * @param {?} c
         * @return {?}
         */
        c => !!c.children
            .find((/**
         * @param {?} cChild
         * @return {?}
         */
        cChild => cChild.isChildRegistered(child)))));
    }
    // Wipes any nested data, so all services can be cleanly reattached.
    /**
     * @return {?}
     */
    clearChildren() {
        this.children.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => {
            c.parent = undefined;
        }));
        this.children = [];
    }
    // Method for delaying an event into the next tick, to avoid Angular "changed after checked" error.
    /**
     * @private
     * @param {?} callback
     * @return {?}
     */
    delay(callback) {
        setTimeout((/**
         * @return {?}
         */
        () => callback()));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDropdownMenuItem {
    /**
     * @param {?} _renderer
     * @param {?} element
     */
    constructor(_renderer, element) {
        this._renderer = _renderer;
        this.element = element;
        this.isSelected = false;
        this.selectedClass = 'selected';
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        // We must use nativeElement as Angular doesn't have a way of reading class information.
        /** @type {?} */
        const element = (/** @type {?} */ (this.element.nativeElement));
        return element.classList.contains('disabled');
    }
    /**
     * @return {?}
     */
    get hasChildDropdown() {
        return !!this.childDropdownMenu;
    }
    /**
     * @return {?}
     */
    get isSelected() {
        return this._isSelected;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isSelected(value) {
        // Renderer is used to enable a dynamic class name.
        if (value) {
            this._renderer.addClass(this.element.nativeElement, this.selectedClass);
        }
        else {
            this._renderer.removeClass(this.element.nativeElement, this.selectedClass);
        }
    }
    /**
     * @return {?}
     */
    performClick() {
        // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
        this.element.nativeElement.click();
    }
}
FuiDropdownMenuItem.decorators = [
    { type: Directive, args: [{
                // We must attach to every '.item' as Angular doesn't support > selectors.
                selector: '.item'
            },] }
];
/** @nocollapse */
FuiDropdownMenuItem.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FuiDropdownMenuItem.propDecorators = {
    childDropdownMenu: [{ type: ContentChild, args: [forwardRef((/**
                 * @return {?}
                 */
                () => FuiDropdownMenu)), { static: false },] }]
};
class FuiDropdownMenu extends FuiTransition {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(renderer, element, changeDetector) {
        super(renderer, element, changeDetector);
        // Initialise transition functionality.
        this._transitionController = new TransitionController(false);
        this.setTransitionController(this._transitionController);
        this.menuTransition = 'slide down';
        this.menuTransitionDuration = 200;
        this.menuAutoSelectFirst = false;
        this.menuSelectedItemClass = 'selected';
        // In case the dropdown menu is destroyed before it has a chance to be fully initialised.
        this._parentKeyDownListener = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set parentElement(value) {
        this._parentKeyDownListener = this._renderer
            .listen(value.nativeElement, 'keydown', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.onParentKeyDown(e)));
    }
    /**
     * @param {?} items
     * @return {?}
     */
    set items(items) {
        this._itemsQueryOverride = items;
    }
    /**
     * @return {?}
     */
    get service() {
        return this._service;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set service(value) {
        this._service = value;
        /** @type {?} */
        let previousIsOpen = this._service.isOpen;
        this._service.isOpenChange.subscribe((/**
         * @param {?} isOpen
         * @return {?}
         */
        (isOpen) => {
            if (isOpen !== previousIsOpen) {
                // Only run transitions if the open state has changed.
                this._transitionController.stopAll();
                this._transitionController.animate(new Transition(this.menuTransition, this.menuTransitionDuration, TransitionDirection.Either, (/**
                 * @return {?}
                 */
                () => this._service.isAnimating = false)));
            }
            if (!isOpen) {
                // Reset the item selections when a nested item is selected to avoid incosistent open states.
                if (this.selectedItems.length > 1) {
                    this.resetSelection();
                }
            }
            previousIsOpen = isOpen;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    get _itemsQuery() {
        return this._itemsQueryOverride || this._itemsQueryInternal;
    }
    // Get the list of items, ignoring those that are disabled.
    /**
     * @private
     * @return {?}
     */
    get _items() {
        return this._itemsQuery.filter((/**
         * @param {?} i
         * @return {?}
         */
        i => !i.isDisabled));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            if (this._service.autoCloseMode === DropdownAutoCloseType.ItemClick) {
                /** @type {?} */
                const target = (/** @type {?} */ (e.target));
                if (this._element.nativeElement.contains(target.closest('.item')) && !/input|textarea/i.test(target.tagName)) {
                    // Once an item is selected, we can close the entire dropdown.
                    this._service.setOpenState(false, true);
                }
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onParentKeyDown(e) {
        // Only the root dropdown (i.e. not nested dropdowns) is responsible for keeping track of the currently selected item.
        if (this._service && this._service.isOpen && !this._service.isNested) {
            // Stop document events like scrolling while open.
            /** @type {?} */
            const target = (/** @type {?} */ (e.target));
            if (!/input/i.test(target.tagName) &&
                [KeyCode.Escape, KeyCode.Enter, KeyCode.Up, KeyCode.Down, KeyCode.Left, KeyCode.Right].find((/**
                 * @param {?} kC
                 * @return {?}
                 */
                kC => kC === e.keyCode))) {
                e.preventDefault();
            }
            // Gets the top selected item from the stack.
            const [selected] = this.selectedItems.slice(-1);
            // Keeping track of the menu containing the currently selected element allows us to easily determine its siblings.
            /** @type {?} */
            let selectedContainer = this;
            if (this.selectedItems.length >= 2) {
                const [selectedParent] = this.selectedItems.slice(-2);
                selectedContainer = selectedParent.childDropdownMenu;
            }
            switch (e.keyCode) {
                // Escape : close the entire dropdown.
                case KeyCode.Escape: {
                    this._service.setOpenState(false);
                    break;
                }
                // Down : select the next item below the current one, or the 1st if none selected.
                case KeyCode.Down:
                // Up : select the next item above the current one, or the 1st if none selected.
                case KeyCode.Up: {
                    this.selectedItems.pop();
                    this.selectedItems.push(selectedContainer.updateSelection(selected, e.keyCode));
                    // Prevent default regardless of whether we are in an input, to stop jumping to the start or end of the query string.
                    e.preventDefault();
                    break;
                }
                // Enter : if the item doesn't contain a nested dropdown, 'click' it. Otherwise, fall through to 'Right' action.
                case KeyCode.Enter: {
                    if (selected && !selected.hasChildDropdown) {
                        selected.performClick();
                        break;
                    }
                }
                // falls through
                // Right : if the selected item contains a nested dropdown, open the dropdown & select the 1st item.
                case KeyCode.Right: {
                    if (selected && selected.hasChildDropdown) {
                        selected.childDropdownMenu.service.setOpenState(true);
                        this.selectedItems.push(selected.childDropdownMenu.updateSelection(selected, e.keyCode));
                    }
                    break;
                }
                // Left : if the selected item is in a nested dropdown, close it and select the containing item.
                case KeyCode.Left: {
                    if (this.selectedItems.length >= 2) {
                        this.selectedItems.pop();
                        const [selectedParent] = this.selectedItems.slice(-1);
                        selectedParent.childDropdownMenu.service.setOpenState(false);
                        selectedParent.isSelected = true;
                    }
                    break;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    resetSelection() {
        this.selectedItems = [];
        this._items.forEach((/**
         * @param {?} i
         * @return {?}
         */
        i => {
            i.selectedClass = this.menuSelectedItemClass;
            i.isSelected = false;
        }));
        if (this.menuAutoSelectFirst && this._items.length > 0) {
            // Autoselect 1st item if required & possible.
            this._items[0].isSelected = true;
            this.scrollToItem(this._items[0]);
            this.selectedItems.push(this._itemsQuery.first);
        }
    }
    // Determines the item to next be selected, based on the keyboard input & the currently selected item.
    /**
     * @param {?} selectedItem
     * @param {?} keyCode
     * @return {?}
     */
    updateSelection(selectedItem, keyCode) {
        if (selectedItem) {
            // Remove the selected status on the previously selected item.
            selectedItem.isSelected = false;
        }
        /** @type {?} */
        let selectedIndex = this._items
            .findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => i === selectedItem));
        /** @type {?} */
        let newSelection;
        switch (keyCode) {
            case KeyCode.Enter:
            case KeyCode.Right:
            case KeyCode.Down:
                selectedIndex += 1;
                break;
            case KeyCode.Up:
                if (selectedIndex === -1) {
                    // If none are selected, select the 1st item. Should this be `this.items.last - 1`?
                    selectedIndex = 0;
                    break;
                }
                selectedIndex -= 1;
                break;
        }
        // Select the item at the updated index. The || is to stop us selecting past the start or end of the item list.
        newSelection = this._items[selectedIndex] || selectedItem;
        if (newSelection) {
            // Set the selected status on the newly selected item.
            newSelection.isSelected = true;
            // Set the current scroll position to the location of the newly selected item.
            this.scrollToItem(newSelection);
        }
        return newSelection;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    scrollToItem(item) {
        /** @type {?} */
        const menu = this._element.nativeElement;
        /** @type {?} */
        const selectedRect = item.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const menuRect = menu.getBoundingClientRect();
        /** @type {?} */
        let scrollAmount = 0;
        if (selectedRect.bottom > menuRect.bottom) {
            scrollAmount = selectedRect.bottom - menuRect.bottom;
        }
        if (selectedRect.top < menuRect.top) {
            scrollAmount = selectedRect.top - menuRect.top;
        }
        menu.scrollTop += Math.round(scrollAmount);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.onItemsChanged();
        this._itemsQuery.changes.subscribe((/**
         * @return {?}
         */
        () => this.onItemsChanged()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._parentKeyDownListener();
    }
    /**
     * @private
     * @return {?}
     */
    onItemsChanged() {
        // We use `_items` rather than `items` in case one or more have become disabled.
        this.resetSelection();
    }
}
FuiDropdownMenu.decorators = [
    { type: Directive, args: [{
                selector: '[fuiDropdownMenu]'
            },] }
];
/** @nocollapse */
FuiDropdownMenu.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiDropdownMenu.propDecorators = {
    menuTransition: [{ type: Input }],
    menuTransitionDuration: [{ type: Input }],
    menuAutoSelectFirst: [{ type: Input }],
    menuSelectedItemClass: [{ type: Input }],
    _itemsQueryInternal: [{ type: ContentChildren, args: [FuiDropdownMenuItem,] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDropdown {
    /**
     * @param {?} _element
     */
    constructor(_element) {
        this._element = _element;
        this.service = new DropdownService();
        this.service.isOpenChange.subscribe((/**
         * @return {?}
         */
        () => {
            if (this.service.isOpen) {
                this._element.nativeElement.focus();
            }
        }));
    }
    /**
     * @return {?}
     */
    get isOpenChange() {
        return this.service.isOpenChange;
    }
    /**
     * @return {?}
     */
    get isActive() {
        // This is to ensure nested dropdowns don't get made bold.
        return this.service.isOpen && !this.service.isNested;
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this.service.isOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        // If we are opening the dropdown, we want to always open its parents.
        this.service.setOpenState(value, !!value);
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        return this.service.isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isDisabled(value) {
        this.service.setDisabledState(value);
    }
    /**
     * @return {?}
     */
    get autoClose() {
        return this.service.autoCloseMode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoClose(value) {
        this.service.autoCloseMode = value;
    }
    /**
     * @return {?}
     */
    get children() {
        // @ContentChildren includes the current element by default.
        return this._children.filter((/**
         * @param {?} c
         * @return {?}
         */
        c => c !== this));
    }
    /**
     * @return {?}
     */
    get tabIndex() {
        if (this.isDisabled || this.service.isNested) {
            // If disabled, remove from tabindex.
            return undefined;
        }
        if (this._tabIndex != undefined) {
            // If custom tabindex, default to that.
            return this._tabIndex;
        }
        // Otherwise, return default of 0.
        return 0;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this._menu) {
            throw new Error('You must set [fuiDropdownMenu] on the menu element.');
        }
        this._menu.service = this.service;
        this._menu.parentElement = this._element;
        this.childrenUpdated();
        this._children.changes
            .subscribe((/**
         * @return {?}
         */
        () => this.childrenUpdated()));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            this.service.toggleOpenState();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocusOut(e) {
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.externallyClose();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeypress(e) {
        // Block the keyboard event from being fired on parent dropdowns.
        if (!e.eventHandled) {
            if (e.keyCode === KeyCode.Enter) {
                e.eventHandled = true;
                this.service.setOpenState(true);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    childrenUpdated() {
        // Reregister child dropdowns each time the menu content changes.
        this.children
            .map((/**
         * @param {?} c
         * @return {?}
         */
        c => c.service))
            .forEach((/**
         * @param {?} s
         * @return {?}
         */
        s => this.service.registerChild(s)));
    }
    /**
     * @private
     * @return {?}
     */
    externallyClose() {
        if (this.service.autoCloseMode === DropdownAutoCloseType.ItemClick ||
            this.service.autoCloseMode === DropdownAutoCloseType.OutsideClick) {
            // No need to reflect in parent since they are also bound to document.
            this.service.setOpenState(false);
        }
    }
}
FuiDropdown.decorators = [
    { type: Directive, args: [{
                selector: '[fuiDropdown]'
            },] }
];
/** @nocollapse */
FuiDropdown.ctorParameters = () => [
    { type: ElementRef }
];
FuiDropdown.propDecorators = {
    _menu: [{ type: ContentChild, args: [FuiDropdownMenu, { static: false },] }],
    isOpenChange: [{ type: Output }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    isOpen: [{ type: Input }],
    isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    autoClose: [{ type: Input }],
    _children: [{ type: ContentChildren, args: [FuiDropdown, { descendants: true },] }],
    _tabIndex: [{ type: Input, args: ['tabindex',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }],
    onKeypress: [{ type: HostListener, args: ['keypress', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiDropdownModule {
}
FuiDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FuiTransitionModule
                ],
                declarations: [
                    FuiDropdown,
                    FuiDropdownMenu,
                    FuiDropdownMenuItem
                ],
                exports: [
                    FuiDropdown,
                    FuiDropdownMenu,
                    FuiDropdownMenuItem
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Helper class to support method chaining when calling `FuiModalService.open(...)`.
/**
 * @template T, U, V
 */
class ActiveModal {
    /**
     * @param {?} instance
     * @param {?} componentRef
     */
    constructor(instance, componentRef) {
        this._config = instance;
        this._componentRef = componentRef;
        // Automatically destroy the modal component when it has been dismissed.
        this.component.onDismiss.subscribe((/**
         * @return {?}
         */
        () => this._componentRef.destroy()));
    }
    // Shorthand for direct access to the `FuiModal` instance.
    /**
     * @return {?}
     */
    get component() {
        return this._componentRef.instance;
    }
    // Registers a callback for when `onApprove` is fired.
    /**
     * @param {?} callback
     * @return {?}
     */
    onApprove(callback) {
        this.component.onApprove.subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => callback(res)));
        return this;
    }
    // Registers a callback for when `onDeny` is fired.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDeny(callback) {
        this.component.onDeny.subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => callback(res)));
        return this;
    }
    // Fires the approve event of the modal manually.
    /**
     * @param {?} result
     * @return {?}
     */
    approve(result) {
        this.component.approve(result);
    }
    // Fires the deny event of the modal manually.
    /**
     * @param {?} result
     * @return {?}
     */
    deny(result) {
        this.component.deny(result);
    }
    // Removes the modal component instantly, without transitions or firing any events.
    /**
     * @return {?}
     */
    destroy() {
        this._componentRef.destroy();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ModalSize = {
    Mini: (/** @type {?} */ ('mini')),
    Tiny: (/** @type {?} */ ('tiny')),
    Small: (/** @type {?} */ ('small')),
    Normal: (/** @type {?} */ ('normal')),
    Large: (/** @type {?} */ ('large'))
};
// Stores a basic set of configuration options for a modal.
/**
 * @template T, U, V
 */
class ModalConfig {
    /**
     * @param {?=} context
     * @param {?=} isClosable
     */
    constructor(context = undefined, isClosable = true) {
        // Initialise with default values.
        this.isClosable = isClosable;
        this.context = context;
        this.size = ModalSize.Normal;
        this.isFullScreen = false;
        this.isBasic = false;
        this.isInverted = false;
        this.isCentered = true;
        this.mustScroll = false;
        this.transition = 'scale';
        this.transitionDuration = 500;
    }
}
// Used when creating a modal from a `TemplateRef`.
/**
 * @template T, U, V
 */
class TemplateModalConfig extends ModalConfig {
    /**
     * @param {?} template
     * @param {?=} context
     * @param {?=} isClosable
     */
    constructor(template, context = undefined, isClosable = true) {
        super(context, isClosable);
        this.template = template;
    }
}
// Used when creating a modal from an existing component.
/**
 * @template T, U, V
 */
class ComponentModalConfig extends ModalConfig {
    /**
     * @param {?} component
     * @param {?=} context
     * @param {?=} isClosable
     */
    constructor(component, context = undefined, isClosable = true) {
        super(context, isClosable);
        this.component = component;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Used to pass ability to control a modal to a component.
/**
 * @template T, U
 */
class ModalControls {
    /**
     * @param {?} approve
     * @param {?} deny
     */
    constructor(approve, deny) {
        this.approve = approve;
        this.deny = deny;
    }
    // Use method here rather than arrow variables to make intellisense show they're methods.
    /**
     * @param {?} result
     * @return {?}
     */
    approve(result) {
    }
    /**
     * @param {?} result
     * @return {?}
     */
    deny(result) {
    }
}
// Injected into custom modal components, to allow control of the modal, and access to a context object.
/**
 * @template T, U, V
 */
class Modal extends ModalControls {
    /**
     * @param {?} controls
     * @param {?} context
     */
    constructor(controls, context) {
        // Instances of `ModalControls` are only created in the `FuiModal` constructor,
        // so we take an initialised instance rather than remaking one each time.
        super(controls.approve, controls.deny);
        this.context = context;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Shorthand for a modal template. Sets up ability to write: `<ng-template let-context let-modal="modal">...</ng-template>`
// We use an abstract class as ModalTemplate tends to be used within decorated properties, which means it needs to exist!
/**
 * @abstract
 * @template T, U, V
 */
class ModalTemplate extends TemplateRef {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
class FuiModal {
    /**
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} _componentFactory
     */
    constructor(_renderer, _element, _componentFactory) {
        this._renderer = _renderer;
        this._element = _element;
        this._componentFactory = _componentFactory;
        // Initialise with default configuration from `ModalConfig` (to avoid writing defaults twice).
        /** @type {?} */
        const config = new ModalConfig();
        this.loadConfig(config);
        // Event emitters for each of the possible modal outcomes.
        this.onApprove = new EventEmitter();
        this.onDeny = new EventEmitter();
        this.onDismiss = new EventEmitter();
        // Initialise controls with actions for the `approve` and `deny` cases.
        this.controls = new ModalControls((/**
         * @param {?} res
         * @return {?}
         */
        res => this.dismiss((/**
         * @return {?}
         */
        () => this.onApprove.emit(res)))), (/**
         * @param {?} res
         * @return {?}
         */
        res => this.dismiss((/**
         * @return {?}
         */
        () => this.onDeny.emit(res)))));
        // Internal variable initialisation.
        this.dimBackground = false;
        this._isClosing = false;
        this.transitionController = new TransitionController(false);
    }
    /**
     * @return {?}
     */
    get approve() {
        return this.controls.approve;
    }
    /**
     * @return {?}
     */
    get deny() {
        return this.controls.deny;
    }
    /**
     * @return {?}
     */
    get dynamicClasses() {
        /** @type {?} */
        const classes = {};
        if (this.size) {
            classes[this.size] = true;
        }
        return classes;
    }
    // Value to deny with when closing via `isClosable`.
    /**
     * @return {?}
     */
    get isFullScreen() {
        return this._isFullScreen;
    }
    /**
     * @param {?} fullScreen
     * @return {?}
     */
    set isFullScreen(fullScreen) {
        this._isFullScreen = Util.DOM.parseBooleanAttribute(fullScreen);
    }
    /**
     * @return {?}
     */
    get mustScroll() {
        return this._mustScroll;
    }
    /**
     * @param {?} mustScroll
     * @return {?}
     */
    set mustScroll(mustScroll) {
        this._mustScroll = mustScroll;
        // 'Cache' value in _mustAlwaysScroll so that if `true`, _mustScroll isn't ever auto-updated.
        this._mustAlwaysScroll = mustScroll;
        this.updateScroll();
    }
    /**
     * @return {?}
     */
    get isInverted() {
        return this._isInverted;
    }
    /**
     * @param {?} inverted
     * @return {?}
     */
    set isInverted(inverted) {
        this._isInverted = Util.DOM.parseBooleanAttribute(inverted);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Transition the modal to be visible.
        this.transitionController.animate(new Transition(this.transition, this.transitionDuration, TransitionDirection.In));
        setTimeout((/**
         * @return {?}
         */
        () => this.dimBackground = true));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Move the modal to the document body to ensure correct scrolling.
        this._originalContainer = this._element.nativeElement.parentNode;
        (/** @type {?} */ (document.querySelector('body'))).appendChild(this._element.nativeElement);
        // Remove the #templateSibling element from the DOM to fix bottom border styles.
        /** @type {?} */
        const templateElement = (/** @type {?} */ (this.templateSibling.element.nativeElement));
        if (templateElement.parentNode) {
            templateElement.parentNode.removeChild(templateElement);
        }
        /** @type {?} */
        const element = (/** @type {?} */ (this._modalElement.nativeElement));
        setTimeout((/**
         * @return {?}
         */
        () => this.updateScroll()));
        // Focus any element with [autofocus] attribute.
        /** @type {?} */
        const autoFocus = (/** @type {?} */ (element.querySelector('[autofocus]')));
        if (autoFocus) {
            // Autofocus after the browser has had time to process other event handlers.
            setTimeout((/**
             * @return {?}
             */
            () => autoFocus.focus()), 10);
            // Try to focus again when the modal has opened so that autofocus works in IE11.
            setTimeout((/**
             * @return {?}
             */
            () => autoFocus.focus()), this.transitionDuration);
        }
    }
    // Updates the modal with the specified configuration.
    /**
     * @template V
     * @param {?} config
     * @return {?}
     */
    loadConfig(config) {
        this.isClosable = config.isClosable;
        this.closeResult = config.closeResult;
        this.size = config.size;
        this.isFullScreen = config.isFullScreen;
        this.isBasic = config.isBasic;
        this.isInverted = config.isInverted;
        this.isCentered = config.isCentered;
        this.mustScroll = config.mustScroll;
        this.transition = config.transition;
        this.transitionDuration = config.transitionDuration;
    }
    // Closes the modal with a 'deny' outcome, using the specified default reason.
    /**
     * @return {?}
     */
    close() {
        if (this.isClosable) {
            // If we are allowed to close, fire the deny result with the default value.
            this.deny(this.closeResult);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        // Makes sense here, as the modal shouldn't be attached to any DOM element.
        e.stopPropagation();
    }
    // Document listener is fine here because nobody will have enough modals open.
    /**
     * @param {?} e
     * @return {?}
     */
    onDocumentKeyUp(e) {
        if (e.keyCode === KeyCode.Escape) {
            // Close automatically covers case of `!isClosable`, so check not needed.
            this.close();
        }
    }
    /**
     * @return {?}
     */
    onDocumentResize() {
        this.updateScroll();
    }
    // Dismisses the modal with a transition, firing the callback after the modal has finished transitioning.
    /**
     * @private
     * @param {?=} callback
     * @return {?}
     */
    dismiss(callback = (/**
     * @return {?}
     */
    () => {
    })) {
        // If we aren't currently closing,
        if (!this._isClosing) {
            this._isClosing = true;
            // Transition the modal to be invisible.
            this.dimBackground = false;
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.transition, this.transitionDuration, TransitionDirection.Out, (/**
             * @return {?}
             */
            () => {
                // When done, move the modal back to its original location, emit a dismiss event, and fire the callback.
                if (this._originalContainer) {
                    this._originalContainer.appendChild(this._element.nativeElement);
                }
                this.onDismiss.emit();
                callback();
            })));
        }
    }
    // Decides whether the modal needs to reposition to allow scrolling.
    /**
     * @private
     * @return {?}
     */
    updateScroll() {
        // _mustAlwaysScroll works by stopping _mustScroll from being automatically updated, so it stays `true`.
        if (!this._mustAlwaysScroll && this._modalElement) {
            // Fomantic UI modal margin and dimmer padding are 1rem, which is relative to the global font size, so for compatibility:
            /** @type {?} */
            const fontSize = parseFloat(window.getComputedStyle(document.documentElement).getPropertyValue('font-size'));
            /** @type {?} */
            const margin = fontSize * 2;
            /** @type {?} */
            const element = (/** @type {?} */ (this._modalElement.nativeElement));
            // The modal must scroll if the window height is smaller than the modal height + both margins.
            this._mustScroll = window.innerHeight < element.clientHeight + margin * 2;
        }
    }
}
FuiModal.decorators = [
    { type: Component, args: [{
                selector: 'fui-modal',
                template: `
<!-- Page dimmer for modal background. -->
<fui-modal-dimmer [ngClass]="{'top aligned': !isCentered}"
                  [class.inverted]="isInverted"
                  [(isDimmed)]="dimBackground"
                  [transitionDuration]="transitionDuration"
                  (click)="close()">

    <!-- Modal component, with transition component attached -->
    <div class="ui modal"
         [fuiTransition]="transitionController"
         [class.active]="transitionController?.isVisible"
         [class.fullscreen]="isFullScreen"
         [class.basic]="isBasic"
         [class.scrolling]="mustScroll"
         [class.inverted]="isInverted"
         [ngClass]="dynamicClasses"
         (click)="onClick($event)"
         #modal>

        <!-- Configurable close icon -->
        <i class="close icon" *ngIf="isClosable" (click)="close()"></i>
        <!-- <ng-content> so that <fui-modal> can be used as a normal component. -->
        <ng-content></ng-content>
        <!-- @ViewChild reference so we can insert elements beside this div. -->
        <div #templateSibling></div>
    </div>
</fui-modal-dimmer>
`,
                styles: [``]
            }] }
];
/** @nocollapse */
FuiModal.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: FuiComponentFactory }
];
FuiModal.propDecorators = {
    isClosable: [{ type: Input }],
    closeResult: [{ type: Input }],
    onApprove: [{ type: Output, args: ['approved',] }],
    onDeny: [{ type: Output, args: ['denied',] }],
    onDismiss: [{ type: Output, args: ['dismissed',] }],
    size: [{ type: Input }],
    isCentered: [{ type: Input }],
    isBasic: [{ type: Input }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: true },] }],
    _modalElement: [{ type: ViewChild, args: ['modal', { static: false },] }],
    isFullScreen: [{ type: Input }],
    mustScroll: [{ type: Input }],
    isInverted: [{ type: Input }],
    onDocumentKeyUp: [{ type: HostListener, args: ['document:keyup', ['$event'],] }],
    onDocumentResize: [{ type: HostListener, args: ['window:resize',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiModalService {
    /**
     * @param {?} _componentFactory
     */
    constructor(_componentFactory) {
        this._componentFactory = _componentFactory;
    }
    /**
     * @template T, U, V
     * @param {?} modal
     * @return {?}
     */
    open(modal) {
        // Generate the modal component to be shown.
        /** @type {?} */
        const componentRef = this._componentFactory.createComponent(FuiModal);
        // Shorthand for the created modal component instance.
        /** @type {?} */
        const modalComponent = componentRef.instance;
        if (modal instanceof TemplateModalConfig) {
            // Inject the template into the view.
            this._componentFactory.createView(modalComponent.templateSibling, modal.template, {
                // `let-context`
                $implicit: modal.context,
                // `let-modal="modal"`
                modal: componentRef.instance.controls
            });
        }
        else if (modal instanceof ComponentModalConfig) {
            // Generate the component to be used as the modal content,
            // injecting an instance of `Modal` to be used in the component constructor.
            /** @type {?} */
            const contentComponentRef = this._componentFactory.createComponent(modal.component, [
                {
                    provide: Modal,
                    useValue: new Modal(modalComponent.controls, modal.context)
                }
            ]);
            // Insert the new component into the content of the modal.
            this._componentFactory.attachToView(contentComponentRef, modalComponent.templateSibling);
            // Shorthand for access to the content component's DOM element.
            /** @type {?} */
            const contentElement = (/** @type {?} */ (contentComponentRef.location.nativeElement));
            // Move all of the DOM elements inside the component to the main modal element.
            // This is done so that CSS classes apply correctly. It does stop any custom styles from working however,
            // so other ways may have to be investigated.
            while (contentElement.hasChildNodes() && contentElement.parentElement && contentElement.firstChild) {
                contentElement.parentElement.appendChild(contentElement.removeChild(contentElement.firstChild));
            }
            // Remove the generated component's 'empty shell' from the DOM.
            this._componentFactory.detachFromDocument(contentComponentRef);
        }
        // Attach the new modal component to the application.
        // The component will move itself to the document body for correctl styling.
        this._componentFactory.attachToApplication(componentRef);
        // Initialise the generated modal with the provided config.
        modalComponent.loadConfig(modal);
        // Return an instance of an `ActiveModal`, so the user can control the new modal.
        return new ActiveModal(modal, componentRef);
    }
}
FuiModalService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FuiModalService.ctorParameters = () => [
    { type: FuiComponentFactory }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiModalDimmer extends FuiDimmer {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(renderer, element, changeDetector) {
        super(renderer, element, changeDetector);
        this.hasClasses = true;
        this.isClickable = false;
    }
}
FuiModalDimmer.decorators = [
    { type: Component, args: [{
                selector: 'fui-modal-dimmer',
                template: `<ng-content></ng-content>`,
                styles: [`
        :host.ui.dimmer:not(.hidden) {
            transition: none;
            overflow-y: auto;
            display: flex !important;
        }
    `]
            }] }
];
/** @nocollapse */
FuiModalDimmer.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiModalDimmer.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.page',] }, { type: HostBinding, args: ['class.modals',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiModalModule {
}
FuiModalModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FuiDimmerModule,
                    FuiTransitionModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiModal,
                    FuiModalDimmer
                ],
                exports: [
                    FuiModal
                ],
                providers: [
                    FuiModalService
                ],
                entryComponents: [
                    FuiModal
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiRating {
    constructor() {
        this.hoveredIndex = -1;
        this.value = 0;
        this.valueChange = new EventEmitter();
        this.type = 'star';
        this.maximum = 5;
        this.isReadonly = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get icons() {
        // tslint:disable-next-line:prefer-literal
        return new Array(this.maximum);
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value;
    }
    /**
     * @return {?}
     */
    get maximum() {
        return this._maximum;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maximum(value) {
        this._maximum = +value;
    }
    /**
     * @param {?} i
     * @return {?}
     */
    onClick(i) {
        if (!this.isReadonly) {
            this.value = i + 1;
            this.valueChange.emit(this.value);
        }
    }
    /**
     * @param {?} i
     * @return {?}
     */
    onMouseover(i) {
        this.hoveredIndex = i;
    }
    /**
     * @return {?}
     */
    onMouseout() {
        this.hoveredIndex = -1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
}
FuiRating.decorators = [
    { type: Component, args: [{
                selector: 'fui-rating',
                // tslint:disable-next-line
                template: `<i *ngFor="let icon of icons; let i = index" class="icon {{type}}" (mouseover)="onMouseover(i)" (click)="onClick(i)" [class.selected]="hoveredIndex >= i && !isReadonly" [class.active]="value > i"></i>`,
                styles: [`
:host.read-only .icon {
    cursor: auto
}
`]
            }] }
];
/** @nocollapse */
FuiRating.ctorParameters = () => [];
FuiRating.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.rating',] }],
    valueChange: [{ type: Output }],
    isReadonly: [{ type: HostBinding, args: ['class.read-only',] }, { type: Input }],
    type: [{ type: Input }],
    maximum: [{ type: Input }],
    onMouseout: [{ type: HostListener, args: ['mouseout',] }]
};
class FuiRatingValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiRatingValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'fui-rating',
                host: { '(valueChange)': 'onChange($event)' },
                providers: [customValueAccessorFactory(FuiRatingValueAccessor)]
            },] }
];
/** @nocollapse */
FuiRatingValueAccessor.ctorParameters = () => [
    { type: FuiRating }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiRatingModule {
}
FuiRatingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    CommonModule
                ],
                declarations: [
                    FuiRating,
                    FuiRatingValueAccessor
                ],
                exports: [
                    FuiRating,
                    FuiRatingValueAccessor
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiSearchResult {
    /**
     * @param {?} componentFactory
     */
    constructor(componentFactory) {
        this.componentFactory = componentFactory;
        this.hasClasses = true;
        // By default we make this function return an empty string, for the brief moment when it isn't displaying the correct label.
        this.formatter = (/**
         * @param {?} value
         * @return {?}
         */
        value => '');
    }
    /**
     * @return {?}
     */
    get template() {
        return this._template;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    set template(template) {
        this._template = template;
        if (this.template) {
            this.componentFactory.createView(this.templateSibling, this.template, {
                $implicit: this.value,
                query: this.query
            });
        }
    }
}
FuiSearchResult.decorators = [
    { type: Component, args: [{
                selector: 'fui-search-result',
                template: `
<span #templateSibling></span>
<span *ngIf="!template" [innerHTML]="formatter(value, query)"></span>
`
            }] }
];
/** @nocollapse */
FuiSearchResult.ctorParameters = () => [
    { type: FuiComponentFactory }
];
FuiSearchResult.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.result',] }],
    value: [{ type: Input }],
    query: [{ type: Input }],
    formatter: [{ type: Input }],
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
    template: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
class SearchService {
    /**
     * @param {?=} allowEmptyQuery
     */
    constructor(allowEmptyQuery = false) {
        this._options = [];
        this.optionsFilter = (/**
         * @param {?} os
         * @param {?} q
         * @return {?}
         */
        (os, q) => {
            // Convert the query string to a RegExp.
            /** @type {?} */
            const regex = this.toRegex(this._query);
            if (regex instanceof RegExp) {
                // Only update the results if the query was valid regex.
                // This avoids the results suddenly becoming empty if an invalid regex string is inputted.
                return os
                    // Filter on the options with a string match on the field we are testing.
                    .filter((/**
                 * @param {?} o
                 * @return {?}
                 */
                o => Util.Object.readValue(o, this._optionsField)
                    .toString()
                    .match(regex)));
            }
            // Don't update since it wasn't a valid regex.
            return false;
        });
        // Set default values and reset.
        this.allowEmptyQuery = allowEmptyQuery;
        this.searchDelay = 0;
        this.reset();
    }
    /**
     * @return {?}
     */
    get hasItemLookup() {
        return !!this.optionsLookup && this.optionsLookup.length === 2;
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        this._options = options || [];
        // We cannot use both local & remote options simultaneously.
        this._optionsLookup = undefined;
        // Reset entire service with new options.
        this.reset();
    }
    /**
     * @return {?}
     */
    get optionsLookup() {
        return this._optionsLookup;
    }
    /**
     * @param {?} lookupFn
     * @return {?}
     */
    set optionsLookup(lookupFn) {
        this._optionsLookup = lookupFn;
        // As before, cannot use local & remote options simultaneously.
        this._options = [];
        this.reset();
    }
    /**
     * @return {?}
     */
    get optionsField() {
        return this._optionsField;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    set optionsField(field) {
        this._optionsField = field;
        // We need to reset otherwise we would now be showing invalid search results.
        this.reset();
    }
    /**
     * @return {?}
     */
    get results() {
        return this._results;
    }
    /**
     * @return {?}
     */
    get query() {
        return this._query;
    }
    /**
     * @return {?}
     */
    get isSearching() {
        return this._isSearching;
    }
    // Updates the query after the specified search delay.
    /**
     * @param {?} query
     * @param {?=} callback
     * @return {?}
     */
    updateQueryDelayed(query, callback = (/**
     * @return {?}
     */
    () => {
    })) {
        this._query = query;
        clearTimeout(this._searchDelayTimeout);
        this._searchDelayTimeout = window.setTimeout((/**
         * @return {?}
         */
        () => {
            this.updateQuery(query, callback);
        }), this.searchDelay);
    }
    // Updates the current search query.
    /**
     * @param {?} query
     * @param {?=} callback
     * @return {?}
     */
    updateQuery(query, callback = (/**
     * @return {?}
     */
    () => {
    })) {
        this._query = query;
        if (this._query === '' && !this.allowEmptyQuery) {
            // Don't update if the new query is empty (and we don't allow empty queries).
            // Don't reset so that when animating closed we don't get a judder.
            return callback();
        }
        if (this._resultsCache.hasOwnProperty(this._query)) {
            // If the query is already cached, make use of it.
            this._results = this._resultsCache[this._query];
            return callback();
        }
        if (this._optionsLookup) {
            this._isSearching = true;
            // Call the options lookup without a this context.
            /** @type {?} */
            const queryLookup = (/** @type {?} */ (this._optionsLookup.call(undefined, this._query)));
            queryLookup
                .then((/**
             * @param {?} results
             * @return {?}
             */
            results => {
                this._isSearching = false;
                this.updateResults(results);
                return callback();
            }))
                .catch((/**
             * @param {?} error
             * @return {?}
             */
            error => {
                // Unset 'loading' state, and throw the returned error without updating the results.
                this._isSearching = false;
                return callback(error);
            }));
            return;
        }
        /** @type {?} */
        const filtered = this.optionsFilter.call(undefined, this._options, this._query);
        if (filtered) {
            this.updateResults(filtered);
        }
        return callback();
    }
    // tslint:disable-next-line:promise-function-async
    /**
     * @param {?} initial
     * @return {?}
     */
    initialLookup(initial) {
        if (initial instanceof Array) {
            return (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this._optionsLookup)))))(undefined, initial)));
        }
        return (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this._optionsLookup)))))(undefined, initial)));
    }
    // Generates HTML for highlighted match text.
    /**
     * @param {?} text
     * @param {?} query
     * @return {?}
     */
    highlightMatches(text, query) {
        /** @type {?} */
        const regex = this.toRegex(query);
        if (regex instanceof RegExp) {
            return text.replace(regex, (/**
             * @param {?} match
             * @return {?}
             */
            match => `<b>${match}</b>`));
        }
        return text;
    }
    // Updates & caches the new set of results.
    /**
     * @private
     * @param {?} results
     * @return {?}
     */
    updateResults(results) {
        this._resultsCache[this._query] = results;
        this._results = results;
    }
    // Converts a query string to regex without throwing an error.
    /**
     * @private
     * @param {?} query
     * @return {?}
     */
    toRegex(query) {
        try {
            return new RegExp(query, 'i');
        }
        catch (e) {
            return query;
        }
    }
    // Resets the search back to a pristine state.
    /**
     * @private
     * @return {?}
     */
    reset() {
        this._results = [];
        this._resultsCache = {};
        this._isSearching = false;
        this.updateQuery('');
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiSearch {
    /**
     * @param {?} _element
     * @param {?} renderer
     * @param {?} _localizationService
     */
    constructor(_element, renderer, _localizationService) {
        this._element = _element;
        this._localizationService = _localizationService;
        this.dropdownService = new DropdownService();
        this.searchService = new SearchService();
        this.onLocaleUpdate();
        this._localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        () => this.onLocaleUpdate()));
        this.hasClasses = true;
        this.tabindex = 0;
        this.hasIcon = true;
        this.retainSelectedResult = true;
        this.searchDelay = 200;
        this.maxResults = 7;
        this.onResultSelected = new EventEmitter();
        this.transition = 'scale';
        this.transitionDuration = 200;
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this.dropdownService.isOpen;
    }
    /**
     * @return {?}
     */
    get query() {
        return this.searchService.query;
    }
    /**
     * @param {?} query
     * @return {?}
     */
    set query(query) {
        this.selectedResult = undefined;
        // Initialise a delayed search.
        this.searchService.updateQueryDelayed(query, (/**
         * @return {?}
         */
        () => {
            // Set the results open state depending on whether a query has been entered.
            return this.dropdownService.setOpenState(this.searchService.query.length > 0);
        }));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        if (options) {
            this.searchService.options = options;
        }
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    set optionsFilter(filter) {
        if (filter) {
            this.searchService.optionsFilter = filter;
        }
    }
    /**
     * @param {?} lookupFn
     * @return {?}
     */
    set optionsLookup(lookupFn) {
        this.searchService.optionsLookup = lookupFn;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    set optionsField(field) {
        this.searchService.optionsField = field;
    }
    /**
     * @param {?} delay
     * @return {?}
     */
    set searchDelay(delay) {
        this.searchService.searchDelay = delay;
    }
    /**
     * @return {?}
     */
    get isSearching() {
        return this.searchService.isSearching;
    }
    /**
     * @return {?}
     */
    get results() {
        return this.searchService.results.slice(0, this.maxResults);
    }
    // Gets & sets the placeholder text displayed inside the text input.
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder || this.localeValues.placeholder;
    }
    /**
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = placeholder;
    }
    /**
     * @return {?}
     */
    get localeValues() {
        return this._localizationService.override(this._localeValues, this.localeOverrides);
    }
    /**
     * @return {?}
     */
    get resultFormatter() {
        if (this._resultFormatter) {
            return this._resultFormatter;
        }
        else if (this.searchService.optionsLookup) {
            return (/**
             * @param {?} r
             * @return {?}
             */
            r => this.readValue(r));
        }
        else {
            return (/**
             * @param {?} r
             * @param {?} q
             * @return {?}
             */
            (r, q) => this.searchService.highlightMatches(this.readValue(r), q));
        }
    }
    /**
     * @param {?} formatter
     * @return {?}
     */
    set resultFormatter(formatter) {
        this._resultFormatter = formatter;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._menu.service = this.dropdownService;
    }
    // Selects a result.
    /**
     * @param {?} result
     * @return {?}
     */
    select(result) {
        this.onResultSelected.emit(result);
        this.dropdownService.setOpenState(false);
        if (this.retainSelectedResult) {
            this.selectedResult = result;
            this.searchService.updateQuery(this.readValue(result));
        }
        else {
            this.searchService.updateQuery('');
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        this.open();
    }
    /**
     * @return {?}
     */
    onFocusIn() {
        if (!this.dropdownService.isAnimating) {
            this.open();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocusOut(e) {
        console.log(e);
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.dropdownService.setOpenState(false);
        }
    }
    // Reads the specified field from an item.
    /**
     * @param {?} object
     * @return {?}
     */
    readValue(object) {
        return Util.Object.readValue(object, this.searchService.optionsField);
    }
    /**
     * @private
     * @return {?}
     */
    onLocaleUpdate() {
        this._localeValues = this._localizationService.get().search;
    }
    /**
     * @private
     * @return {?}
     */
    open() {
        if (this.searchService.query.length > 0) {
            // Only open on click when there is a query entered.
            this.dropdownService.setOpenState(true);
        }
    }
}
FuiSearch.decorators = [
    { type: Component, args: [{
                selector: 'fui-search',
                template: `
<div class="ui input" [class.icon]="hasIcon" (click)="onClick($event)">
    <input class="prompt" type="text" [attr.placeholder]="placeholder" autocomplete="off" [(ngModel)]="query">
    <i *ngIf="hasIcon" class="search icon"></i>
</div>
<div class="results"
     fuiDropdownMenu
     [menuTransition]="transition"
     [menuTransitionDuration]="transitionDuration"
     menuSelectedItemClass="active">

    <fui-search-result *ngFor="let r of results"
                       class="item"
                       [value]="r"
                       [query]="query"
                       [formatter]="resultFormatter"
                       [template]="resultTemplate"
                       (click)="select(r)"></fui-search-result>

    <div *ngIf="results.length == 0" class="message empty">
        <div class="header">{{ localeValues.noResults.header }}</div>
        <div class="description">{{ localeValues.noResults.message }}</div>
    </div>
</div>
`,
                styles: [`
/* Ensures results div has margin. */
:host {
    display: inline-block;
    outline: 0;
}

/* Fixes positioning when results are pushed above the search. */
.results {
    margin-bottom: .5em;
}
`]
            }] }
];
/** @nocollapse */
FuiSearch.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: FuiLocalizationService }
];
FuiSearch.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.search',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hasIcon: [{ type: Input }],
    resultTemplate: [{ type: Input }],
    retainSelectedResult: [{ type: Input }],
    maxResults: [{ type: Input }],
    onResultSelected: [{ type: Output, args: ['resultSelected',] }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    _menu: [{ type: ViewChild, args: [FuiDropdownMenu, { static: false },] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    options: [{ type: Input }],
    optionsFilter: [{ type: Input }],
    optionsLookup: [{ type: Input }],
    optionsField: [{ type: Input }],
    searchDelay: [{ type: Input }],
    isSearching: [{ type: HostBinding, args: ['class.loading',] }],
    placeholder: [{ type: Input }],
    resultFormatter: [{ type: Input }],
    onFocusIn: [{ type: HostListener, args: ['focusin',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSearchModule {
}
FuiSearchModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FuiDropdownModule,
                    FuiLocalizationModule,
                    FuiUtilityModule
                ],
                declarations: [
                    FuiSearch,
                    FuiSearchResult
                ],
                exports: [
                    FuiSearch
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiSelectOption extends FuiDropdownMenuItem {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(renderer, element, changeDetector) {
        // We inherit FuiDropdownMenuItem to automatically gain all keyboard navigation functionality.
        // This is not done via adding the .item class because it isn't supported by Angular.
        super(renderer, element);
        this.changeDetector = changeDetector;
        this.hasClasses = true;
        this.isActive = false;
        this.onSelected = new EventEmitter();
        // By default we make the default text an empty label, for the brief moment when it isn't displaying the correct one.
        this.renderedText = '';
        this.usesTemplate = false;
    }
    /**
     * @param {?} formatter
     * @return {?}
     */
    set formatter(formatter) {
        if (!this.usesTemplate) {
            this.renderedText = formatter(this.value);
        }
        else {
            this.renderedText = '';
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        e.eventHandled = true;
        setTimeout((/**
         * @return {?}
         */
        () => this.onSelected.emit(this.value)));
    }
}
FuiSelectOption.decorators = [
    { type: Component, args: [{
                selector: 'fui-select-option',
                template: `
<span #templateSibling></span>
<span [innerHTML]="renderedText"></span>
`
            }] }
];
/** @nocollapse */
FuiSelectOption.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiSelectOption.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.item',] }],
    value: [{ type: Input }],
    onSelected: [{ type: Output }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSelectSearch {
    /**
     * @param {?} _renderer
     * @param {?} _element
     */
    constructor(_renderer, _element) {
        this._renderer = _renderer;
        this._element = _element;
        this.onQueryUpdated = new EventEmitter();
        this.onQueryKeyDown = new EventEmitter();
        this.hasClasses = true;
        this.autoComplete = 'off';
    }
    /**
     * @param {?} query
     * @return {?}
     */
    set query(query) {
        this._renderer.setProperty(this._element.nativeElement, 'value', query);
    }
    /**
     * @param {?} query
     * @return {?}
     */
    updateQuery(query) {
        this.onQueryUpdated.emit(query);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        this.onQueryKeyDown.emit(e);
    }
    /**
     * @return {?}
     */
    focus() {
        // Slightly delay to support in menu search.
        this._element.nativeElement.focus();
        setTimeout((/**
         * @return {?}
         */
        () => this._element.nativeElement.focus()));
    }
}
FuiSelectSearch.decorators = [
    { type: Directive, args: [{
                selector: 'input[fuiSelectSearch]'
            },] }
];
/** @nocollapse */
FuiSelectSearch.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FuiSelectSearch.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.search',] }],
    autoComplete: [{ type: HostBinding, args: ['attr.autocomplete',] }],
    updateQuery: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// We use generic type T to smenuTransitionDurationpecify the type of the options we are working with,
// and U to specify the type of the property of the option used as the value.
/**
 * @abstract
 * @template T, U
 */
class FuiSelectBase {
    /**
     * @param {?} _element
     * @param {?} _localizationService
     */
    constructor(_element, _localizationService) {
        this._element = _element;
        this._localizationService = _localizationService;
        this.dropdownService = new DropdownService();
        // We do want an empty query to return all results.
        this.searchService = new SearchService(true);
        this.isSearchable = false;
        this.onLocaleUpdate();
        this._localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        () => this.onLocaleUpdate()));
        this._renderedSubscriptions = [];
        this.icon = 'dropdown';
        this.transition = 'slide down';
        this.transitionDuration = 200;
        this.onTouched = new EventEmitter();
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this.dropdownService.isOpen;
    }
    /**
     * @return {?}
     */
    get isVisible() {
        return this._menu.isVisible;
    }
    /**
     * @return {?}
     */
    get hasSearchClass() {
        return this.isSearchable && !this.isSearchExternal;
    }
    /**
     * @return {?}
     */
    get isSearching() {
        return this.searchService.isSearching;
    }
    /**
     * @return {?}
     */
    get isClearing() {
        return this.isClearable;
    }
    /**
     * @return {?}
     */
    get searchInput() {
        return this._manualSearch || this._internalSearch;
    }
    /**
     * @return {?}
     */
    get tabindex() {
        if (this.isDisabled) {
            // If disabled, remove from tabindex.
            return -1;
        }
        if (this.dropdownService.isOpen && this.isSearchExternal) {
            // If open & in menu search, remove from tabindex (as input always autofocusses).
            return -1;
        }
        if (this._tabIndex != undefined) {
            // If custom tabindex, default to that.
            return this._tabIndex;
        }
        if (this.hasSearchClass) {
            // If search input enabled, tab goes to input.
            return -1;
        }
        // Otherwise, return default of 0.
        return 0;
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        return this.dropdownService.isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isDisabled(value) {
        this.dropdownService.isDisabled = !!value;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        if (options) {
            this.searchService.options = options;
            this.optionsUpdateHook();
        }
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    set optionsFilter(filter) {
        if (filter) {
            this.searchService.optionsFilter = filter;
            this.optionsUpdateHook();
        }
    }
    /**
     * @param {?} lookup
     * @return {?}
     */
    set optionsLookup(lookup) {
        if (lookup) {
            this.searchService.optionsLookup = lookup;
            this.optionsUpdateHook();
        }
    }
    /**
     * @return {?}
     */
    get filteredOptions() {
        return this.searchService.results;
    }
    // Deprecated
    /**
     * @return {?}
     */
    get availableOptions() {
        return this.filteredOptions;
    }
    /**
     * @return {?}
     */
    get query() {
        return this.isSearchable ? this.searchService.query : undefined;
    }
    /**
     * @param {?} query
     * @return {?}
     */
    set query(query) {
        if (query != undefined) {
            this.queryUpdateHook();
            this.updateQuery(query);
            // Update the rendered text as query has changed.
            this._renderedOptions.forEach((/**
             * @param {?} ro
             * @return {?}
             */
            ro => this.initialiseRenderedOption(ro)));
            if (this.searchInput) {
                this.searchInput.query = query;
            }
        }
    }
    /**
     * @return {?}
     */
    get labelField() {
        return this.searchService.optionsField;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    set labelField(field) {
        this.searchService.optionsField = field;
    }
    /**
     * @return {?}
     */
    get labelGetter() {
        // Helper function to retrieve the label from an item.
        return (/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => {
            /** @type {?} */
            const label = Util.Object.readValue(obj, this.labelField);
            if (label != undefined) {
                return label.toString();
            }
            return '';
        });
    }
    /**
     * @return {?}
     */
    get valueGetter() {
        // Helper function to retrieve the value from an item.
        return (/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => Util.Object.readValue(obj, this.valueField));
    }
    /**
     * @return {?}
     */
    get configuredFormatter() {
        if (this._optionFormatter) {
            return (/**
             * @param {?} o
             * @return {?}
             */
            o => (/** @type {?} */ (this._optionFormatter))(o, this.isSearchable ? this.query : undefined));
        }
        else if (this.searchService.optionsLookup) {
            return (/**
             * @param {?} o
             * @return {?}
             */
            o => this.labelGetter(o));
        }
        else {
            return (/**
             * @param {?} o
             * @return {?}
             */
            o => this.searchService.highlightMatches(this.labelGetter(o), this.query || ''));
        }
    }
    /**
     * @param {?} formatter
     * @return {?}
     */
    set optionFormatter(formatter) {
        this._optionFormatter = formatter;
    }
    /**
     * @return {?}
     */
    get localeValues() {
        return this._localizationService.override(this._localeValues, this.localeOverrides);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._menu.service = this.dropdownService;
        // We manually specify the menu items to the menu because the @ContentChildren doesn't pick up our dynamically rendered items.
        this._menu.items = this._renderedOptions;
        this._menu.parentElement = this._element;
        if (this._manualSearch) {
            this.isSearchable = true;
            this.isSearchExternal = true;
        }
        if (this.searchInput) {
            this.searchInput.onQueryUpdated.subscribe((/**
             * @param {?} q
             * @return {?}
             */
            (q) => this.query = q));
            this.searchInput.onQueryKeyDown.subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => this.onQueryInputKeydown(e)));
        }
        // We must call this immediately as changes doesn't fire when you subscribe.
        this.onAvailableOptionsRendered();
        this._renderedOptions.changes.subscribe((/**
         * @return {?}
         */
        () => this.onAvailableOptionsRendered()));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onCaretClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            if (!this.dropdownService.isAnimating) {
                this.dropdownService.setOpenState(!this.dropdownService.isOpen);
                this.focus();
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        if (!e.eventHandled && !this.dropdownService.isAnimating) {
            e.eventHandled = true;
            // If the dropdown is searchable, clicking should keep it open, otherwise we toggle the open state.
            this.dropdownService.setOpenState(this.isSearchable ? true : !this.dropdownService.isOpen);
            // Immediately focus the search input whenever clicking on the select.
            this.focus();
        }
    }
    /**
     * @return {?}
     */
    onFocusIn() {
        if (!this.dropdownService.isOpen && !this.dropdownService.isAnimating) {
            this.dropdownService.setOpenState(true);
            this.focus();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocusOut(e) {
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.dropdownService.setOpenState(false);
            this.onTouched.emit();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyPress(e) {
        if (e.keyCode === KeyCode.Enter) {
            // Enables support for focussing and opening with the keyboard alone.
            // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
            this._element.nativeElement.click();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        if (!this.dropdownService.isOpen && e.keyCode === KeyCode.Down) {
            // Enables support for focussing and opening with the keyboard alone.
            // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
            this._element.nativeElement.click();
            e.preventDefault();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onQueryInputKeydown(event) {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._renderedSubscriptions.forEach((/**
         * @param {?} s
         * @return {?}
         */
        s => s.unsubscribe()));
    }
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    /**
     * @protected
     * @return {?}
     */
    optionsUpdateHook() {
    }
    // Hook is here since Typescript doesn't yet support overriding getters & setters while still calling the superclass.
    /**
     * @protected
     * @return {?}
     */
    queryUpdateHook() {
    }
    /**
     * @protected
     * @param {?} query
     * @return {?}
     */
    updateQuery(query) {
        // Update the query then open the dropdown, as after keyboard input it should always be open.
        this.searchService.updateQuery(query, (/**
         * @return {?}
         */
        () => this.dropdownService.setOpenState(true)));
    }
    /**
     * @protected
     * @param {?=} delayed
     * @return {?}
     */
    resetQuery(delayed = true) {
        // The search delay is set to the transition duration to ensure results
        // aren't rendered as the select closes as that causes a sudden flash.
        if (delayed) {
            this.searchService.searchDelay = this._menu.menuTransitionDuration;
            this.searchService.updateQueryDelayed('');
        }
        else {
            this.searchService.updateQuery('');
        }
        if (this.searchInput) {
            this.searchInput.query = '';
        }
    }
    /**
     * @protected
     * @return {?}
     */
    onAvailableOptionsRendered() {
        // Unsubscribe from all previous subscriptions to avoid memory leaks on large selects.
        this._renderedSubscriptions.forEach((/**
         * @param {?} rs
         * @return {?}
         */
        rs => rs.unsubscribe()));
        this._renderedSubscriptions = [];
        this._renderedOptions.forEach((/**
         * @param {?} ro
         * @return {?}
         */
        ro => {
            // Slightly delay initialisation to avoid change after checked errors. TODO - look into avoiding this!
            setTimeout((/**
             * @return {?}
             */
            () => this.initialiseRenderedOption(ro)));
            this._renderedSubscriptions.push(ro.onSelected.subscribe((/**
             * @return {?}
             */
            () => this.selectOption(ro.value))));
        }));
        // If no options have been provided, autogenerate them from the rendered ones.
        if (this.searchService.options.length === 0 && !this.searchService.optionsLookup) {
            this.options = this._renderedOptions.map((/**
             * @param {?} ro
             * @return {?}
             */
            ro => ro.value));
        }
    }
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    initialiseRenderedOption(option) {
        option.usesTemplate = !!this.optionTemplate;
        option.formatter = this.configuredFormatter;
        if (option.usesTemplate) {
            this.drawTemplate(option.templateSibling, option.value);
        }
        option.changeDetector.markForCheck();
    }
    /**
     * @protected
     * @param {?} options
     * @param {?} value
     * @return {?}
     */
    findOption(options, value) {
        // Tries to find an option in options array
        return options.find((/**
         * @param {?} o
         * @return {?}
         */
        o => value === this.valueGetter(o)));
    }
    /**
     * @protected
     * @return {?}
     */
    focus() {
        if (this.isSearchable && this.searchInput) {
            // Focusses the search input only when searchable.
            // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
            this.searchInput.focus();
        }
        else {
            this._element.nativeElement.focus();
        }
    }
    // Helper that draws the provided template beside the provided ViewContainerRef.
    /**
     * @protected
     * @param {?} siblingRef
     * @param {?} value
     * @return {?}
     */
    drawTemplate(siblingRef, value) {
        siblingRef.clear();
        // Use of `$implicit` means use of <ng-template let-option> syntax is supported.
        siblingRef.createEmbeddedView(this.optionTemplate, {
            $implicit: value,
            query: this.query
        });
    }
    /**
     * @private
     * @return {?}
     */
    onLocaleUpdate() {
        this._localeValues = this._localizationService.get().select;
    }
}
FuiSelectBase.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.dropdown',] }],
    isClearable: [{ type: Input }],
    isSearchable: [{ type: Input }],
    valueField: [{ type: Input }],
    optionTemplate: [{ type: Input }],
    icon: [{ type: Input }],
    transition: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    onTouched: [{ type: Output, args: ['touched',] }],
    _menu: [{ type: ViewChild, args: [FuiDropdownMenu, { static: true },] }],
    _renderedOptions: [{ type: ContentChildren, args: [FuiSelectOption, { descendants: true },] }],
    _internalSearch: [{ type: ViewChild, args: [FuiSelectSearch, { static: false },] }],
    _manualSearch: [{ type: ContentChild, args: [FuiSelectSearch, { static: false },] }],
    _tabIndex: [{ type: Input, args: ['tabindex',] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    isVisible: [{ type: HostBinding, args: ['class.visible',] }],
    hasSearchClass: [{ type: HostBinding, args: ['class.search',] }],
    isSearching: [{ type: HostBinding, args: ['class.loading',] }],
    isClearing: [{ type: HostBinding, args: ['class.clearable',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    options: [{ type: Input }],
    optionsFilter: [{ type: Input }],
    optionsLookup: [{ type: Input }],
    labelField: [{ type: Input }],
    optionFormatter: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onFocusIn: [{ type: HostListener, args: ['focusin',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }],
    onKeyPress: [{ type: HostListener, args: ['keypress', ['$event'],] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FuiMultiSelectLabel extends FuiTransition {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     * @param {?} componentFactory
     */
    constructor(renderer, element, changeDetector, componentFactory) {
        super(renderer, element, changeDetector);
        this.componentFactory = componentFactory;
        // Initialise transition functionality.
        this._transitionController = new TransitionController(false, 'inline-block');
        this.setTransitionController(this._transitionController);
        this.onDeselected = new EventEmitter();
        this.hasClasses = true;
        this._transitionController.animate(new Transition('scale', 100, TransitionDirection.In));
    }
    /**
     * @return {?}
     */
    get template() {
        return this._template;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    set template(template) {
        this._template = template;
        if (this.template) {
            this.componentFactory.createView(this.templateSibling, this.template, {
                $implicit: this.value,
                query: this.query
            });
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    deselectOption(e) {
        e.eventHandled = true;
        this._transitionController.animate(new Transition('scale', 100, TransitionDirection.Out, (/**
         * @return {?}
         */
        () => this.onDeselected.emit(this.value))));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        e.eventHandled = true;
    }
}
FuiMultiSelectLabel.decorators = [
    { type: Component, args: [{
                selector: 'fui-multi-select-label',
                template: `
<span #templateSibling></span>
<span *ngIf="!template" [innerHTML]="formatter(value)"></span>
<i class="delete icon" (click)="deselectOption($event)"></i>
`
            }] }
];
/** @nocollapse */
FuiMultiSelectLabel.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: FuiComponentFactory }
];
FuiMultiSelectLabel.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.label',] }],
    value: [{ type: Input }],
    query: [{ type: Input }],
    onDeselected: [{ type: Output, args: ['deselected',] }],
    formatter: [{ type: Input }],
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
    template: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
class FuiMultiSelect extends FuiSelectBase {
    /**
     * @param {?} element
     * @param {?} localizationService
     */
    constructor(element, localizationService) {
        super(element, localizationService);
        this.selectedOptions = [];
        this.selectedOptionsChange = new EventEmitter();
        this.hasLabels = true;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get filteredOptions() {
        if (this.maxSelectedReached) {
            // If we have reached the maximum number of selections, then empty the results completely.
            return [];
        }
        /** @type {?} */
        const searchResults = this.searchService.results;
        if (!this.hasLabels) {
            return searchResults;
        }
        else {
            // Returns the search results \ selected options.
            return searchResults
                .filter((/**
             * @param {?} r
             * @return {?}
             */
            r => this.selectedOptions.find((/**
             * @param {?} o
             * @return {?}
             */
            o => r === o)) == undefined));
        }
    }
    /**
     * @return {?}
     */
    get availableOptions() {
        return this.filteredOptions;
    }
    /**
     * @return {?}
     */
    get maxSelectedReached() {
        if (this.maxSelected == undefined) {
            // If there is no maximum then we can immediately return.
            return false;
        }
        return this.selectedOptions.length === this.maxSelected;
    }
    /**
     * @return {?}
     */
    get maxSelectedMessage() {
        return this._localizationService.interpolate(this.localeValues.multi.maxSelectedMessage, [['max', this.maxSelected.toString()]]);
    }
    /**
     * @return {?}
     */
    get selectedMessage() {
        return this._localizationService.interpolate(this.localeValues.multi.selectedMessage, [['count', this.selectedOptions.length.toString() === '0' && this._showCountText ?
                    this._showCountText : this.selectedOptions.length.toString()]]);
    }
    /**
     * @return {?}
     */
    get hasLabels() {
        return this._hasLabels;
    }
    /**
     * @param {?} hasLabels
     * @return {?}
     */
    set hasLabels(hasLabels) {
        this._hasLabels = hasLabels;
    }
    /**
     * @return {?}
     */
    get showCountText() {
        return this._showCountText;
    }
    /**
     * @param {?} showCountText
     * @return {?}
     */
    set showCountText(showCountText) {
        this._showCountText = showCountText;
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder || this.localeValues.multi.placeholder;
    }
    /**
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = placeholder;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    selectOption(option) {
        if (this.selectedOptions.indexOf(option) !== -1) {
            this.deselectOption(option);
            return;
        }
        this.selectedOptions.push(option);
        this.selectedOptionsChange.emit(this.selectedOptions.map((/**
         * @param {?} o
         * @return {?}
         */
        o => this.valueGetter(o))));
        this.resetQuery(false);
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
        if (!this.hasLabels) {
            this.onAvailableOptionsRendered();
        }
    }
    /**
     * @param {?} values
     * @return {?}
     */
    writeValue(values) {
        if (values instanceof Array) {
            if (this.searchService.options.length > 0) {
                // If the options have already been loaded, we can immediately match the ngModel values to options.
                this.selectedOptions = values
                    // non-null assertion added here because Typescript doesn't recognise the non-null filter.
                    .map((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => (/** @type {?} */ (this.findOption(this.searchService.options, v)))))
                    .filter((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => v != undefined));
            }
            if (values.length > 0 && this.selectedOptions.length === 0) {
                if (this.searchService.hasItemLookup) {
                    // If the search service has a selected lookup function, make use of that to load the initial values.
                    this.searchService
                        .initialLookup(values)
                        .then((/**
                     * @param {?} items
                     * @return {?}
                     */
                    items => this.selectedOptions = items));
                }
                else {
                    // Otherwise, cache the written value for when options are set.
                    this._writtenOptions = values;
                }
            }
            if (values.length === 0) {
                this.selectedOptions = [];
            }
        }
        else {
            this.selectedOptions = [];
        }
    }
    /**
     * @param {?} option
     * @return {?}
     */
    deselectOption(option) {
        // Update selected options to the previously selected options \ {option}.
        this.selectedOptions = this.selectedOptions.filter((/**
         * @param {?} so
         * @return {?}
         */
        so => so !== option));
        this.selectedOptionsChange.emit(this.selectedOptions.map((/**
         * @param {?} o
         * @return {?}
         */
        o => this.valueGetter(o))));
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
        if (!this.hasLabels) {
            this.onAvailableOptionsRendered();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onQueryInputKeydown(event) {
        if (event.keyCode === KeyCode.Backspace && this.query === '' && this.selectedOptions.length > 0) {
            // Deselect the rightmost option when the user presses backspace in the search input.
            this.deselectOption(this.selectedOptions[this.selectedOptions.length - 1]);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    optionsUpdateHook() {
        if (!this._writtenOptions && this.selectedOptions.length > 0) {
            // We need to check the options still exist.
            this.writeValue(this.selectedOptions.map((/**
             * @param {?} o
             * @return {?}
             */
            o => this.valueGetter(o))));
        }
        if (this._writtenOptions && this.searchService.options.length > 0) {
            // If there were values written by ngModel before the options had been loaded, this runs to fix it.
            this.selectedOptions = this._writtenOptions
                // non-null assertion added here because Typescript doesn't recognise the non-null filter.
                .map((/**
             * @param {?} v
             * @return {?}
             */
            v => (/** @type {?} */ (this.findOption(this.searchService.options, v)))))
                .filter((/**
             * @param {?} v
             * @return {?}
             */
            v => v != undefined));
            if (this.selectedOptions.length === this._writtenOptions.length) {
                this._writtenOptions = undefined;
            }
        }
    }
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    initialiseRenderedOption(option) {
        super.initialiseRenderedOption(option);
        // Boldens the item so it appears selected in the dropdown.
        option.isActive = !this.hasLabels && this.selectedOptions.indexOf(option.value) !== -1;
    }
}
FuiMultiSelect.decorators = [
    { type: Component, args: [{
                selector: 'fui-multi-select',
                template: `
<!-- Dropdown icon -->
<i class="{{ icon }} icon" (click)="onCaretClick($event)"></i>

<ng-container *ngIf="hasLabels">
<!-- Multi-select labels -->
    <fui-multi-select-label *ngFor="let selected of selectedOptions;"
                            [value]="selected"
                            [query]="query"
                            [formatter]="configuredFormatter"
                            [template]="optionTemplate"
                            (deselected)="deselectOption($event)"></fui-multi-select-label>
</ng-container>

<!-- Query input -->
<input fuiSelectSearch
       type="text"
       [hidden]="!isSearchable || isSearchExternal">

<!-- Helper text -->
<div class="text"
     [class.default]="hasLabels"
     [class.filtered]="!!query && !isSearchExternal">

    <!-- Placeholder text -->
    <ng-container *ngIf="hasLabels; else selectedBlock">{{ placeholder }}</ng-container>

    <!-- Summary shown when labels are hidden -->
    <ng-template #selectedBlock> {{ selectedMessage }}</ng-template>
</div>

<!-- Select dropdown menu -->
<div class="menu"
     fuiDropdownMenu
     [menuTransition]="transition"
     [menuTransitionDuration]="transitionDuration"
     [menuAutoSelectFirst]="true">

    <ng-content></ng-content>
    <ng-container *ngIf="availableOptions.length == 0 ">
        <div *ngIf="!maxSelectedReached" class="message">{{ localeValues.noResultsMessage }}</div>
        <div *ngIf="maxSelectedReached" class="message">{{ maxSelectedMessage }}</div>
    </ng-container>
</div>
`,
                styles: [`
:host input.search {
    width: 12em !important;
}
`]
            }] }
];
/** @nocollapse */
FuiMultiSelect.ctorParameters = () => [
    { type: ElementRef },
    { type: FuiLocalizationService }
];
FuiMultiSelect.propDecorators = {
    selectedOptionsChange: [{ type: Output }],
    maxSelected: [{ type: Input }],
    hasClasses: [{ type: HostBinding, args: ['class.multiple',] }],
    hasLabels: [{ type: Input }],
    showCountText: [{ type: Input }],
    placeholder: [{ type: Input }]
};
// Value accessor directive for the select to support ngModel.
/**
 * @template T, U
 */
class FuiMultiSelectValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiMultiSelectValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'fui-multi-select',
                host: {
                    '(selectedOptionsChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiMultiSelectValueAccessor)]
            },] }
];
/** @nocollapse */
FuiMultiSelectValueAccessor.ctorParameters = () => [
    { type: FuiMultiSelect }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
class FuiSelect extends FuiSelectBase {
    /**
     * @param {?} element
     * @param {?} localizationService
     */
    constructor(element, localizationService) {
        super(element, localizationService);
        this.selectedOptionChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder || this.localeValues.single.placeholder;
    }
    /**
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = placeholder;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    selectOption(option) {
        // Choose and emit the selected option.
        this.selectedOption = option;
        this.selectedOptionChange.emit(this.valueGetter(option));
        this.dropdownService.setOpenState(false);
        this.resetQuery();
        this.drawSelectedOption();
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value != undefined) {
            if (this.searchService.options.length > 0) {
                // If the options have already been loaded, we can immediately match the ngModel value to an option.
                this.selectedOption = this.findOption(this.searchService.options, value);
                this.drawSelectedOption();
            }
            if (this.selectedOption == undefined) {
                if (this.valueField && this.searchService.hasItemLookup) {
                    // If the search service has a selected lookup function, make use of that to load the initial value.
                    this.searchService
                        .initialLookup(value)
                        .then((/**
                     * @param {?} i
                     * @return {?}
                     */
                    i => {
                        this.selectedOption = i;
                        this.drawSelectedOption();
                    }));
                }
                else {
                    // Otherwise, cache the written value for when options are set.
                    this._writtenOption = value;
                }
            }
        }
        else {
            this.selectedOption = undefined;
            this.drawSelectedOption();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onRemoveClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            this.selectedOption = undefined;
            this.selectedOptionChange.emit(undefined);
            this._renderedOptions.forEach((/**
             * @param {?} o
             * @return {?}
             */
            o => o.isActive = false));
        }
    }
    /**
     * @protected
     * @return {?}
     */
    optionsUpdateHook() {
        if (!this._writtenOption && this.selectedOption) {
            // We need to check the option still exists.
            this.writeValue(this.valueGetter(this.selectedOption));
        }
        if (this._writtenOption && this.searchService.options.length > 0) {
            // If there was an value written by ngModel before the options had been loaded, this runs to fix it.
            this.selectedOption = this.findOption(this.searchService.options, this._writtenOption);
            if (this.selectedOption) {
                this._writtenOption = undefined;
                this.drawSelectedOption();
            }
        }
    }
    /**
     * @protected
     * @return {?}
     */
    queryUpdateHook() {
        // When the query is updated, we just abandon the current selection.
        this.selectedOption = undefined;
    }
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    initialiseRenderedOption(option) {
        super.initialiseRenderedOption(option);
        // Boldens the item so it appears selected in the dropdown.
        option.isActive = option.value === this.selectedOption;
    }
    /**
     * @private
     * @return {?}
     */
    drawSelectedOption() {
        // Updates the active class on the newly selected option.
        if (this._renderedOptions) {
            this.onAvailableOptionsRendered();
        }
        if (this.selectedOption != undefined && this.optionTemplate) {
            this.drawTemplate(this._optionTemplateSibling, this.selectedOption);
        }
    }
}
FuiSelect.decorators = [
    { type: Component, args: [{
                selector: 'fui-select',
                template: `
                   <!-- Query input -->
                   <input fuiSelectSearch
                          type="text"
                          [hidden]="!isSearchable || isSearchExternal">

                   <!-- Placeholder text -->
                   <div *ngIf="selectedOption == undefined" class="default text" [class.filtered]="query">{{ placeholder }}</div>
                   <!-- Selected item -->
                   <div class="text" [class.filtered]="query || selectedOption == undefined">
                       <span #optionTemplateSibling></span>
                       <span *ngIf="!optionTemplate && selectedOption != undefined"
                             [innerHTML]="configuredFormatter(selectedOption)"></span>
                   </div>
                   <!-- Dropdown icon -->
                   <i *ngIf="selectedOption && !isSearching && isClearable" class="times icon"
                      (click)="onRemoveClick($event)"></i>
                   <i *ngIf="!selectedOption || !isClearable" class="{{ icon }} icon" (click)="onCaretClick($event)"></i>
                   <!-- Select dropdown menu -->
                   <div class="menu"
                        fuiDropdownMenu
                        [menuTransition]="transition"
                        [menuTransitionDuration]="transitionDuration"
                        [menuAutoSelectFirst]="isSearchable">

                       <ng-content></ng-content>
                       <div *ngIf="isSearchable && availableOptions.length === 0" class="message">
                           {{ localeValues.noResultsMessage }}
                       </div>
                   </div>
               `,
                styles: [`
                   :host .times.icon {
                       position: absolute;
                       width: auto;
                       height: auto;
                       line-height: 1.21428571em;
                       top: .78571429em;
                       right: 1em;
                       margin: -.78571429em;
                       opacity: .6;
                       font-size: 1.07142857em;
                       padding: .6em;
                       -webkit-transition: opacity .1s ease;
                       transition: opacity .1s ease;
                       z-index: 3;
                   }

                   :host .times.icon.larger {
                       padding: .91666667em;
                       font-size: .85714286em;
                   }

                   :host .times.icon:hover {
                       opacity: 1;
                   }
               `]
            }] }
];
/** @nocollapse */
FuiSelect.ctorParameters = () => [
    { type: ElementRef },
    { type: FuiLocalizationService }
];
FuiSelect.propDecorators = {
    selectedOptionChange: [{ type: Output }],
    _optionTemplateSibling: [{ type: ViewChild, args: ['optionTemplateSibling', { read: ViewContainerRef, static: false },] }],
    placeholder: [{ type: Input }]
};
// Value accessor directive for the select to support ngModel.
/**
 * @template T, U
 */
class FuiSelectValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiSelectValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'fui-select',
                host: {
                    '(selectedOptionChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiSelectValueAccessor)]
            },] }
];
/** @nocollapse */
FuiSelectValueAccessor.ctorParameters = () => [
    { type: FuiSelect }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSelectModule {
}
FuiSelectModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FuiDropdownModule,
                    FuiUtilityModule,
                    FuiLocalizationModule
                ],
                declarations: [
                    FuiSelect,
                    FuiSelectOption,
                    FuiSelectSearch,
                    FuiSelectValueAccessor,
                    FuiMultiSelect,
                    FuiMultiSelectLabel,
                    FuiMultiSelectValueAccessor
                ],
                exports: [
                    FuiSelect,
                    FuiSelectOption,
                    FuiSelectSearch,
                    FuiSelectValueAccessor,
                    FuiMultiSelect,
                    FuiMultiSelectValueAccessor
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SidebarTransition = {
    Overlay: (/** @type {?} */ ('overlay')),
    Push: (/** @type {?} */ ('push')),
    ScaleDown: (/** @type {?} */ ('scale down')),
    Uncover: (/** @type {?} */ ('uncover')),
    SlideAlong: (/** @type {?} */ ('slide along')),
    SlideOut: (/** @type {?} */ ('slide out'))
};
/** @type {?} */
const SidebarDirection = {
    Left: (/** @type {?} */ ('left')),
    Right: (/** @type {?} */ ('right')),
    Top: (/** @type {?} */ ('top')),
    Bottom: (/** @type {?} */ ('bottom'))
};
class SidebarService {
    /**
     * @param {?=} isVisible
     */
    constructor(isVisible = false) {
        this.isVisible = isVisible;
        this.isAnimating = false;
        this.wasJustOpened = false;
        this.isVisibleChange = new EventEmitter();
        this.widthChange = new EventEmitter();
        this.heightChange = new EventEmitter();
        this.width = 260;
        this.height = 0;
        this.transition = SidebarTransition.Uncover;
    }
    /**
     * @return {?}
     */
    get width() {
        if (this.direction === SidebarDirection.Left) {
            return this._width;
        }
        if (this.direction === SidebarDirection.Right) {
            return -this._width;
        }
        return 0;
    }
    /**
     * @param {?} width
     * @return {?}
     */
    set width(width) {
        this._width = width;
        this.widthChange.emit();
    }
    /**
     * @return {?}
     */
    get height() {
        if (this.direction === SidebarDirection.Top) {
            return this._height;
        }
        if (this.direction === SidebarDirection.Bottom) {
            return -this._height;
        }
        return 0;
    }
    /**
     * @param {?} height
     * @return {?}
     */
    set height(height) {
        this._height = height;
        this.heightChange.emit();
    }
    /**
     * @param {?} isVisible
     * @return {?}
     */
    setVisibleState(isVisible) {
        if (this.isVisible !== isVisible) {
            this.isVisible = isVisible;
            this.isAnimating = true;
            this.wasJustOpened = true;
            this.isVisibleChange.emit(isVisible);
            setTimeout((/**
             * @return {?}
             */
            () => this.wasJustOpened = false));
            clearTimeout(this._isAnimatingTimeout);
            this._isAnimatingTimeout = window.setTimeout((/**
             * @return {?}
             */
            () => this.isAnimating = false), 500);
        }
    }
    /**
     * @return {?}
     */
    toggleVisibleState() {
        this.setVisibleState(!this.isVisible);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSidebar {
    /**
     * @param {?} _renderer
     * @param {?} _element
     */
    constructor(_renderer, _element) {
        this._renderer = _renderer;
        this._element = _element;
        this.service = new SidebarService();
        // We set the default here as well to force the classes to update.
        this.transition = SidebarTransition.Uncover;
        this.direction = SidebarDirection.Left;
        setTimeout((/**
         * @return {?}
         */
        () => this.updateDimensions()));
        this.service.isVisibleChange.subscribe((/**
         * @return {?}
         */
        () => this.updateDimensions()));
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get transition() {
        return this.service.transition;
    }
    /**
     * @param {?} transition
     * @return {?}
     */
    set transition(transition) {
        this.service.transition.split(' ').forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this.setClass(c, false)));
        this.service.transition = transition;
        this.service.transition.split(' ').forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => this.setClass(c, true)));
    }
    /**
     * @return {?}
     */
    get direction() {
        return this.service.direction;
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    set direction(direction) {
        this.setClass(this.service.direction, false);
        this.service.direction = direction;
        this.setClass(this.service.direction, true);
    }
    /**
     * @return {?}
     */
    get isVisible() {
        return this.service.isVisible;
    }
    /**
     * @param {?} isVisible
     * @return {?}
     */
    set isVisible(isVisible) {
        this.service.setVisibleState(isVisible);
    }
    /**
     * @return {?}
     */
    get isVisibleChange() {
        return this.service.isVisibleChange;
    }
    /**
     * @return {?}
     */
    get isAnimating() {
        return this.service.isAnimating;
    }
    /**
     * @return {?}
     */
    open() {
        this.service.setVisibleState(true);
    }
    /**
     * @return {?}
     */
    close() {
        this.service.setVisibleState(false);
    }
    /**
     * @return {?}
     */
    toggle() {
        this.service.toggleVisibleState();
    }
    /**
     * @private
     * @return {?}
     */
    updateDimensions() {
        this.service.width = this._element.nativeElement.offsetWidth;
        this.service.height = this._element.nativeElement.offsetHeight;
    }
    /**
     * @private
     * @param {?} className
     * @param {?=} isAdd
     * @return {?}
     */
    setClass(className, isAdd = true) {
        if (isAdd) {
            this._renderer.addClass(this._element.nativeElement, className);
        }
        else {
            this._renderer.removeClass(this._element.nativeElement, className);
        }
    }
}
FuiSidebar.decorators = [
    { type: Component, args: [{
                selector: 'fui-sidebar',
                template: `<ng-content></ng-content>`
            }] }
];
/** @nocollapse */
FuiSidebar.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FuiSidebar.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.sidebar',] }, { type: HostBinding, args: ['class.menu',] }],
    transition: [{ type: Input }],
    direction: [{ type: Input }],
    isVisible: [{ type: HostBinding, args: ['class.visible',] }, { type: Input }],
    isVisibleChange: [{ type: Output }],
    isAnimating: [{ type: HostBinding, args: ['class.animating',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSidebarSibling {
    /**
     * @param {?} _renderer
     * @param {?} _element
     */
    constructor(_renderer, _element) {
        this._renderer = _renderer;
        this._element = _element;
        this.canCloseSidebar = true;
        this.isDimmedWhenVisible = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get isVisible() {
        if (!this.service) {
            return false;
        }
        return this.service.isVisible;
    }
    /**
     * @return {?}
     */
    get isDimmed() {
        if (!this.service) {
            return false;
        }
        return this.service.isVisible && this.isDimmedWhenVisible;
    }
    /**
     * @return {?}
     */
    get service() {
        return this._service;
    }
    /**
     * @param {?} service
     * @return {?}
     */
    set service(service) {
        this._service = service;
        setTimeout((/**
         * @return {?}
         */
        () => this.updateTransform()));
        this._service.isVisibleChange.subscribe((/**
         * @return {?}
         */
        () => this.updateTransform()));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.canCloseSidebar && this.service.isVisible && !this.service.wasJustOpened) {
            this.service.setVisibleState(false);
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateTransform() {
        this._renderer.removeStyle(this._element.nativeElement, 'transform');
        this._renderer.removeStyle(this._element.nativeElement, '-webkit-transform');
        if (this.service.isVisible &&
            this.service.transition !== SidebarTransition.Overlay &&
            this.service.transition !== SidebarTransition.ScaleDown) {
            /** @type {?} */
            const translate = `translate3d(${this.service.width}px, ${this.service.height}px, 0)`;
            this._renderer.setStyle(this._element.nativeElement, 'transform', translate);
            this._renderer.setStyle(this._element.nativeElement, '-webkit-transform', translate);
        }
    }
}
FuiSidebarSibling.decorators = [
    { type: Component, args: [{
                selector: 'fui-sidebar-sibling',
                template: `
                   <ng-content></ng-content>`,
                styles: [`
                   :host {
                       display: block;
                   }
               `]
            }] }
];
/** @nocollapse */
FuiSidebarSibling.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FuiSidebarSibling.propDecorators = {
    isDimmedWhenVisible: [{ type: Input }],
    hasClasses: [{ type: HostBinding, args: ['class.pusher',] }],
    canCloseSidebar: [{ type: Input }],
    isVisible: [{ type: HostBinding, args: ['class.visible',] }],
    isDimmed: [{ type: HostBinding, args: ['class.dimmed',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSidebarContainer {
    constructor() {
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.sidebar) {
            throw new Error('You must include a <fui-sidebar> element within the container.');
        }
        this.service = this.sidebar.service;
        if (!this.sibling) {
            throw new Error('You must include a <fui-sidebar-sibling> element within the container.');
        }
        this.sibling.service = this.service;
    }
}
FuiSidebarContainer.decorators = [
    { type: Component, args: [{
                selector: 'fui-sidebar-container',
                template: `<ng-content></ng-content>`,
                styles: [`
:host {
    display: block;
}
`]
            }] }
];
/** @nocollapse */
FuiSidebarContainer.ctorParameters = () => [];
FuiSidebarContainer.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.pushable',] }],
    sidebar: [{ type: ContentChild, args: [FuiSidebar, { static: false },] }],
    sibling: [{ type: ContentChild, args: [FuiSidebarSibling, { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiSidebarModule {
}
FuiSidebarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiSidebar,
                    FuiSidebarContainer,
                    FuiSidebarSibling
                ],
                exports: [
                    FuiSidebar,
                    FuiSidebarContainer,
                    FuiSidebarSibling
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Tab {
    /**
     * @param {?} header
     * @param {?} content
     */
    constructor(header, content) {
        this.id = header.id;
        this.header = header;
        this.content = content;
        // So that the header and content isActive properties are always in sync.
        this.header.isActiveChange
            .subscribe((/**
         * @return {?}
         */
        () => this.content.isActive = this.isActive));
    }
    // Saves accessing .header.isActive every time.
    /**
     * @return {?}
     */
    get isActive() {
        return this.header.isActive;
    }
    /**
     * @param {?} active
     * @return {?}
     */
    set isActive(active) {
        // Use `setActiveState` so as not to fire 'external changes' event.
        this.header.setActiveState(active);
    }
    // Saves accessing .header.isDisabled every time.
    /**
     * @return {?}
     */
    get isDisabled() {
        return this.header.isDisabled;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTabHeader {
    constructor() {
        this._isActive = false;
        this.isActiveChange = new EventEmitter();
        this.isActiveExternalChange = new EventEmitter();
        this.onActivate = new EventEmitter();
        this.onDeactivate = new EventEmitter();
        this.isDisabled = false;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this._isActive;
    }
    /**
     * @param {?} active
     * @return {?}
     */
    set isActive(active) {
        /** @type {?} */
        let isActive = active;
        // Only used by @Input(), runs whenever user input changes `isActive`.
        // Run in timeout because `isDisabled` can prohibit user from changing `isActive`.
        // so update is delayed to avoid 'changed after checked' error.
        setTimeout((/**
         * @return {?}
         */
        () => {
            // Only allow change if tab header is not disabled.
            isActive = !this.isDisabled ? active : false;
            this.setActiveState(isActive);
            // Fire 'external change' event as user input has occured.
            this.isActiveExternalChange.emit(isActive);
        }));
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        return this._isDisabled;
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    set isDisabled(disabled) {
        // Only update if value provided is different to current one.
        if (this._isDisabled !== disabled) {
            this._isDisabled = disabled;
            // If now disabled, then tab header must be deactivated.
            if (this.isDisabled) {
                this.isActive = false;
            }
        }
    }
    // Internally update active state.
    /**
     * @param {?} active
     * @return {?}
     */
    setActiveState(active) {
        // If (cast) active value has changed:
        if (!!this._isActive !== active) {
            // Update to the new value.
            this._isActive = active;
            // Fire the appropriate activation event.
            if (active) {
                this.onActivate.emit();
            }
            else {
                this.onDeactivate.emit();
            }
        }
        // Regardless, emit a change to `isActive`, so [(isActive)] works correctly.
        this.isActiveChange.emit(active);
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.isDisabled) {
            // Activate the tab when clicked, so long as it isn't disabled.
            this.isActive = true;
        }
    }
}
FuiTabHeader.decorators = [
    { type: Directive, args: [{
                selector: '[fuiTabHeader]'
            },] }
];
/** @nocollapse */
FuiTabHeader.ctorParameters = () => [];
FuiTabHeader.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.item',] }],
    id: [{ type: Input, args: ['fuiTabHeader',] }],
    isActiveChange: [{ type: Output }],
    onActivate: [{ type: Output, args: ['activate',] }],
    onDeactivate: [{ type: Output, args: ['deactivate',] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }, { type: Input }],
    isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTabContent {
    constructor() {
        this.isActive = false;
        this.hasClasses = true;
    }
}
FuiTabContent.decorators = [
    { type: Directive, args: [{
                selector: '[fuiTabContent]'
            },] }
];
/** @nocollapse */
FuiTabContent.ctorParameters = () => [];
FuiTabContent.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.tab',] }],
    id: [{ type: Input, args: ['fuiTabContent',] }],
    isActive: [{ type: HostBinding, args: ['class.active',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTabset {
    constructor() {
        this.tabs = [];
        this._barrierCount = 0;
    }
    // When setting a tab as the currently active tab, it automatically gains
    /**
     * @return {?}
     */
    get activeTab() {
        return this._activeTab;
    }
    // `isActive` status (saves littering `isActive = true` everywhere).
    /**
     * @param {?} tab
     * @return {?}
     */
    set activeTab(tab) {
        this._activeTab = tab;
        tab.isActive = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Fire `internalComponentsUpdated` when the query lists change.
        this._tabHeaders.changes.subscribe((/**
         * @return {?}
         */
        () => this.internalComponentsUpdated()));
        this._tabContents.changes.subscribe((/**
         * @return {?}
         */
        () => this.internalComponentsUpdated()));
        // Initially load the tabs.
        this.loadTabs();
    }
    // Activate the first tab in the set.
    /**
     * @return {?}
     */
    activateFirstTab() {
        this.activeTab = this.tabs[0];
    }
    // Activates the closest available tab to a given one.
    /**
     * @param {?} tab
     * @return {?}
     */
    activateClosestTab(tab) {
        /** @type {?} */
        let nextAvailable;
        // When the exited tab's index is higher than all available tabs,
        if (tab.index >= this.tabs.length) {
            // Activate the last tab.
            nextAvailable = this.tabs[this.tabs.length - 1];
        }
        // If that didn't work, try the following cases:
        if (!nextAvailable) {
            if (!this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            t => t === tab))) { // When the exited tab no longer exists,
                // Replace it with a tab at the same index.
                nextAvailable = this.tabs[tab.index];
            }
            else { // Or if the exited tab still exists,
                // Go to the tab immediately to the left.
                nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];
            }
        }
        // However, if the chosen tab is disabled,
        if (nextAvailable.isDisabled) {
            // Activate the closest available tab to it.
            return this.activateClosestTab(nextAvailable);
        }
        this.activeTab = nextAvailable;
    }
    // Fires whenever either the tab headers or tab contents query lists update.
    /**
     * @private
     * @return {?}
     */
    internalComponentsUpdated() {
        // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.
        // This is so that both the headers and contents query lists can update before we run code that matches the two up.
        this._barrierCount++;
        if (this._barrierCount === 2) {
            // Reset the barrier so it can be called again.
            this._barrierCount = 0;
            // Update the tabs.
            this.loadTabs();
        }
    }
    // Connects tab headers to tab contents, and creates a tab instance for each pairing.
    /**
     * @private
     * @return {?}
     */
    loadTabs() {
        // Remove any tabs that no longer have an associated header.
        this.tabs = this.tabs.filter((/**
         * @param {?} t
         * @return {?}
         */
        t => !!this._tabHeaders.find((/**
         * @param {?} tH
         * @return {?}
         */
        tH => tH === t.header))));
        this._tabHeaders
            // Filter out the loaded headers with attached tab instances.
            .filter((/**
         * @param {?} tH
         * @return {?}
         */
        tH => !this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        t => t.header === tH))))
            .forEach((/**
         * @param {?} tH
         * @return {?}
         */
        tH => {
            /** @type {?} */
            const content = this._tabContents.find((/**
             * @param {?} tC
             * @return {?}
             */
            tC => tC.id === tH.id));
            if (!content) {
                // Error if an associated tab content cannot be found for the given header.
                throw new Error('A [fuiTabHeader] must have a related [fuiTabContent].');
            }
            // Create a new tab instance for this header & content combo.
            /** @type {?} */
            const tab = new Tab(tH, content);
            // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.
            tab.header.isActiveExternalChange.subscribe((/**
             * @return {?}
             */
            () => this.onHeaderActiveChanged(tab)));
            // Add the new instance to the list of tabs.
            this.tabs.push(tab);
        }));
        // Assign each tab an index (which denotes the order they physically appear in).
        this._tabHeaders
            .forEach((/**
         * @param {?} tH
         * @param {?} i
         * @return {?}
         */
        (tH, i) => {
            /** @type {?} */
            const tab = this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            t => t.header === tH));
            if (tab) {
                tab.index = i;
            }
        }));
        // Sort the tabs by their index.
        this.tabs.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => a.index - b.index));
        if (!this.activeTab) { // Check if there are no current existing active tabs.
            // If so, we must activate the first available tab.
            this.activateFirstTab();
        }
        else if (!this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        t => t === this.activeTab))) { // O'wise check if current active tab has been deleted.
            // If so, we must find the closest.
            // Use `setTimeout` as this causes a 'changed after checked' error o'wise.
            setTimeout((/**
             * @return {?}
             */
            () => this.activateClosestTab(this.activeTab)));
        }
        if (this.tabs.length === 0) {
            // Error if there aren't any tabs in the tabset.
            throw new Error('You cannot have no tabs!');
        }
    }
    // Fires whenever a tab header's active state is externally changed.
    /**
     * @private
     * @param {?} tab
     * @return {?}
     */
    onHeaderActiveChanged(tab) {
        // If the tab has become activated, but was not previously the active tab:
        if (tab.isActive && this.activeTab !== tab) {
            // Deactivate all of the tabs.
            this.tabs.filter((/**
             * @param {?} t
             * @return {?}
             */
            t => t !== tab)).forEach((/**
             * @param {?} t
             * @return {?}
             */
            t => t.isActive = false));
            // Set the currently active tab to this one.
            this.activeTab = tab;
        }
        // If the tab has become deactivated, but was previously the active tab:
        if (!tab.isActive && this.activeTab === tab) {
            // Activate the closest tab to it.
            this.activateClosestTab(tab);
        }
    }
}
FuiTabset.decorators = [
    { type: Component, args: [{
                selector: 'fui-tabset',
                template: `<ng-content></ng-content>`
            }] }
];
/** @nocollapse */
FuiTabset.ctorParameters = () => [];
FuiTabset.propDecorators = {
    _tabHeaders: [{ type: ContentChildren, args: [FuiTabHeader,] }],
    _tabContents: [{ type: ContentChildren, args: [FuiTabContent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiTabsModule {
}
FuiTabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiTabset,
                    FuiTabHeader,
                    FuiTabContent
                ],
                exports: [
                    FuiTabset,
                    FuiTabHeader,
                    FuiTabContent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastTitle {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FuiToastTitle.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[fuiToastTitle]' },] }
];
/** @nocollapse */
FuiToastTitle.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastMessage {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FuiToastMessage.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[fuiToastMessage]', },] }
];
/** @nocollapse */
FuiToastMessage.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToast {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.closeEvent = new EventEmitter();
        this.icons = {
            info: 'info',
            success: 'checkmark',
            warning: 'warning',
            error: 'times'
        };
        this.dismissible = this.dismissible || true;
        this.title = this.title || '';
        this.message = this.message || '';
        this.class = this.class || 'info';
        if (typeof this.showIcon !== 'string') {
            if (this.showIcon === undefined || this.showIcon === null) {
                this.showIcon = this.icons[this.class];
            }
            else {
                this.showIcon = false;
            }
        }
        this.closeIcon = this.closeIcon || false;
        this.className = this.className || 'ui toast';
        this.progressUp = this.progressUp || true;
        this.displayTime = this.displayTime || 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.displayTime) {
            window.setTimeout((/**
             * @return {?}
             */
            () => this.close()), this.displayTime);
            if (this.showProgress) {
                this.progress = this.progressUp ? 0 : 100;
                window.setTimeout((/**
                 * @return {?}
                 */
                () => this.progress = this.progressUp ? 100 : 0), 300);
            }
        }
    }
    /**
     * @return {?}
     */
    close() {
        this.elementRef.nativeElement.remove();
        this.closeEvent.next(this.id);
    }
}
FuiToast.decorators = [
    { type: Component, args: [{
                selector: 'fui-toast',
                exportAs: 'fuiToast',
                template: `
    <div class="toast-box compact" (click)="(dismissible ? (!closeIcon ? close() : null) : null)">
      <div *ngIf="showProgress && showProgress === 'top'" class="ui attached active progress {{class}} {{showProgress}}">
        <div class="bar" [ngStyle]="{'transition': 'width ' + (displayTime / 1000)  + 's', 'width': progress + '%'}"
             style="width: 100%;"></div>
      </div>
      <div class="{{class}} {{className}}" [ngClass]="{'icon': showIcon}">
        <i *ngIf="closeIcon" class="close icon" (click)="close()"></i>
        <i *ngIf="showIcon" class="{{showIcon}} icon"></i>
        <div class="content">
          <ng-container *ngIf="title">
            <div class="header">{{title}}</div>
          </ng-container>
          <div class="header" *ngIf="titleTpl">
            <ng-template [ngTemplateOutlet]="titleTpl.templateRef"></ng-template>
          </div>
          <ng-container *ngIf="message">
            <div class="body">{{message}}</div>
          </ng-container>
          <div *ngIf="messageTpl" class="body">
            <ng-template [ngTemplateOutlet]="messageTpl.templateRef"></ng-template>
          </div>
        </div>
      </div>
      <div *ngIf="showProgress && showProgress === 'bottom'" class="ui attached active progress {{class}} {{showProgress}}">
        <div class="bar" [ngStyle]="{'transition': 'width ' + (displayTime / 1000)  + 's', 'width': progress + '%'}"
             style="width: 100%;"></div>
      </div>
    </div>
  `
            }] }
];
/** @nocollapse */
FuiToast.ctorParameters = () => [
    { type: ElementRef }
];
FuiToast.propDecorators = {
    dismissible: [{ type: Input }],
    title: [{ type: Input }],
    message: [{ type: Input }],
    class: [{ type: Input }],
    showIcon: [{ type: Input }],
    closeIcon: [{ type: Input }],
    className: [{ type: Input }],
    progressUp: [{ type: Input }],
    showProgress: [{ type: Input }],
    displayTime: [{ type: Input }],
    id: [{ type: Input }],
    closeEvent: [{ type: Output, args: ['close',] }],
    titleTpl: [{ type: ContentChild, args: [FuiToastTitle, { static: false },] }],
    messageTpl: [{ type: ContentChild, args: [FuiToastMessage, { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastContainer {
    constructor() {
        this.toastData = [];
        this.timeoutIds = {};
        this.maxId = 0;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    addToast(data) {
        data.id = data.id || ++this.maxId;
        data.showProgress = data.showProgress || 'bottom';
        data.class = data.class || 'info';
        data.displayTime = data.displayTime || 5000;
        this.toastData.unshift(data);
        this.timeoutIds[data.id] = window.setTimeout((/**
         * @return {?}
         */
        () => this.closeToast(data.id)), data.displayTime);
    }
    /**
     * @param {?} toastId
     * @return {?}
     */
    closeToast(toastId) {
        /** @type {?} */
        const x = this.toastData.findIndex((/**
         * @param {?} t
         * @return {?}
         */
        t => t.id === toastId));
        if (x > -1) {
            /** @type {?} */
            const id = this.toastData[x].id;
            window.clearTimeout(this.timeoutIds[id]);
            delete this.timeoutIds[id];
            this.toastData.splice(x, 1);
        }
    }
}
FuiToastContainer.decorators = [
    { type: Component, args: [{
                selector: 'fui-toast-container',
                exportAs: 'fuiToastContainer',
                template: `
    <fui-toast *ngFor="let toast of toastData"
               [id]="toast.id"
               [title]="toast.title"
               [message]="toast.message"
               [class]="toast.class"
               [showProgress]="toast.showProgress"
               [displayTime]="toast.displayTime"
               [showIcon]="toast.showIcon"
               [closeIcon]="toast.closeIcon"
               [progressUp]="toast.progressUp"
               [className]="toast.className"
               (close)="closeToast(toast.id)"></fui-toast>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastConfig {
}
FuiToastConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuiToastModule {
}
FuiToastModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FuiToastTitle,
                    FuiToastMessage,
                    FuiToast,
                    FuiToastContainer
                ],
                exports: [
                    FuiToastTitle,
                    FuiToastMessage,
                    FuiToast,
                    FuiToastContainer
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FomanticUIModule {
}
FomanticUIModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: [
                    FuiMessageModule,
                    FuiPaginationModule,
                    FuiAccordionModule,
                    FuiCheckboxModule,
                    FuiCollapseModule,
                    FuiDatepickerModule,
                    FuiDimmerModule,
                    FuiDropdownModule,
                    FuiModalModule,
                    FuiPopupModule,
                    FuiProgressModule,
                    FuiRatingModule,
                    FuiSearchModule,
                    FuiSelectModule,
                    FuiSidebarModule,
                    FuiTabsModule,
                    FuiToastModule,
                    FuiTransitionModule,
                    FuiLocalizationModule,
                    FuiUtilityModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ComponentModalConfig, DatepickerMode, DropdownAutoCloseType, FomanticUIModule, FuiAccordionModule, FuiActiveMessage, ActiveModal as FuiActiveModal, FuiCheckboxModule, FuiCollapseModule, FuiDatepickerModule, FuiDimmerModule, FuiDropdownModule, FuiLocalizationModule, FuiLocalizationService, FuiMessageContainer, FuiMessageModule, FuiMessageService, Modal as FuiModal, FuiModalModule, FuiModalService, FuiPaginationModule, FuiPopupConfig, FuiPopupModule, FuiProgressModule, FuiRatingModule, FuiSearchModule, FuiSelectModule, FuiSidebarModule, FuiTabsModule, FuiToast, FuiToastConfig, FuiToastContainer, FuiToastMessage, FuiToastModule, FuiToastTitle, FuiTransition, FuiTransitionModule, FuiUtilityModule, MessageConfig, MessageController, MessagePosition, MessageState, ModalConfig, ModalControls, ModalSize, ModalTemplate, PositioningPlacement as PopupPlacement, PopupTrigger, SearchService, SidebarDirection, SidebarTransition, TemplateModalConfig, Transition, TransitionController, TransitionDirection, FuiLocalizationService as a, FuiLocalizationModule as b, FuiDatepickerInputDirective as ba, CalendarRangeService as bb, CalendarView as bc, FuiCalendarDateView as bd, FuiCalendarHourView as be, FuiCalendarMinuteView as bf, FuiCalendarMonthView as bg, FuiCalendarYearView as bh, FuiDatepickerModule as bi, FuiDimmer as bj, FuiDimmerModule as bk, FuiDropdownMenuItem as bl, FuiDropdownMenu as bm, FuiDropdown as bn, FuiDropdownModule as bo, ModalConfig as bp, ModalControls as bq, ModalTemplate as br, FuiModal as bs, FuiModalService as bt, FuiModalModule as bu, CustomValidator as bv, customValidatorFactory as bw, CustomValueAccessor as bx, customValueAccessorFactory as by, DatePrecision as bz, FuiMessageContainer as c, FuiComponentFactory as ca, FuiUtilityModule as cb, FuiPopupComponentController as cc, PopupConfig as cd, FuiPopupController as ce, FuiPopupTemplateController as cf, FuiPopupArrow as cg, FuiPopup as ch, FuiPopupDirective as ci, FuiPopupConfig as cj, FuiPopupModule as ck, FuiProgress as cl, FuiProgressModule as cm, FuiRating as cn, FuiRatingValueAccessor as co, FuiRatingModule as cp, FuiSearchResult as cq, FuiSearch as cr, FuiSearchModule as cs, FuiSelectBase as ct, FuiMultiSelectLabel as cu, FuiMultiSelect as cv, FuiMultiSelectValueAccessor as cw, FuiSelectOption as cx, FuiSelect as cy, FuiSelectValueAccessor as cz, FuiMessageGlobalContainer as d, FuiSelectSearch as da, FuiSelectModule as db, FuiSidebarContainer as dc, FuiSidebarSibling as dd, FuiSidebar as de, FuiSidebarModule as df, FuiTabset as dg, FuiTabContent as dh, FuiTabHeader as di, FuiTabsModule as dj, FuiToastModule as dk, FuiTransition as dl, FuiTransitionModule as dm, FuiModalDimmer as dn, FuiMessage as e, FuiMessageService as f, FuiMessageModule as g, FuiPagination as h, FuiPaginationModule as i, FuiAccordionPanel as j, FuiAccordion as k, FuiAccordionModule as l, FuiCheckbox as m, FuiCheckboxValueAccessor as n, FuiRadio as o, FuiRadioValueAccessor as p, FuiRadioManager as q, FuiCheckboxModule as r, FuiCollapse as s, FuiCollapseModule as t, FuiCalendarViewTitle as u, FuiDatepicker as v, FuiCalendarItem as w, FuiDatepickerDirective as x, FuiDatepickerDirectiveValueAccessor as y, FuiDatepickerDirectiveValidator as z };
//# sourceMappingURL=ngx-fomantic-ui.js.map
