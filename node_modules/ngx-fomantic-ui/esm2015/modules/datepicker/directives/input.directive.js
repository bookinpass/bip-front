/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Host, HostBinding, HostListener, Input, Renderer2 } from '@angular/core';
import { DateUtil } from '../../../misc/util/internal';
import { FuiLocalizationService } from '../../../behaviors/localization/internal';
import { PopupTrigger } from '../../popup/internal';
import { FuiDatepickerDirective, FuiDatepickerDirectiveValueAccessor } from './datepicker.directive';
import { DateParser, InternalDateParser } from '../classes/date-parser';
export class FuiDatepickerInputDirective {
    /**
     * @param {?} datepicker
     * @param {?} valueAccessor
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} localizationService
     */
    constructor(datepicker, valueAccessor, _renderer, _element, localizationService) {
        this.datepicker = datepicker;
        this.valueAccessor = valueAccessor;
        this._renderer = _renderer;
        this._element = _element;
        this.useNativeOnMobile = true;
        this.fallbackActive = false;
        // Whenever the datepicker value updates, update the input text alongside it.
        this.datepicker.onSelectedDateChange.subscribe((/**
         * @return {?}
         */
        () => this.updateValue(this.selectedDateString)));
        localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        () => this.updateValue(this.selectedDateString)));
    }
    /**
     * @return {?}
     */
    get parser() {
        if (this.fallbackActive) {
            return new InternalDateParser(this.datepicker.mode, this.datepicker.localeValues);
        }
        return new DateParser(this.datepicker.localeValues.formats[this.datepicker.mode], this.datepicker.localeValues);
    }
    /**
     * @return {?}
     */
    get selectedDateString() {
        if (this.datepicker.selectedDate) {
            return this.parser.format(this.datepicker.selectedDate);
        }
    }
    /**
     * @return {?}
     */
    get type() {
        if (this.fallbackActive) {
            return this.datepicker.config.fallback;
        }
        return 'text';
    }
    /**
     * @return {?}
     */
    get max() {
        if (this.fallbackActive && this.datepicker.maxDate) {
            // Since HTML doesn't use a date object max is somewhat tricky.
            // Our Datepicker will always choose the 1st date on the provided precision,
            // meaning anything below the maxDate will work, hence endOf.
            /** @type {?} */
            const max = DateUtil.endOf(this.datepicker.config.precision, DateUtil.clone(this.datepicker.maxDate));
            return this.parser.format(max);
        }
    }
    /**
     * @return {?}
     */
    get min() {
        if (this.fallbackActive && this.datepicker.minDate) {
            // Since HTML doesn't use a date object min is somewhat tricky.
            // We use 1 minute before the next date at the configured precision since
            // our Datepicker picks the first available date at that precision.
            /** @type {?} */
            const min = DateUtil.clone(this.datepicker.minDate);
            return this.parser.format(min);
        }
    }
    /**
     * @return {?}
     */
    get useNativeOnMobile() {
        return this._useNativeOnMobile;
    }
    /**
     * @param {?} fallback
     * @return {?}
     */
    set useNativeOnMobile(fallback) {
        this._useNativeOnMobile = fallback;
        /** @type {?} */
        const isOnMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(navigator.userAgent);
        this.fallbackActive = this.useNativeOnMobile && isOnMobile;
    }
    /**
     * @return {?}
     */
    get fallbackActive() {
        return this._fallbackActive;
    }
    /**
     * @param {?} active
     * @return {?}
     */
    set fallbackActive(active) {
        this._fallbackActive = active;
        // If the fallback is active, then the trigger must be manual so the datepicker never opens.
        this.datepicker.popup.config.trigger = this.fallbackActive ? PopupTrigger.Manual : PopupTrigger.Focus;
        // Update the input value (this will insert the `T` as required).
        this.updateValue(this.selectedDateString);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    typeValue(value) {
        this._lastUpdateTyped = true;
        this._currentInputValue = value;
        if (!value) {
            // Delete the selected date if no date was entered manually.
            return this.datepicker.writeValue(undefined);
        }
        /** @type {?} */
        const parsed = this.parser.parse(value, this.datepicker.selectedDate);
        if (!isNaN(parsed.getTime()) && value === this.parser.format(parsed)) {
            return this.datepicker.writeValue(parsed);
        }
        return this.datepicker.writeValue(undefined);
    }
    /**
     * @return {?}
     */
    onFocusOut() {
        this.valueAccessor.onTouched();
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        // Only update the current value if it is different to what it's being updated to.
        // This is so that the editing position isn't changed when manually typing the date.
        if (!this._lastUpdateTyped) {
            this._renderer.setProperty(this._element.nativeElement, 'value', value || '');
        }
        this._lastUpdateTyped = false;
    }
}
FuiDatepickerInputDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[fuiDatepicker]'
            },] }
];
/** @nocollapse */
FuiDatepickerInputDirective.ctorParameters = () => [
    { type: FuiDatepickerDirective, decorators: [{ type: Host }] },
    { type: FuiDatepickerDirectiveValueAccessor, decorators: [{ type: Host }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: FuiLocalizationService }
];
FuiDatepickerInputDirective.propDecorators = {
    type: [{ type: HostBinding, args: ['attr.type',] }],
    max: [{ type: HostBinding, args: ['attr.max',] }],
    min: [{ type: HostBinding, args: ['attr.min',] }],
    useNativeOnMobile: [{ type: Input, args: ['pickerUseNativeOnMobile',] }],
    typeValue: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
    onFocusOut: [{ type: HostListener, args: ['focusout',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._currentInputValue;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._lastUpdateTyped;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._useNativeOnMobile;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._fallbackActive;
    /** @type {?} */
    FuiDatepickerInputDirective.prototype.datepicker;
    /** @type {?} */
    FuiDatepickerInputDirective.prototype.valueAccessor;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._element;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWZvbWFudGljLXVpLyIsInNvdXJjZXMiOlsibW9kdWxlcy9kYXRlcGlja2VyL2RpcmVjdGl2ZXMvaW5wdXQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3ZHLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUNyRCxPQUFPLEVBQUMsc0JBQXNCLEVBQUMsTUFBTSwwQ0FBMEMsQ0FBQztBQUNoRixPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDbEQsT0FBTyxFQUFDLHNCQUFzQixFQUFFLG1DQUFtQyxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDbkcsT0FBTyxFQUFDLFVBQVUsRUFBRSxrQkFBa0IsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBS3RFLE1BQU0sT0FBTywyQkFBMkI7Ozs7Ozs7O0lBS3RDLFlBQTJCLFVBQWtDLEVBQ2xDLGFBQWtELEVBQ3pELFNBQW9CLEVBQ3BCLFFBQW9CLEVBQzVCLG1CQUEyQztRQUo1QixlQUFVLEdBQVYsVUFBVSxDQUF3QjtRQUNsQyxrQkFBYSxHQUFiLGFBQWEsQ0FBcUM7UUFDekQsY0FBUyxHQUFULFNBQVMsQ0FBVztRQUNwQixhQUFRLEdBQVIsUUFBUSxDQUFZO1FBR3RDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7UUFDOUIsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7UUFFNUIsNkVBQTZFO1FBQzdFLElBQUksQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsU0FBUzs7O1FBQUMsR0FBRyxFQUFFLENBQ2xELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGtC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VCxRQUFRLEVBQUUsc0JBQXNCO2FBQ2pDOzs7O1lBTE8sc0JBQXNCLHVCQVdmLElBQUk7WUFYYSxtQ0FBbUMsdUJBWXBELElBQUk7WUFoQm9ELFNBQVM7WUFBN0QsVUFBVTtZQUVyQixzQkFBc0I7OzttQkEyQzNCLFdBQVcsU0FBQyxXQUFXO2tCQVF2QixXQUFXLFNBQUMsVUFBVTtrQkFXdEIsV0FBVyxTQUFDLFVBQVU7Z0NBYXRCLEtBQUssU0FBQyx5QkFBeUI7d0JBeUIvQixZQUFZLFNBQUMsT0FBTyxFQUFFLENBQUMscUJBQXFCLENBQUM7eUJBaUI3QyxZQUFZLFNBQUMsVUFBVTs7Ozs7OztJQTNHeEIseURBQStDOzs7OztJQUMvQyx1REFBa0M7Ozs7O0lBOERsQyx5REFBb0M7Ozs7O0lBYXBDLHNEQUFpQzs7SUF6RXJCLGlEQUFpRDs7SUFDakQsb0RBQWlFOzs7OztJQUNqRSxnREFBNEI7Ozs7O0lBQzVCLCtDQUE0QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0LCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgUmVuZGVyZXIyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtEYXRlVXRpbH0gZnJvbSAnLi4vLi4vLi4vbWlzYy91dGlsL2ludGVybmFsJztcclxuaW1wb3J0IHtGdWlMb2NhbGl6YXRpb25TZXJ2aWNlfSBmcm9tICcuLi8uLi8uLi9iZWhhdmlvcnMvbG9jYWxpemF0aW9uL2ludGVybmFsJztcclxuaW1wb3J0IHtQb3B1cFRyaWdnZXJ9IGZyb20gJy4uLy4uL3BvcHVwL2ludGVybmFsJztcclxuaW1wb3J0IHtGdWlEYXRlcGlja2VyRGlyZWN0aXZlLCBGdWlEYXRlcGlja2VyRGlyZWN0aXZlVmFsdWVBY2Nlc3Nvcn0gZnJvbSAnLi9kYXRlcGlja2VyLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7RGF0ZVBhcnNlciwgSW50ZXJuYWxEYXRlUGFyc2VyfSBmcm9tICcuLi9jbGFzc2VzL2RhdGUtcGFyc2VyJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnaW5wdXRbZnVpRGF0ZXBpY2tlcl0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGdWlEYXRlcGlja2VySW5wdXREaXJlY3RpdmUge1xyXG5cclxuICBwcml2YXRlIF9jdXJyZW50SW5wdXRWYWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gIHByaXZhdGUgX2xhc3RVcGRhdGVUeXBlZDogYm9vbGVhbjtcclxuXHJcbiAgY29uc3RydWN0b3IoQEhvc3QoKSBwdWJsaWMgZGF0ZXBpY2tlcjogRnVpRGF0ZXBpY2tlckRpcmVjdGl2ZSxcclxuICAgICAgICAgICAgICBASG9zdCgpIHB1YmxpYyB2YWx1ZUFjY2Vzc29yOiBGdWlEYXRlcGlja2VyRGlyZWN0aXZlVmFsdWVBY2Nlc3NvcixcclxuICAgICAgICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsXHJcbiAgICAgICAgICAgICAgbG9jYWxpemF0aW9uU2VydmljZTogRnVpTG9jYWxpemF0aW9uU2VydmljZSkge1xyXG5cclxuICAgIHRoaXMudXNlTmF0aXZlT25Nb2JpbGUgPSB0cnVlO1xyXG4gICAgdGhpcy5mYWxsYmFja0FjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgIC8vIFdoZW5ldmVyIHRoZSBkYXRlcGlja2VyIHZhbHVlIHVwZGF0ZXMsIHVwZGF0ZSB0aGUgaW5wdXQgdGV4dCBhbG9uZ3NpZGUgaXQuXHJcbiAgICB0aGlzLmRhdGVwaWNrZXIub25TZWxlY3RlZERhdGVDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+XHJcbiAgICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5zZWxlY3RlZERhdGVTdHJpbmcpKTtcclxuXHJcbiAgICBsb2NhbGl6YXRpb25TZXJ2aWNlLm9uTGFuZ3VhZ2VVcGRhdGUuc3Vic2NyaWJlKCgpID0+XHJcbiAgICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5zZWxlY3RlZERhdGVTdHJpbmcpKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgcGFyc2VyKCk6IERhdGVQYXJzZXIge1xyXG4gICAgaWYgKHRoaXMuZmFsbGJhY2tBY3RpdmUpIHtcclxuICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbERhdGVQYXJzZXIodGhpcy5kYXRlcGlja2VyLm1vZGUsIHRoaXMuZGF0ZXBpY2tlci5sb2NhbGVWYWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBEYXRlUGFyc2VyKHRoaXMuZGF0ZXBpY2tlci5sb2NhbGVWYWx1ZXMuZm9ybWF0c1t0aGlzLmRhdGVwaWNrZXIubW9kZV0sIHRoaXMuZGF0ZXBpY2tlci5sb2NhbGVWYWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBzZWxlY3RlZERhdGVTdHJpbmcoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIGlmICh0aGlzLmRhdGVwaWNrZXIuc2VsZWN0ZWREYXRlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlci5mb3JtYXQodGhpcy5kYXRlcGlja2VyLnNlbGVjdGVkRGF0ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBASG9zdEJpbmRpbmcoJ2F0dHIudHlwZScpXHJcbiAgcHVibGljIGdldCB0eXBlKCk6IHN0cmluZyB7XHJcbiAgICBpZiAodGhpcy5mYWxsYmFja0FjdGl2ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRlcGlja2VyLmNvbmZpZy5mYWxsYmFjaztcclxuICAgIH1cclxuICAgIHJldHVybiAndGV4dCc7XHJcbiAgfVxyXG5cclxuICBASG9zdEJpbmRpbmcoJ2F0dHIubWF4JylcclxuICBwdWJsaWMgZ2V0IG1heCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgaWYgKHRoaXMuZmFsbGJhY2tBY3RpdmUgJiYgdGhpcy5kYXRlcGlja2VyLm1heERhdGUpIHtcclxuICAgICAgLy8gU2luY2UgSFRNTCBkb2Vzbid0IHVzZSBhIGRhdGUgb2JqZWN0IG1heCBpcyBzb21ld2hhdCB0cmlja3kuXHJcbiAgICAgIC8vIE91ciBEYXRlcGlja2VyIHdpbGwgYWx3YXlzIGNob29zZSB0aGUgMXN0IGRhdGUgb24gdGhlIHByb3ZpZGVkIHByZWNpc2lvbixcclxuICAgICAgLy8gbWVhbmluZyBhbnl0aGluZyBiZWxvdyB0aGUgbWF4RGF0ZSB3aWxsIHdvcmssIGhlbmNlIGVuZE9mLlxyXG4gICAgICBjb25zdCBtYXggPSBEYXRlVXRpbC5lbmRPZih0aGlzLmRhdGVwaWNrZXIuY29uZmlnLnByZWNpc2lvbiwgRGF0ZVV0aWwuY2xvbmUodGhpcy5kYXRlcGlja2VyLm1heERhdGUpKTtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLmZvcm1hdChtYXgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLm1pbicpXHJcbiAgcHVibGljIGdldCBtaW4oKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIGlmICh0aGlzLmZhbGxiYWNrQWN0aXZlICYmIHRoaXMuZGF0ZXBpY2tlci5taW5EYXRlKSB7XHJcbiAgICAgIC8vIFNpbmNlIEhUTUwgZG9lc24ndCB1c2UgYSBkYXRlIG9iamVjdCBtaW4gaXMgc29tZXdoYXQgdHJpY2t5LlxyXG4gICAgICAvLyBXZSB1c2UgMSBtaW51dGUgYmVmb3JlIHRoZSBuZXh0IGRhdGUgYXQgdGhlIGNvbmZpZ3VyZWQgcHJlY2lzaW9uIHNpbmNlXHJcbiAgICAgIC8vIG91ciBEYXRlcGlja2VyIHBpY2tzIHRoZSBmaXJzdCBhdmFpbGFibGUgZGF0ZSBhdCB0aGF0IHByZWNpc2lvbi5cclxuICAgICAgY29uc3QgbWluID0gRGF0ZVV0aWwuY2xvbmUodGhpcy5kYXRlcGlja2VyLm1pbkRhdGUpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZXIuZm9ybWF0KG1pbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF91c2VOYXRpdmVPbk1vYmlsZTogYm9vbGVhbjtcclxuXHJcbiAgQElucHV0KCdwaWNrZXJVc2VOYXRpdmVPbk1vYmlsZScpXHJcbiAgcHVibGljIGdldCB1c2VOYXRpdmVPbk1vYmlsZSgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl91c2VOYXRpdmVPbk1vYmlsZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXQgdXNlTmF0aXZlT25Nb2JpbGUoZmFsbGJhY2s6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMuX3VzZU5hdGl2ZU9uTW9iaWxlID0gZmFsbGJhY2s7XHJcbiAgICBjb25zdCBpc09uTW9iaWxlID0gL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbml8TW9iaWxlfG1vYmlsZXxDcmlPUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICB0aGlzLmZhbGxiYWNrQWN0aXZlID0gdGhpcy51c2VOYXRpdmVPbk1vYmlsZSAmJiBpc09uTW9iaWxlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfZmFsbGJhY2tBY3RpdmU6IGJvb2xlYW47XHJcblxyXG4gIHB1YmxpYyBnZXQgZmFsbGJhY2tBY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tBY3RpdmU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0IGZhbGxiYWNrQWN0aXZlKGFjdGl2ZTogYm9vbGVhbikge1xyXG4gICAgdGhpcy5fZmFsbGJhY2tBY3RpdmUgPSBhY3RpdmU7XHJcbiAgICAvLyBJZiB0aGUgZmFsbGJhY2sgaXMgYWN0aXZlLCB0aGVuIHRoZSB0cmlnZ2VyIG11c3QgYmUgbWFudWFsIHNvIHRoZSBkYXRlcGlja2VyIG5ldmVyIG9wZW5zLlxyXG4gICAgdGhpcy5kYXRlcGlja2VyLnBvcHVwLmNvbmZpZy50cmlnZ2VyID0gdGhpcy5mYWxsYmFja0FjdGl2ZSA/IFBvcHVwVHJpZ2dlci5NYW51YWwgOiBQb3B1cFRyaWdnZXIuRm9jdXM7XHJcbiAgICAvLyBVcGRhdGUgdGhlIGlucHV0IHZhbHVlICh0aGlzIHdpbGwgaW5zZXJ0IHRoZSBgVGAgYXMgcmVxdWlyZWQpLlxyXG4gICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLnNlbGVjdGVkRGF0ZVN0cmluZyk7XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdpbnB1dCcsIFsnJGV2ZW50LnRhcmdldC52YWx1ZSddKVxyXG4gIHB1YmxpYyB0eXBlVmFsdWUodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHZvaWQge1xyXG4gICAgdGhpcy5fbGFzdFVwZGF0ZVR5cGVkID0gdHJ1ZTtcclxuICAgIHRoaXMuX2N1cnJlbnRJbnB1dFZhbHVlID0gdmFsdWU7XHJcblxyXG4gICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAvLyBEZWxldGUgdGhlIHNlbGVjdGVkIGRhdGUgaWYgbm8gZGF0ZSB3YXMgZW50ZXJlZCBtYW51YWxseS5cclxuICAgICAgcmV0dXJuIHRoaXMuZGF0ZXBpY2tlci53cml0ZVZhbHVlKHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZXIucGFyc2UodmFsdWUsIHRoaXMuZGF0ZXBpY2tlci5zZWxlY3RlZERhdGUpO1xyXG4gICAgaWYgKCFpc05hTihwYXJzZWQuZ2V0VGltZSgpKSAmJiB2YWx1ZSA9PT0gdGhpcy5wYXJzZXIuZm9ybWF0KHBhcnNlZCkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0ZXBpY2tlci53cml0ZVZhbHVlKHBhcnNlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5kYXRlcGlja2VyLndyaXRlVmFsdWUodW5kZWZpbmVkKTtcclxuICB9XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3Vzb3V0JylcclxuICBwdWJsaWMgb25Gb2N1c091dCgpOiB2b2lkIHtcclxuICAgIHRoaXMudmFsdWVBY2Nlc3Nvci5vblRvdWNoZWQoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlVmFsdWUodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHZvaWQge1xyXG4gICAgLy8gT25seSB1cGRhdGUgdGhlIGN1cnJlbnQgdmFsdWUgaWYgaXQgaXMgZGlmZmVyZW50IHRvIHdoYXQgaXQncyBiZWluZyB1cGRhdGVkIHRvLlxyXG4gICAgLy8gVGhpcyBpcyBzbyB0aGF0IHRoZSBlZGl0aW5nIHBvc2l0aW9uIGlzbid0IGNoYW5nZWQgd2hlbiBtYW51YWxseSB0eXBpbmcgdGhlIGRhdGUuXHJcbiAgICBpZiAoIXRoaXMuX2xhc3RVcGRhdGVUeXBlZCkge1xyXG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlIHx8ICcnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9sYXN0VXBkYXRlVHlwZWQgPSBmYWxzZTtcclxuICB9XHJcbn1cclxuIl19