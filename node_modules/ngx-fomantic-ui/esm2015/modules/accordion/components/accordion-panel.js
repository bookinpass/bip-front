/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Component, EventEmitter, Input, Output } from '@angular/core';
import { Transition, TransitionController } from '../../transition/internal';
export class FuiAccordionPanel {
    /**
     * @param {?} _changeDetector
     */
    constructor(_changeDetector) {
        this._changeDetector = _changeDetector;
        this.transitionController = new TransitionController(false);
        this._isOpen = false;
        this.isOpenChange = new EventEmitter(false);
    }
    /**
     * @return {?}
     */
    get transition() {
        if (this._service) {
            return this._service.transition;
        }
        return 'fade';
    }
    /**
     * @return {?}
     */
    get transitionDuration() {
        if (this._service) {
            // Return the service defined transition duration.
            return this._service.transitionDuration;
        }
        // Revert to instantaneous if the service is not yet loaded.
        return 0;
    }
    /**
     * @param {?} service
     * @return {?}
     */
    set service(service) {
        this._service = service;
        this._changeDetector.detectChanges();
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        // Convert to boolean (fixes false != undefined)
        /** @type {?} */
        const isOpen = !!value;
        if (isOpen !== this.isOpen) {
            // Only update if the value has changed.
            this._isOpen = isOpen;
            if (isOpen && this._service) {
                // If we are opening this panel, we must close the other ones.
                this._service.closeOtherPanels(this);
            }
            this.isOpenChange.emit(this.isOpen);
            // Cancel all current animations, and fade the contents. The direction is automatic.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.transition, this.transitionDuration));
        }
    }
    /**
     * @return {?}
     */
    toggle() {
        if (!this.isDisabled) {
            this.isOpen = !this.isOpen;
        }
    }
}
FuiAccordionPanel.decorators = [
    { type: Component, args: [{
                selector: 'fui-accordion-panel',
                exportAs: 'fuiAccordionPanel',
                template: `
<!-- Title -->
<div class="title" [class.active]="isOpen" (click)="toggle()" >
    <ng-content select="[title]"></ng-content>
</div>
<!-- Content -->
<div [fuiCollapse]="!isOpen" [collapseDuration]="transitionDuration">
    <div class="content" [class.active]="isOpen" [fuiTransition]="transitionController">
        <ng-content select="[content]"></ng-content>
    </div>
</div>
`,
                styles: [`
/* Manual style as Fomantic UI relies on > selector */
.content {
    padding: .5em 0 1em;
}

/* Another > selector fix */
:host:first-child .title {
    border-top: none;
}
`]
            }] }
];
/** @nocollapse */
FuiAccordionPanel.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FuiAccordionPanel.propDecorators = {
    isDisabled: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    isOpen: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FuiAccordionPanel.prototype.transitionController;
    /** @type {?} */
    FuiAccordionPanel.prototype.isDisabled;
    /** @type {?} */
    FuiAccordionPanel.prototype.isOpenChange;
    /**
     * @type {?}
     * @private
     */
    FuiAccordionPanel.prototype._service;
    /**
     * @type {?}
     * @private
     */
    FuiAccordionPanel.prototype._isOpen;
    /**
     * @type {?}
     * @private
     */
    FuiAccordionPanel.prototype._changeDetector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3JkaW9uLXBhbmVsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWZvbWFudGljLXVpLyIsInNvdXJjZXMiOlsibW9kdWxlcy9hY2NvcmRpb24vY29tcG9uZW50cy9hY2NvcmRpb24tcGFuZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxpQkFBaUIsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFeEYsT0FBTyxFQUFDLFVBQVUsRUFBRSxvQkFBb0IsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBNkIzRSxNQUFNLE9BQU8saUJBQWlCOzs7O0lBUTVCLFlBQW9CLGVBQWtDO1FBQWxDLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjtRQUNwRCxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU1RCxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUNyQixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksWUFBWSxDQUFVLEtBQUssQ0FBQyxDQUFDO0lBQ3ZELENBQUM7Ozs7SUFFRCxJQUFXLFVBQVU7UUFDbkIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7U0FDakM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOzs7O0lBRUQsSUFBVyxrQkFBa0I7UUFDM0IsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pCLGtEQUFrRDtZQUNsRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUM7U0FDekM7UUFDRCw0REFBNEQ7UUFDNUQsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDOzs7OztJQUlELElBQVcsT0FBTyxDQUFDLE9BQTRCO1FBQzdDLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkMsQ0FBQzs7OztJQUlELElBQ1csTUFBTTtRQUNmLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDOzs7OztJQUVELElBQVcsTUFBTSxDQUFDLEtBQWM7OztjQUV4QixNQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUs7UUFFdEIsSUFBSSxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUMxQix3Q0FBd0M7WUFDeEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7WUFFdEIsSUFBSSxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDM0IsOERBQThEO2dCQUM5RCxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3RDO1lBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRXBDLG9GQUFvRjtZQUNwRixJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDcEMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7U0FDN0Y7SUFDSCxDQUFDOzs7O0lBRU0sTUFBTTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQzVCO0lBQ0gsQ0FBQzs7O1lBakdGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUscUJBQXFCO2dCQUMvQixRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QixRQUFRLEVBQUU7Ozs7Ozs7Ozs7O0NBV1g7eUJBQ1U7Ozs7Ozs7Ozs7Q0FVVjthQUNBOzs7O1lBOUJPLGlCQUFpQjs7O3lCQWtDdEIsS0FBSzsyQkFFTCxNQUFNO3FCQW9DTixLQUFLOzs7O0lBdkNOLGlEQUFrRDs7SUFDbEQsdUNBQzJCOztJQUMzQix5Q0FDMkM7Ozs7O0lBMEIzQyxxQ0FBc0M7Ozs7O0lBT3RDLG9DQUF5Qjs7Ozs7SUEvQmIsNENBQTBDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0Z1aUFjY29yZGlvblNlcnZpY2V9IGZyb20gJy4uL3NlcnZpY2VzL2FjY29yZGlvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHtUcmFuc2l0aW9uLCBUcmFuc2l0aW9uQ29udHJvbGxlcn0gZnJvbSAnLi4vLi4vdHJhbnNpdGlvbi9pbnRlcm5hbCc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2Z1aS1hY2NvcmRpb24tcGFuZWwnLFxyXG4gIGV4cG9ydEFzOiAnZnVpQWNjb3JkaW9uUGFuZWwnLFxyXG4gIHRlbXBsYXRlOiBgXHJcbjwhLS0gVGl0bGUgLS0+XHJcbjxkaXYgY2xhc3M9XCJ0aXRsZVwiIFtjbGFzcy5hY3RpdmVdPVwiaXNPcGVuXCIgKGNsaWNrKT1cInRvZ2dsZSgpXCIgPlxyXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW3RpdGxlXVwiPjwvbmctY29udGVudD5cclxuPC9kaXY+XHJcbjwhLS0gQ29udGVudCAtLT5cclxuPGRpdiBbZnVpQ29sbGFwc2VdPVwiIWlzT3BlblwiIFtjb2xsYXBzZUR1cmF0aW9uXT1cInRyYW5zaXRpb25EdXJhdGlvblwiPlxyXG4gICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIiBbY2xhc3MuYWN0aXZlXT1cImlzT3BlblwiIFtmdWlUcmFuc2l0aW9uXT1cInRyYW5zaXRpb25Db250cm9sbGVyXCI+XHJcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NvbnRlbnRdXCI+PC9uZy1jb250ZW50PlxyXG4gICAgPC9kaXY+XHJcbjwvZGl2PlxyXG5gLFxyXG4gIHN0eWxlczogW2BcclxuLyogTWFudWFsIHN0eWxlIGFzIEZvbWFudGljIFVJIHJlbGllcyBvbiA+IHNlbGVjdG9yICovXHJcbi5jb250ZW50IHtcclxuICAgIHBhZGRpbmc6IC41ZW0gMCAxZW07XHJcbn1cclxuXHJcbi8qIEFub3RoZXIgPiBzZWxlY3RvciBmaXggKi9cclxuOmhvc3Q6Zmlyc3QtY2hpbGQgLnRpdGxlIHtcclxuICAgIGJvcmRlci10b3A6IG5vbmU7XHJcbn1cclxuYF1cclxufSlcclxuZXhwb3J0IGNsYXNzIEZ1aUFjY29yZGlvblBhbmVsIHtcclxuXHJcbiAgcHVibGljIHRyYW5zaXRpb25Db250cm9sbGVyOiBUcmFuc2l0aW9uQ29udHJvbGxlcjtcclxuICBASW5wdXQoKVxyXG4gIHB1YmxpYyBpc0Rpc2FibGVkOiBib29sZWFuO1xyXG4gIEBPdXRwdXQoKVxyXG4gIHB1YmxpYyBpc09wZW5DaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmKSB7XHJcbiAgICB0aGlzLnRyYW5zaXRpb25Db250cm9sbGVyID0gbmV3IFRyYW5zaXRpb25Db250cm9sbGVyKGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcclxuICAgIHRoaXMuaXNPcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHRyYW5zaXRpb24oKTogc3RyaW5nIHtcclxuICAgIGlmICh0aGlzLl9zZXJ2aWNlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlLnRyYW5zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICdmYWRlJztcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgdHJhbnNpdGlvbkR1cmF0aW9uKCk6IG51bWJlciB7XHJcbiAgICBpZiAodGhpcy5fc2VydmljZSkge1xyXG4gICAgICAvLyBSZXR1cm4gdGhlIHNlcnZpY2UgZGVmaW5lZCB0cmFuc2l0aW9uIGR1cmF0aW9uLlxyXG4gICAgICByZXR1cm4gdGhpcy5fc2VydmljZS50cmFuc2l0aW9uRHVyYXRpb247XHJcbiAgICB9XHJcbiAgICAvLyBSZXZlcnQgdG8gaW5zdGFudGFuZW91cyBpZiB0aGUgc2VydmljZSBpcyBub3QgeWV0IGxvYWRlZC5cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc2VydmljZTogRnVpQWNjb3JkaW9uU2VydmljZTtcclxuXHJcbiAgcHVibGljIHNldCBzZXJ2aWNlKHNlcnZpY2U6IEZ1aUFjY29yZGlvblNlcnZpY2UpIHtcclxuICAgIHRoaXMuX3NlcnZpY2UgPSBzZXJ2aWNlO1xyXG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfaXNPcGVuOiBib29sZWFuO1xyXG5cclxuICBASW5wdXQoKVxyXG4gIHB1YmxpYyBnZXQgaXNPcGVuKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzT3BlbjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXQgaXNPcGVuKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAvLyBDb252ZXJ0IHRvIGJvb2xlYW4gKGZpeGVzIGZhbHNlICE9IHVuZGVmaW5lZClcclxuICAgIGNvbnN0IGlzT3BlbiA9ICEhdmFsdWU7XHJcblxyXG4gICAgaWYgKGlzT3BlbiAhPT0gdGhpcy5pc09wZW4pIHtcclxuICAgICAgLy8gT25seSB1cGRhdGUgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxyXG4gICAgICB0aGlzLl9pc09wZW4gPSBpc09wZW47XHJcblxyXG4gICAgICBpZiAoaXNPcGVuICYmIHRoaXMuX3NlcnZpY2UpIHtcclxuICAgICAgICAvLyBJZiB3ZSBhcmUgb3BlbmluZyB0aGlzIHBhbmVsLCB3ZSBtdXN0IGNsb3NlIHRoZSBvdGhlciBvbmVzLlxyXG4gICAgICAgIHRoaXMuX3NlcnZpY2UuY2xvc2VPdGhlclBhbmVscyh0aGlzKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmlzT3BlbkNoYW5nZS5lbWl0KHRoaXMuaXNPcGVuKTtcclxuXHJcbiAgICAgIC8vIENhbmNlbCBhbGwgY3VycmVudCBhbmltYXRpb25zLCBhbmQgZmFkZSB0aGUgY29udGVudHMuIFRoZSBkaXJlY3Rpb24gaXMgYXV0b21hdGljLlxyXG4gICAgICB0aGlzLnRyYW5zaXRpb25Db250cm9sbGVyLnN0b3BBbGwoKTtcclxuICAgICAgdGhpcy50cmFuc2l0aW9uQ29udHJvbGxlci5hbmltYXRlKG5ldyBUcmFuc2l0aW9uKHRoaXMudHJhbnNpdGlvbiwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyB0b2dnbGUoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLmlzT3BlbiA9ICF0aGlzLmlzT3BlbjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19