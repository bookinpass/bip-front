/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Directive, ElementRef, EventEmitter, Input, Output, ViewChild, ViewContainerRef } from '@angular/core';
import { CustomValueAccessor, customValueAccessorFactory } from '../../../misc/util/internal';
import { FuiLocalizationService } from '../../../behaviors/localization/internal';
import { FuiSelectBase } from '../classes/select-base';
/**
 * @template T, U
 */
export class FuiSelect extends FuiSelectBase {
    /**
     * @param {?} element
     * @param {?} localizationService
     */
    constructor(element, localizationService) {
        super(element, localizationService);
        this.selectedOptionChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder || this.localeValues.single.placeholder;
    }
    /**
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = placeholder;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    selectOption(option) {
        // Choose and emit the selected option.
        this.selectedOption = option;
        this.selectedOptionChange.emit(this.valueGetter(option));
        this.dropdownService.setOpenState(false);
        this.resetQuery();
        this.drawSelectedOption();
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value != undefined) {
            if (this.searchService.options.length > 0) {
                // If the options have already been loaded, we can immediately match the ngModel value to an option.
                this.selectedOption = this.findOption(this.searchService.options, value);
                this.drawSelectedOption();
            }
            if (this.selectedOption == undefined) {
                if (this.valueField && this.searchService.hasItemLookup) {
                    // If the search service has a selected lookup function, make use of that to load the initial value.
                    this.searchService
                        .initialLookup(value)
                        .then((/**
                     * @param {?} i
                     * @return {?}
                     */
                    i => {
                        this.selectedOption = i;
                        this.drawSelectedOption();
                    }));
                }
                else {
                    // Otherwise, cache the written value for when options are set.
                    this._writtenOption = value;
                }
            }
        }
        else {
            this.selectedOption = undefined;
            this.drawSelectedOption();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onRemoveClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            this.selectedOption = undefined;
            this.selectedOptionChange.emit(undefined);
            this._renderedOptions.forEach((/**
             * @param {?} o
             * @return {?}
             */
            o => o.isActive = false));
        }
    }
    /**
     * @protected
     * @return {?}
     */
    optionsUpdateHook() {
        if (!this._writtenOption && this.selectedOption) {
            // We need to check the option still exists.
            this.writeValue(this.valueGetter(this.selectedOption));
        }
        if (this._writtenOption && this.searchService.options.length > 0) {
            // If there was an value written by ngModel before the options had been loaded, this runs to fix it.
            this.selectedOption = this.findOption(this.searchService.options, this._writtenOption);
            if (this.selectedOption) {
                this._writtenOption = undefined;
                this.drawSelectedOption();
            }
        }
    }
    /**
     * @protected
     * @return {?}
     */
    queryUpdateHook() {
        // When the query is updated, we just abandon the current selection.
        this.selectedOption = undefined;
    }
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    initialiseRenderedOption(option) {
        super.initialiseRenderedOption(option);
        // Boldens the item so it appears selected in the dropdown.
        option.isActive = option.value === this.selectedOption;
    }
    /**
     * @private
     * @return {?}
     */
    drawSelectedOption() {
        // Updates the active class on the newly selected option.
        if (this._renderedOptions) {
            this.onAvailableOptionsRendered();
        }
        if (this.selectedOption != undefined && this.optionTemplate) {
            this.drawTemplate(this._optionTemplateSibling, this.selectedOption);
        }
    }
}
FuiSelect.decorators = [
    { type: Component, args: [{
                selector: 'fui-select',
                template: `
                   <!-- Query input -->
                   <input fuiSelectSearch
                          type="text"
                          [hidden]="!isSearchable || isSearchExternal">

                   <!-- Placeholder text -->
                   <div *ngIf="selectedOption == undefined" class="default text" [class.filtered]="query">{{ placeholder }}</div>
                   <!-- Selected item -->
                   <div class="text" [class.filtered]="query || selectedOption == undefined">
                       <span #optionTemplateSibling></span>
                       <span *ngIf="!optionTemplate && selectedOption != undefined"
                             [innerHTML]="configuredFormatter(selectedOption)"></span>
                   </div>
                   <!-- Dropdown icon -->
                   <i *ngIf="selectedOption && !isSearching && isClearable" class="times icon"
                      (click)="onRemoveClick($event)"></i>
                   <i *ngIf="!selectedOption || !isClearable" class="{{ icon }} icon" (click)="onCaretClick($event)"></i>
                   <!-- Select dropdown menu -->
                   <div class="menu"
                        fuiDropdownMenu
                        [menuTransition]="transition"
                        [menuTransitionDuration]="transitionDuration"
                        [menuAutoSelectFirst]="isSearchable">

                       <ng-content></ng-content>
                       <div *ngIf="isSearchable && availableOptions.length === 0" class="message">
                           {{ localeValues.noResultsMessage }}
                       </div>
                   </div>
               `,
                styles: [`
                   :host .times.icon {
                       position: absolute;
                       width: auto;
                       height: auto;
                       line-height: 1.21428571em;
                       top: .78571429em;
                       right: 1em;
                       margin: -.78571429em;
                       opacity: .6;
                       font-size: 1.07142857em;
                       padding: .6em;
                       -webkit-transition: opacity .1s ease;
                       transition: opacity .1s ease;
                       z-index: 3;
                   }

                   :host .times.icon.larger {
                       padding: .91666667em;
                       font-size: .85714286em;
                   }

                   :host .times.icon:hover {
                       opacity: 1;
                   }
               `]
            }] }
];
/** @nocollapse */
FuiSelect.ctorParameters = () => [
    { type: ElementRef },
    { type: FuiLocalizationService }
];
FuiSelect.propDecorators = {
    selectedOptionChange: [{ type: Output }],
    _optionTemplateSibling: [{ type: ViewChild, args: ['optionTemplateSibling', { read: ViewContainerRef, static: false },] }],
    placeholder: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FuiSelect.prototype.selectedOption;
    /** @type {?} */
    FuiSelect.prototype.selectedOptionChange;
    /**
     * @type {?}
     * @private
     */
    FuiSelect.prototype._writtenOption;
    /**
     * @type {?}
     * @private
     */
    FuiSelect.prototype._optionTemplateSibling;
    /**
     * @type {?}
     * @private
     */
    FuiSelect.prototype._placeholder;
}
// Value accessor directive for the select to support ngModel.
/**
 * @template T, U
 */
export class FuiSelectValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiSelectValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'fui-select',
                host: {
                    '(selectedOptionChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiSelectValueAccessor)]
            },] }
];
/** @nocollapse */
FuiSelectValueAccessor.ctorParameters = () => [
    { type: FuiSelect }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWZvbWFudGljLXVpLyIsInNvdXJjZXMiOlsibW9kdWxlcy9zZWxlY3QvY29tcG9uZW50cy9zZWxlY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDekgsT0FBTyxFQUFDLG1CQUFtQixFQUFFLDBCQUEwQixFQUF5QyxNQUFNLDZCQUE2QixDQUFDO0FBQ3BJLE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLDBDQUEwQyxDQUFDO0FBQ2hGLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQzs7OztBQStEckQsTUFBTSxPQUFPLFNBQWdCLFNBQVEsYUFBbUI7Ozs7O0lBVXRELFlBQVksT0FBbUIsRUFBRSxtQkFBMkM7UUFDMUUsS0FBSyxDQUFDLE9BQU8sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1FBRXBDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLFlBQVksRUFBSyxDQUFDO0lBQ3BELENBQUM7Ozs7SUFJRCxJQUNXLFdBQVc7UUFDcEIsT0FBTyxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQztJQUNuRSxDQUFDOzs7OztJQUVELElBQVcsV0FBVyxDQUFDLFdBQW1CO1FBQ3hDLElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7Ozs7O0lBRU0sWUFBWSxDQUFDLE1BQVM7UUFDM0IsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQyxjQUFjLEdBQUcsTUFBTSxDQUFDO1FBQzdCLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxD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RUFBRSxhQUFhO2lCQUMzQjtnQkFDRCxTQUFTLEVBQUUsQ0FBQywwQkFBMEIsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO2FBQ2hFOzs7O1lBRW1CLFNBQVMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFZpZXdDaGlsZCwgVmlld0NvbnRhaW5lclJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7Q3VzdG9tVmFsdWVBY2Nlc3NvciwgY3VzdG9tVmFsdWVBY2Nlc3NvckZhY3RvcnksIEhhbmRsZWRFdmVudCwgSUN1c3RvbVZhbHVlQWNjZXNzb3JIb3N0fSBmcm9tICcuLi8uLi8uLi9taXNjL3V0aWwvaW50ZXJuYWwnO1xyXG5pbXBvcnQge0Z1aUxvY2FsaXphdGlvblNlcnZpY2V9IGZyb20gJy4uLy4uLy4uL2JlaGF2aW9ycy9sb2NhbGl6YXRpb24vaW50ZXJuYWwnO1xyXG5pbXBvcnQge0Z1aVNlbGVjdEJhc2V9IGZyb20gJy4uL2NsYXNzZXMvc2VsZWN0LWJhc2UnO1xyXG5pbXBvcnQge0Z1aVNlbGVjdE9wdGlvbn0gZnJvbSAnLi9zZWxlY3Qtb3B0aW9uJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnZnVpLXNlbGVjdCcsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgICAgICAgICAgICAgICAgIDwhLS0gUXVlcnkgaW5wdXQgLS0+XHJcbiAgICAgICAgICAgICAgICAgICA8aW5wdXQgZnVpU2VsZWN0U2VhcmNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtoaWRkZW5dPVwiIWlzU2VhcmNoYWJsZSB8fCBpc1NlYXJjaEV4dGVybmFsXCI+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgPCEtLSBQbGFjZWhvbGRlciB0ZXh0IC0tPlxyXG4gICAgICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cInNlbGVjdGVkT3B0aW9uID09IHVuZGVmaW5lZFwiIGNsYXNzPVwiZGVmYXVsdCB0ZXh0XCIgW2NsYXNzLmZpbHRlcmVkXT1cInF1ZXJ5XCI+e3sgcGxhY2Vob2xkZXIgfX08L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgIDwhLS0gU2VsZWN0ZWQgaXRlbSAtLT5cclxuICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0XCIgW2NsYXNzLmZpbHRlcmVkXT1cInF1ZXJ5IHx8IHNlbGVjdGVkT3B0aW9uID09IHVuZGVmaW5lZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICNvcHRpb25UZW1wbGF0ZVNpYmxpbmc+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiIW9wdGlvblRlbXBsYXRlICYmIHNlbGVjdGVkT3B0aW9uICE9IHVuZGVmaW5lZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lubmVySFRNTF09XCJjb25maWd1cmVkRm9ybWF0dGVyKHNlbGVjdGVkT3B0aW9uKVwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgPCEtLSBEcm9wZG93biBpY29uIC0tPlxyXG4gICAgICAgICAgICAgICAgICAgPGkgKm5nSWY9XCJzZWxlY3RlZE9wdGlvbiAmJiAhaXNTZWFyY2hpbmcgJiYgaXNDbGVhcmFibGVcIiBjbGFzcz1cInRpbWVzIGljb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uUmVtb3ZlQ2xpY2soJGV2ZW50KVwiPjwvaT5cclxuICAgICAgICAgICAgICAgICAgIDxpICpuZ0lmPVwiIXNlbGVjdGVkT3B0aW9uIHx8ICFpc0NsZWFyYWJsZVwiIGNsYXNzPVwie3sgaWNvbiB9fSBpY29uXCIgKGNsaWNrKT1cIm9uQ2FyZXRDbGljaygkZXZlbnQpXCI+PC9pPlxyXG4gICAgICAgICAgICAgICAgICAgPCEtLSBTZWxlY3QgZHJvcGRvd24gbWVudSAtLT5cclxuICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZW51XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVpRHJvcGRvd25NZW51XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFttZW51VHJhbnNpdGlvbl09XCJ0cmFuc2l0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgW21lbnVUcmFuc2l0aW9uRHVyYXRpb25dPVwidHJhbnNpdGlvbkR1cmF0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgW21lbnVBdXRvU2VsZWN0Rmlyc3RdPVwiaXNTZWFyY2hhYmxlXCI+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuICAgICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiaXNTZWFyY2hhYmxlICYmIGF2YWlsYWJsZU9wdGlvbnMubGVuZ3RoID09PSAwXCIgY2xhc3M9XCJtZXNzYWdlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IGxvY2FsZVZhbHVlcy5ub1Jlc3VsdHNNZXNzYWdlIH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgYCxcclxuICBzdHlsZXM6IFtgXHJcbiAgICAgICAgICAgICAgICAgICA6aG9zdCAudGltZXMuaWNvbiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBhdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICBsaW5lLWhlaWdodDogMS4yMTQyODU3MWVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRvcDogLjc4NTcxNDI5ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDFlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IC0uNzg1NzE0MjllbTtcclxuICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAuNjtcclxuICAgICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMDcxNDI4NTdlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNmVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAuMXMgZWFzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IC4xcyBlYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHotaW5kZXg6IDM7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgOmhvc3QgLnRpbWVzLmljb24ubGFyZ2VyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAuOTE2NjY2NjdlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44NTcxNDI4NmVtO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgIDpob3N0IC50aW1lcy5pY29uOmhvdmVyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRnVpU2VsZWN0PFQsIFU+IGV4dGVuZHMgRnVpU2VsZWN0QmFzZTxULCBVPiBpbXBsZW1lbnRzIElDdXN0b21WYWx1ZUFjY2Vzc29ySG9zdDxVPiB7XHJcblxyXG4gIHB1YmxpYyBzZWxlY3RlZE9wdGlvbj86IFQ7XHJcbiAgQE91dHB1dCgpXHJcbiAgcHVibGljIHNlbGVjdGVkT3B0aW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8VT47XHJcbiAgLy8gU3RvcmVzIHRoZSB2YWx1ZSB3cml0dGVuIGJ5IG5nTW9kZWwgYmVmb3JlIGl0IGNhbiBiZSBtYXRjaGVkIHRvIGFuIG9wdGlvbiBmcm9tIGBvcHRpb25zYC5cclxuICBwcml2YXRlIF93cml0dGVuT3B0aW9uPzogVTtcclxuICBAVmlld0NoaWxkKCdvcHRpb25UZW1wbGF0ZVNpYmxpbmcnLCB7cmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiBmYWxzZX0pXHJcbiAgcHJpdmF0ZSBfb3B0aW9uVGVtcGxhdGVTaWJsaW5nOiBWaWV3Q29udGFpbmVyUmVmO1xyXG5cclxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50UmVmLCBsb2NhbGl6YXRpb25TZXJ2aWNlOiBGdWlMb2NhbGl6YXRpb25TZXJ2aWNlKSB7XHJcbiAgICBzdXBlcihlbGVtZW50LCBsb2NhbGl6YXRpb25TZXJ2aWNlKTtcclxuXHJcbiAgICB0aGlzLnNlbGVjdGVkT3B0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxVPigpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfcGxhY2Vob2xkZXI6IHN0cmluZztcclxuXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgZ2V0IHBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXIgfHwgdGhpcy5sb2NhbGVWYWx1ZXMuc2luZ2xlLnBsYWNlaG9sZGVyO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCBwbGFjZWhvbGRlcihwbGFjZWhvbGRlcjogc3RyaW5nKSB7XHJcbiAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNlbGVjdE9wdGlvbihvcHRpb246IFQpOiB2b2lkIHtcclxuICAgIC8vIENob29zZSBhbmQgZW1pdCB0aGUgc2VsZWN0ZWQgb3B0aW9uLlxyXG4gICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IG9wdGlvbjtcclxuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25DaGFuZ2UuZW1pdCh0aGlzLnZhbHVlR2V0dGVyKG9wdGlvbikpO1xyXG5cclxuICAgIHRoaXMuZHJvcGRvd25TZXJ2aWNlLnNldE9wZW5TdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5yZXNldFF1ZXJ5KCk7XHJcblxyXG4gICAgdGhpcy5kcmF3U2VsZWN0ZWRPcHRpb24oKTtcclxuXHJcbiAgICAvLyBBdXRvbWF0aWNhbGx5IHJlZm9jdXMgdGhlIHNlYXJjaCBpbnB1dCBmb3IgYmV0dGVyIGtleWJvYXJkIGFjY2Vzc2liaWxpdHkuXHJcbiAgICB0aGlzLmZvY3VzKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgd3JpdGVWYWx1ZSh2YWx1ZTogVSk6IHZvaWQge1xyXG4gICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAodGhpcy5zZWFyY2hTZXJ2aWNlLm9wdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIElmIHRoZSBvcHRpb25zIGhhdmUgYWxyZWFkeSBiZWVuIGxvYWRlZCwgd2UgY2FuIGltbWVkaWF0ZWx5IG1hdGNoIHRoZSBuZ01vZGVsIHZhbHVlIHRvIGFuIG9wdGlvbi5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkT3B0aW9uID0gdGhpcy5maW5kT3B0aW9uKHRoaXMuc2VhcmNoU2VydmljZS5vcHRpb25zLCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZHJhd1NlbGVjdGVkT3B0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRPcHRpb24gPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVGaWVsZCAmJiB0aGlzLnNlYXJjaFNlcnZpY2UuaGFzSXRlbUxvb2t1cCkge1xyXG4gICAgICAgICAgLy8gSWYgdGhlIHNlYXJjaCBzZXJ2aWNlIGhhcyBhIHNlbGVjdGVkIGxvb2t1cCBmdW5jdGlvbiwgbWFrZSB1c2Ugb2YgdGhhdCB0byBsb2FkIHRoZSBpbml0aWFsIHZhbHVlLlxyXG4gICAgICAgICAgdGhpcy5zZWFyY2hTZXJ2aWNlXHJcbiAgICAgICAgICAgIC5pbml0aWFsTG9va3VwKHZhbHVlKVxyXG4gICAgICAgICAgICAudGhlbihpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkT3B0aW9uID0gaTtcclxuICAgICAgICAgICAgICB0aGlzLmRyYXdTZWxlY3RlZE9wdGlvbigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjYWNoZSB0aGUgd3JpdHRlbiB2YWx1ZSBmb3Igd2hlbiBvcHRpb25zIGFyZSBzZXQuXHJcbiAgICAgICAgICB0aGlzLl93cml0dGVuT3B0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNlbGVjdGVkT3B0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLmRyYXdTZWxlY3RlZE9wdGlvbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIG9uUmVtb3ZlQ2xpY2soZTogSGFuZGxlZEV2ZW50KTogdm9pZCB7XHJcbiAgICBpZiAoIWUuZXZlbnRIYW5kbGVkKSB7XHJcbiAgICAgIGUuZXZlbnRIYW5kbGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbkNoYW5nZS5lbWl0KHVuZGVmaW5lZCk7XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVkT3B0aW9ucy5mb3JFYWNoKG8gPT4gby5pc0FjdGl2ZSA9IGZhbHNlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBvcHRpb25zVXBkYXRlSG9vaygpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5fd3JpdHRlbk9wdGlvbiAmJiB0aGlzLnNlbGVjdGVkT3B0aW9uKSB7XHJcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgdGhlIG9wdGlvbiBzdGlsbCBleGlzdHMuXHJcbiAgICAgIHRoaXMud3JpdGVWYWx1ZSh0aGlzLnZhbHVlR2V0dGVyKHRoaXMuc2VsZWN0ZWRPcHRpb24pKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fd3JpdHRlbk9wdGlvbiAmJiB0aGlzLnNlYXJjaFNlcnZpY2Uub3B0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiB2YWx1ZSB3cml0dGVuIGJ5IG5nTW9kZWwgYmVmb3JlIHRoZSBvcHRpb25zIGhhZCBiZWVuIGxvYWRlZCwgdGhpcyBydW5zIHRvIGZpeCBpdC5cclxuICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IHRoaXMuZmluZE9wdGlvbih0aGlzLnNlYXJjaFNlcnZpY2Uub3B0aW9ucywgdGhpcy5fd3JpdHRlbk9wdGlvbik7XHJcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkT3B0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fd3JpdHRlbk9wdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmRyYXdTZWxlY3RlZE9wdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgcXVlcnlVcGRhdGVIb29rKCk6IHZvaWQge1xyXG4gICAgLy8gV2hlbiB0aGUgcXVlcnkgaXMgdXBkYXRlZCwgd2UganVzdCBhYmFuZG9uIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb24gPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgaW5pdGlhbGlzZVJlbmRlcmVkT3B0aW9uKG9wdGlvbjogRnVpU2VsZWN0T3B0aW9uPFQ+KTogdm9pZCB7XHJcbiAgICBzdXBlci5pbml0aWFsaXNlUmVuZGVyZWRPcHRpb24ob3B0aW9uKTtcclxuXHJcbiAgICAvLyBCb2xkZW5zIHRoZSBpdGVtIHNvIGl0IGFwcGVhcnMgc2VsZWN0ZWQgaW4gdGhlIGRyb3Bkb3duLlxyXG4gICAgb3B0aW9uLmlzQWN0aXZlID0gb3B0aW9uLnZhbHVlID09PSB0aGlzLnNlbGVjdGVkT3B0aW9uO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkcmF3U2VsZWN0ZWRPcHRpb24oKTogdm9pZCB7XHJcbiAgICAvLyBVcGRhdGVzIHRoZSBhY3RpdmUgY2xhc3Mgb24gdGhlIG5ld2x5IHNlbGVjdGVkIG9wdGlvbi5cclxuICAgIGlmICh0aGlzLl9yZW5kZXJlZE9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5vbkF2YWlsYWJsZU9wdGlvbnNSZW5kZXJlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnNlbGVjdGVkT3B0aW9uICE9IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvblRlbXBsYXRlKSB7XHJcbiAgICAgIHRoaXMuZHJhd1RlbXBsYXRlKHRoaXMuX29wdGlvblRlbXBsYXRlU2libGluZywgdGhpcy5zZWxlY3RlZE9wdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBWYWx1ZSBhY2Nlc3NvciBkaXJlY3RpdmUgZm9yIHRoZSBzZWxlY3QgdG8gc3VwcG9ydCBuZ01vZGVsLlxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ2Z1aS1zZWxlY3QnLFxyXG4gIGhvc3Q6IHtcclxuICAgICcoc2VsZWN0ZWRPcHRpb25DaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudCknLFxyXG4gICAgJyh0b3VjaGVkKSc6ICdvblRvdWNoZWQoKSdcclxuICB9LFxyXG4gIHByb3ZpZGVyczogW2N1c3RvbVZhbHVlQWNjZXNzb3JGYWN0b3J5KEZ1aVNlbGVjdFZhbHVlQWNjZXNzb3IpXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRnVpU2VsZWN0VmFsdWVBY2Nlc3NvcjxULCBVPiBleHRlbmRzIEN1c3RvbVZhbHVlQWNjZXNzb3I8VSwgRnVpU2VsZWN0PFQsIFU+PiB7XHJcbiAgY29uc3RydWN0b3IoaG9zdDogRnVpU2VsZWN0PFQsIFU+KSB7XHJcbiAgICBzdXBlcihob3N0KTtcclxuICB9XHJcbn1cclxuIl19