/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Directive, ElementRef, EventEmitter, HostBinding, Input, Output } from '@angular/core';
import { CustomValueAccessor, customValueAccessorFactory, KeyCode } from '../../../misc/util/internal';
import { FuiLocalizationService } from '../../../behaviors/localization/internal';
import { FuiSelectBase } from '../classes/select-base';
/**
 * @template T, U
 */
export class FuiMultiSelect extends FuiSelectBase {
    /**
     * @param {?} element
     * @param {?} localizationService
     */
    constructor(element, localizationService) {
        super(element, localizationService);
        this.selectedOptions = [];
        this.selectedOptionsChange = new EventEmitter();
        this.hasLabels = true;
        this.hasClasses = true;
    }
    /**
     * @return {?}
     */
    get filteredOptions() {
        if (this.maxSelectedReached) {
            // If we have reached the maximum number of selections, then empty the results completely.
            return [];
        }
        /** @type {?} */
        const searchResults = this.searchService.results;
        if (!this.hasLabels) {
            return searchResults;
        }
        else {
            // Returns the search results \ selected options.
            return searchResults
                .filter((/**
             * @param {?} r
             * @return {?}
             */
            r => this.selectedOptions.find((/**
             * @param {?} o
             * @return {?}
             */
            o => r === o)) == undefined));
        }
    }
    /**
     * @return {?}
     */
    get availableOptions() {
        return this.filteredOptions;
    }
    /**
     * @return {?}
     */
    get maxSelectedReached() {
        if (this.maxSelected == undefined) {
            // If there is no maximum then we can immediately return.
            return false;
        }
        return this.selectedOptions.length === this.maxSelected;
    }
    /**
     * @return {?}
     */
    get maxSelectedMessage() {
        return this._localizationService.interpolate(this.localeValues.multi.maxSelectedMessage, [['max', this.maxSelected.toString()]]);
    }
    /**
     * @return {?}
     */
    get selectedMessage() {
        return this._localizationService.interpolate(this.localeValues.multi.selectedMessage, [['count', this.selectedOptions.length.toString() === '0' && this._showCountText ?
                    this._showCountText : this.selectedOptions.length.toString()]]);
    }
    /**
     * @return {?}
     */
    get hasLabels() {
        return this._hasLabels;
    }
    /**
     * @param {?} hasLabels
     * @return {?}
     */
    set hasLabels(hasLabels) {
        this._hasLabels = hasLabels;
    }
    /**
     * @return {?}
     */
    get showCountText() {
        return this._showCountText;
    }
    /**
     * @param {?} showCountText
     * @return {?}
     */
    set showCountText(showCountText) {
        this._showCountText = showCountText;
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder || this.localeValues.multi.placeholder;
    }
    /**
     * @param {?} placeholder
     * @return {?}
     */
    set placeholder(placeholder) {
        this._placeholder = placeholder;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    selectOption(option) {
        if (this.selectedOptions.indexOf(option) !== -1) {
            this.deselectOption(option);
            return;
        }
        this.selectedOptions.push(option);
        this.selectedOptionsChange.emit(this.selectedOptions.map((/**
         * @param {?} o
         * @return {?}
         */
        o => this.valueGetter(o))));
        this.resetQuery(false);
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
        if (!this.hasLabels) {
            this.onAvailableOptionsRendered();
        }
    }
    /**
     * @param {?} values
     * @return {?}
     */
    writeValue(values) {
        if (values instanceof Array) {
            if (this.searchService.options.length > 0) {
                // If the options have already been loaded, we can immediately match the ngModel values to options.
                this.selectedOptions = values
                    // non-null assertion added here because Typescript doesn't recognise the non-null filter.
                    .map((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => (/** @type {?} */ (this.findOption(this.searchService.options, v)))))
                    .filter((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => v != undefined));
            }
            if (values.length > 0 && this.selectedOptions.length === 0) {
                if (this.searchService.hasItemLookup) {
                    // If the search service has a selected lookup function, make use of that to load the initial values.
                    this.searchService
                        .initialLookup(values)
                        .then((/**
                     * @param {?} items
                     * @return {?}
                     */
                    items => this.selectedOptions = items));
                }
                else {
                    // Otherwise, cache the written value for when options are set.
                    this._writtenOptions = values;
                }
            }
            if (values.length === 0) {
                this.selectedOptions = [];
            }
        }
        else {
            this.selectedOptions = [];
        }
    }
    /**
     * @param {?} option
     * @return {?}
     */
    deselectOption(option) {
        // Update selected options to the previously selected options \ {option}.
        this.selectedOptions = this.selectedOptions.filter((/**
         * @param {?} so
         * @return {?}
         */
        so => so !== option));
        this.selectedOptionsChange.emit(this.selectedOptions.map((/**
         * @param {?} o
         * @return {?}
         */
        o => this.valueGetter(o))));
        // Automatically refocus the search input for better keyboard accessibility.
        this.focus();
        if (!this.hasLabels) {
            this.onAvailableOptionsRendered();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onQueryInputKeydown(event) {
        if (event.keyCode === KeyCode.Backspace && this.query === '' && this.selectedOptions.length > 0) {
            // Deselect the rightmost option when the user presses backspace in the search input.
            this.deselectOption(this.selectedOptions[this.selectedOptions.length - 1]);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    optionsUpdateHook() {
        if (!this._writtenOptions && this.selectedOptions.length > 0) {
            // We need to check the options still exist.
            this.writeValue(this.selectedOptions.map((/**
             * @param {?} o
             * @return {?}
             */
            o => this.valueGetter(o))));
        }
        if (this._writtenOptions && this.searchService.options.length > 0) {
            // If there were values written by ngModel before the options had been loaded, this runs to fix it.
            this.selectedOptions = this._writtenOptions
                // non-null assertion added here because Typescript doesn't recognise the non-null filter.
                .map((/**
             * @param {?} v
             * @return {?}
             */
            v => (/** @type {?} */ (this.findOption(this.searchService.options, v)))))
                .filter((/**
             * @param {?} v
             * @return {?}
             */
            v => v != undefined));
            if (this.selectedOptions.length === this._writtenOptions.length) {
                this._writtenOptions = undefined;
            }
        }
    }
    /**
     * @protected
     * @param {?} option
     * @return {?}
     */
    initialiseRenderedOption(option) {
        super.initialiseRenderedOption(option);
        // Boldens the item so it appears selected in the dropdown.
        option.isActive = !this.hasLabels && this.selectedOptions.indexOf(option.value) !== -1;
    }
}
FuiMultiSelect.decorators = [
    { type: Component, args: [{
                selector: 'fui-multi-select',
                template: `
<!-- Dropdown icon -->
<i class="{{ icon }} icon" (click)="onCaretClick($event)"></i>

<ng-container *ngIf="hasLabels">
<!-- Multi-select labels -->
    <fui-multi-select-label *ngFor="let selected of selectedOptions;"
                            [value]="selected"
                            [query]="query"
                            [formatter]="configuredFormatter"
                            [template]="optionTemplate"
                            (deselected)="deselectOption($event)"></fui-multi-select-label>
</ng-container>

<!-- Query input -->
<input fuiSelectSearch
       type="text"
       [hidden]="!isSearchable || isSearchExternal">

<!-- Helper text -->
<div class="text"
     [class.default]="hasLabels"
     [class.filtered]="!!query && !isSearchExternal">

    <!-- Placeholder text -->
    <ng-container *ngIf="hasLabels; else selectedBlock">{{ placeholder }}</ng-container>

    <!-- Summary shown when labels are hidden -->
    <ng-template #selectedBlock> {{ selectedMessage }}</ng-template>
</div>

<!-- Select dropdown menu -->
<div class="menu"
     fuiDropdownMenu
     [menuTransition]="transition"
     [menuTransitionDuration]="transitionDuration"
     [menuAutoSelectFirst]="true">

    <ng-content></ng-content>
    <ng-container *ngIf="availableOptions.length == 0 ">
        <div *ngIf="!maxSelectedReached" class="message">{{ localeValues.noResultsMessage }}</div>
        <div *ngIf="maxSelectedReached" class="message">{{ maxSelectedMessage }}</div>
    </ng-container>
</div>
`,
                styles: [`
:host input.search {
    width: 12em !important;
}
`]
            }] }
];
/** @nocollapse */
FuiMultiSelect.ctorParameters = () => [
    { type: ElementRef },
    { type: FuiLocalizationService }
];
FuiMultiSelect.propDecorators = {
    selectedOptionsChange: [{ type: Output }],
    maxSelected: [{ type: Input }],
    hasClasses: [{ type: HostBinding, args: ['class.multiple',] }],
    hasLabels: [{ type: Input }],
    showCountText: [{ type: Input }],
    placeholder: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FuiMultiSelect.prototype.selectedOptions;
    /** @type {?} */
    FuiMultiSelect.prototype.selectedOptionsChange;
    /** @type {?} */
    FuiMultiSelect.prototype.maxSelected;
    /** @type {?} */
    FuiMultiSelect.prototype.hasClasses;
    /**
     * @type {?}
     * @private
     */
    FuiMultiSelect.prototype._writtenOptions;
    /**
     * @type {?}
     * @private
     */
    FuiMultiSelect.prototype._hasLabels;
    /**
     * @type {?}
     * @private
     */
    FuiMultiSelect.prototype._showCountText;
    /**
     * @type {?}
     * @private
     */
    FuiMultiSelect.prototype._placeholder;
}
// Value accessor directive for the select to support ngModel.
/**
 * @template T, U
 */
export class FuiMultiSelectValueAccessor extends CustomValueAccessor {
    /**
     * @param {?} host
     */
    constructor(host) {
        super(host);
    }
}
FuiMultiSelectValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'fui-multi-select',
                host: {
                    '(selectedOptionsChange)': 'onChange($event)',
                    '(touched)': 'onTouched()'
                },
                providers: [customValueAccessorFactory(FuiMultiSelectValueAccessor)]
            },] }
];
/** @nocollapse */
FuiMultiSelectValueAccessor.ctorParameters = () => [
    { type: FuiMultiSelect }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVsdGktc2VsZWN0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWZvbWFudGljLXVpLyIsInNvdXJjZXMiOlsibW9kdWxlcy9zZWxlY3QvY29tcG9uZW50cy9tdWx0aS1zZWxlY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDekcsT0FBTyxFQUFDLG1CQUFtQixFQUFFLDBCQUEwQixFQUE0QixPQUFPLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUMvSCxPQUFPLEVBQUMsc0JBQXNCLEVBQUMsTUFBTSwwQ0FBMEMsQ0FBQztBQUNoRixPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sd0JBQXdCLENBQUM7Ozs7QUF3RHJELE1BQU0sT0FBTyxjQUFxQixTQUFRLGFBQW1COzs7OztJQVkzRCxZQUFZLE9BQW1CLEVBQUUsbUJBQTJDO1FBQzFFLEtBQUssQ0FBQyxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztRQUVwQyxJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUVyRCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztRQUN0QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztJQUN6QixDQUFDOzs7O0lBRUQsSUFBVyxlQUFlO1FBQ3hCLElBQUksSUFBSSxDQUFDLGtCQUFrQixFQUFFO1lBQzNCLDBGQUEwRjtZQUMxRixPQUFPLEVBQUUsQ0FBQztTQUNYOztjQUVLLGFBQWEsR0FBUSxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU87UUFFckQsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsT0FBTyxhQUFhLENBQUM7U0FDdEI7YUFBTTtZQUNMLGlE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QixLQUFLOzRCQVdMLEtBQUs7MEJBV0wsS0FBSzs7OztJQXRGTix5Q0FBNEI7O0lBQzVCLCtDQUNnRDs7SUFDaEQscUNBQzJCOztJQUMzQixvQ0FDb0M7Ozs7O0lBRXBDLHlDQUE4Qjs7Ozs7SUFzRDlCLG9DQUE0Qjs7Ozs7SUFXNUIsd0NBQStCOzs7OztJQVcvQixzQ0FBNkI7Ozs7OztBQWlIL0IsTUFBTSxPQUFPLDJCQUFrQyxTQUFRLG1CQUE4Qzs7OztJQUNuRyxZQUFZLElBQTBCO1FBQ3BDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNkLENBQUM7OztZQVhGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsa0JBQWtCO2dCQUM1QixJQUFJLEVBQUU7b0JBQ0oseUJBQXlCLEVBQUUsa0JBQWtCO29CQUM3QyxXQUFXLEVBQUUsYUFBYTtpQkFDM0I7Z0JBQ0QsU0FBUyxFQUFFLENBQUMsMEJBQTBCLENBQUMsMkJBQTJCLENBQUMsQ0FBQzthQUNyRTs7OztZQUVtQixjQUFjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb21wb25lbnQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSW5wdXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7Q3VzdG9tVmFsdWVBY2Nlc3NvciwgY3VzdG9tVmFsdWVBY2Nlc3NvckZhY3RvcnksIElDdXN0b21WYWx1ZUFjY2Vzc29ySG9zdCwgS2V5Q29kZX0gZnJvbSAnLi4vLi4vLi4vbWlzYy91dGlsL2ludGVybmFsJztcclxuaW1wb3J0IHtGdWlMb2NhbGl6YXRpb25TZXJ2aWNlfSBmcm9tICcuLi8uLi8uLi9iZWhhdmlvcnMvbG9jYWxpemF0aW9uL2ludGVybmFsJztcclxuaW1wb3J0IHtGdWlTZWxlY3RCYXNlfSBmcm9tICcuLi9jbGFzc2VzL3NlbGVjdC1iYXNlJztcclxuaW1wb3J0IHtGdWlTZWxlY3RPcHRpb259IGZyb20gJy4vc2VsZWN0LW9wdGlvbic7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2Z1aS1tdWx0aS1zZWxlY3QnLFxyXG4gIHRlbXBsYXRlOiBgXHJcbjwhLS0gRHJvcGRvd24gaWNvbiAtLT5cclxuPGkgY2xhc3M9XCJ7eyBpY29uIH19IGljb25cIiAoY2xpY2spPVwib25DYXJldENsaWNrKCRldmVudClcIj48L2k+XHJcblxyXG48bmctY29udGFpbmVyICpuZ0lmPVwiaGFzTGFiZWxzXCI+XHJcbjwhLS0gTXVsdGktc2VsZWN0IGxhYmVscyAtLT5cclxuICAgIDxmdWktbXVsdGktc2VsZWN0LWxhYmVsICpuZ0Zvcj1cImxldCBzZWxlY3RlZCBvZiBzZWxlY3RlZE9wdGlvbnM7XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJzZWxlY3RlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcXVlcnldPVwicXVlcnlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Zvcm1hdHRlcl09XCJjb25maWd1cmVkRm9ybWF0dGVyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZV09XCJvcHRpb25UZW1wbGF0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVzZWxlY3RlZCk9XCJkZXNlbGVjdE9wdGlvbigkZXZlbnQpXCI+PC9mdWktbXVsdGktc2VsZWN0LWxhYmVsPlxyXG48L25nLWNvbnRhaW5lcj5cclxuXHJcbjwhLS0gUXVlcnkgaW5wdXQgLS0+XHJcbjxpbnB1dCBmdWlTZWxlY3RTZWFyY2hcclxuICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgIFtoaWRkZW5dPVwiIWlzU2VhcmNoYWJsZSB8fCBpc1NlYXJjaEV4dGVybmFsXCI+XHJcblxyXG48IS0tIEhlbHBlciB0ZXh0IC0tPlxyXG48ZGl2IGNsYXNzPVwidGV4dFwiXHJcbiAgICAgW2NsYXNzLmRlZmF1bHRdPVwiaGFzTGFiZWxzXCJcclxuICAgICBbY2xhc3MuZmlsdGVyZWRdPVwiISFxdWVyeSAmJiAhaXNTZWFyY2hFeHRlcm5hbFwiPlxyXG5cclxuICAgIDwhLS0gUGxhY2Vob2xkZXIgdGV4dCAtLT5cclxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJoYXNMYWJlbHM7IGVsc2Ugc2VsZWN0ZWRCbG9ja1wiPnt7IHBsYWNlaG9sZGVyIH19PC9uZy1jb250YWluZXI+XHJcblxyXG4gICAgPCEtLSBTdW1tYXJ5IHNob3duIHdoZW4gbGFiZWxzIGFyZSBoaWRkZW4gLS0+XHJcbiAgICA8bmctdGVtcGxhdGUgI3NlbGVjdGVkQmxvY2s+IHt7IHNlbGVjdGVkTWVzc2FnZSB9fTwvbmctdGVtcGxhdGU+XHJcbjwvZGl2PlxyXG5cclxuPCEtLSBTZWxlY3QgZHJvcGRvd24gbWVudSAtLT5cclxuPGRpdiBjbGFzcz1cIm1lbnVcIlxyXG4gICAgIGZ1aURyb3Bkb3duTWVudVxyXG4gICAgIFttZW51VHJhbnNpdGlvbl09XCJ0cmFuc2l0aW9uXCJcclxuICAgICBbbWVudVRyYW5zaXRpb25EdXJhdGlvbl09XCJ0cmFuc2l0aW9uRHVyYXRpb25cIlxyXG4gICAgIFttZW51QXV0b1NlbGVjdEZpcnN0XT1cInRydWVcIj5cclxuXHJcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiYXZhaWxhYmxlT3B0aW9ucy5sZW5ndGggPT0gMCBcIj5cclxuICAgICAgICA8ZGl2ICpuZ0lmPVwiIW1heFNlbGVjdGVkUmVhY2hlZFwiIGNsYXNzPVwibWVzc2FnZVwiPnt7IGxvY2FsZVZhbHVlcy5ub1Jlc3VsdHNNZXNzYWdlIH19PC9kaXY+XHJcbiAgICAgICAgPGRpdiAqbmdJZj1cIm1heFNlbGVjdGVkUmVhY2hlZFwiIGNsYXNzPVwibWVzc2FnZVwiPnt7IG1heFNlbGVjdGVkTWVzc2FnZSB9fTwvZGl2PlxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcbjwvZGl2PlxyXG5gLFxyXG4gIHN0eWxlczogW2BcclxuOmhvc3QgaW5wdXQuc2VhcmNoIHtcclxuICAgIHdpZHRoOiAxMmVtICFpbXBvcnRhbnQ7XHJcbn1cclxuYF1cclxufSlcclxuZXhwb3J0IGNsYXNzIEZ1aU11bHRpU2VsZWN0PFQsIFU+IGV4dGVuZHMgRnVpU2VsZWN0QmFzZTxULCBVPiBpbXBsZW1lbnRzIElDdXN0b21WYWx1ZUFjY2Vzc29ySG9zdDxVW10+IHtcclxuXHJcbiAgcHVibGljIHNlbGVjdGVkT3B0aW9uczogVFtdO1xyXG4gIEBPdXRwdXQoKVxyXG4gIHB1YmxpYyBzZWxlY3RlZE9wdGlvbnNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxVW10+O1xyXG4gIEBJbnB1dCgpXHJcbiAgcHVibGljIG1heFNlbGVjdGVkOiBudW1iZXI7XHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5tdWx0aXBsZScpXHJcbiAgcHVibGljIHJlYWRvbmx5IGhhc0NsYXNzZXM6IGJvb2xlYW47XHJcbiAgLy8gU3RvcmVzIHRoZSB2YWx1ZXMgd3JpdHRlbiBieSBuZ01vZGVsIGJlZm9yZSBpdCBjYW4gYmUgbWF0Y2hlZCB0byBhbiBvcHRpb24gZnJvbSBgb3B0aW9uc2AuXHJcbiAgcHJpdmF0ZSBfd3JpdHRlbk9wdGlvbnM/OiBVW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGxvY2FsaXphdGlvblNlcnZpY2U6IEZ1aUxvY2FsaXphdGlvblNlcnZpY2UpIHtcclxuICAgIHN1cGVyKGVsZW1lbnQsIGxvY2FsaXphdGlvblNlcnZpY2UpO1xyXG5cclxuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25zID0gW107XHJcbiAgICB0aGlzLnNlbGVjdGVkT3B0aW9uc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8VVtdPigpO1xyXG5cclxuICAgIHRoaXMuaGFzTGFiZWxzID0gdHJ1ZTtcclxuICAgIHRoaXMuaGFzQ2xhc3NlcyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IGZpbHRlcmVkT3B0aW9ucygpOiBUW10ge1xyXG4gICAgaWYgKHRoaXMubWF4U2VsZWN0ZWRSZWFjaGVkKSB7XHJcbiAgICAgIC8vIElmIHdlIGhhdmUgcmVhY2hlZCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc2VsZWN0aW9ucywgdGhlbiBlbXB0eSB0aGUgcmVzdWx0cyBjb21wbGV0ZWx5LlxyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2VhcmNoUmVzdWx0czogVFtdID0gdGhpcy5zZWFyY2hTZXJ2aWNlLnJlc3VsdHM7XHJcblxyXG4gICAgaWYgKCF0aGlzLmhhc0xhYmVscykge1xyXG4gICAgICByZXR1cm4gc2VhcmNoUmVzdWx0cztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJldHVybnMgdGhlIHNlYXJjaCByZXN1bHRzIFxcIHNlbGVjdGVkIG9wdGlvbnMuXHJcbiAgICAgIHJldHVybiBzZWFyY2hSZXN1bHRzXHJcbiAgICAgICAgLmZpbHRlcihyID0+IHRoaXMuc2VsZWN0ZWRPcHRpb25zLmZpbmQobyA9PiByID09PSBvKSA9PSB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBhdmFpbGFibGVPcHRpb25zKCk6IFRbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJlZE9wdGlvbnM7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IG1heFNlbGVjdGVkUmVhY2hlZCgpOiBib29sZWFuIHtcclxuICAgIGlmICh0aGlzLm1heFNlbGVjdGVkID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBtYXhpbXVtIHRoZW4gd2UgY2FuIGltbWVkaWF0ZWx5IHJldHVybi5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRPcHRpb25zLmxlbmd0aCA9PT0gdGhpcy5tYXhTZWxlY3RlZDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgbWF4U2VsZWN0ZWRNZXNzYWdlKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxpemF0aW9uU2VydmljZS5pbnRlcnBvbGF0ZShcclxuICAgICAgdGhpcy5sb2NhbGVWYWx1ZXMubXVsdGkubWF4U2VsZWN0ZWRNZXNzYWdlLFxyXG4gICAgICBbWydtYXgnLCB0aGlzLm1heFNlbGVjdGVkLnRvU3RyaW5nKCldXSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHNlbGVjdGVkTWVzc2FnZSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsaXphdGlvblNlcnZpY2UuaW50ZXJwb2xhdGUoXHJcbiAgICAgIHRoaXMubG9jYWxlVmFsdWVzLm11bHRpLnNlbGVjdGVkTWVzc2FnZSxcclxuICAgICAgW1snY291bnQnLCB0aGlzLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGgudG9TdHJpbmcoKSA9PT0gJzAnICYmIHRoaXMuX3Nob3dDb3VudFRleHQgP1xyXG4gICAgICAgIHRoaXMuX3Nob3dDb3VudFRleHQgOiB0aGlzLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGgudG9TdHJpbmcoKV1dKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX2hhc0xhYmVsczogYm9vbGVhbjtcclxuXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgZ2V0IGhhc0xhYmVscygpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9oYXNMYWJlbHM7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0IGhhc0xhYmVscyhoYXNMYWJlbHM6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMuX2hhc0xhYmVscyA9IGhhc0xhYmVscztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3Nob3dDb3VudFRleHQ6IHN0cmluZztcclxuXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgZ2V0IHNob3dDb3VudFRleHQoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLl9zaG93Q291bnRUZXh0O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCBzaG93Q291bnRUZXh0KHNob3dDb3VudFRleHQ6IHN0cmluZykge1xyXG4gICAgdGhpcy5fc2hvd0NvdW50VGV4dCA9IHNob3dDb3VudFRleHQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9wbGFjZWhvbGRlcjogc3RyaW5nO1xyXG5cclxuICBASW5wdXQoKVxyXG4gIHB1YmxpYyBnZXQgcGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLl9wbGFjZWhvbGRlciB8fCB0aGlzLmxvY2FsZVZhbHVlcy5tdWx0aS5wbGFjZWhvbGRlcjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXQgcGxhY2Vob2xkZXIocGxhY2Vob2xkZXI6IHN0cmluZykge1xyXG4gICAgdGhpcy5fcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZWxlY3RPcHRpb24ob3B0aW9uOiBUKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5zZWxlY3RlZE9wdGlvbnMuaW5kZXhPZihvcHRpb24pICE9PSAtMSkge1xyXG4gICAgICB0aGlzLmRlc2VsZWN0T3B0aW9uKG9wdGlvbik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25zLnB1c2gob3B0aW9uKTtcclxuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25zQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZE9wdGlvbnMubWFwKG8gPT4gdGhpcy52YWx1ZUdldHRlcihvKSkpO1xyXG5cclxuICAgIHRoaXMucmVzZXRRdWVyeShmYWxzZSk7XHJcblxyXG4gICAgLy8gQXV0b21hdGljYWxseSByZWZvY3VzIHRoZSBzZWFyY2ggaW5wdXQgZm9yIGJldHRlciBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5LlxyXG4gICAgdGhpcy5mb2N1cygpO1xyXG5cclxuICAgIGlmICghdGhpcy5oYXNMYWJlbHMpIHtcclxuICAgICAgdGhpcy5vbkF2YWlsYWJsZU9wdGlvbnNSZW5kZXJlZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHdyaXRlVmFsdWUodmFsdWVzOiBVW10pOiB2b2lkIHtcclxuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICBpZiAodGhpcy5zZWFyY2hTZXJ2aWNlLm9wdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIElmIHRoZSBvcHRpb25zIGhhdmUgYWxyZWFkeSBiZWVuIGxvYWRlZCwgd2UgY2FuIGltbWVkaWF0ZWx5IG1hdGNoIHRoZSBuZ01vZGVsIHZhbHVlcyB0byBvcHRpb25zLlxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25zID0gdmFsdWVzXHJcbiAgICAgICAgLy8gbm9uLW51bGwgYXNzZXJ0aW9uIGFkZGVkIGhlcmUgYmVjYXVzZSBUeXBlc2NyaXB0IGRvZXNuJ3QgcmVjb2duaXNlIHRoZSBub24tbnVsbCBmaWx0ZXIuXHJcbiAgICAgICAgICAubWFwKHYgPT4gdGhpcy5maW5kT3B0aW9uKHRoaXMuc2VhcmNoU2VydmljZS5vcHRpb25zLCB2KSEpXHJcbiAgICAgICAgICAuZmlsdGVyKHYgPT4gdiAhPSB1bmRlZmluZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCAmJiB0aGlzLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBpZiAodGhpcy5zZWFyY2hTZXJ2aWNlLmhhc0l0ZW1Mb29rdXApIHtcclxuICAgICAgICAgIC8vIElmIHRoZSBzZWFyY2ggc2VydmljZSBoYXMgYSBzZWxlY3RlZCBsb29rdXAgZnVuY3Rpb24sIG1ha2UgdXNlIG9mIHRoYXQgdG8gbG9hZCB0aGUgaW5pdGlhbCB2YWx1ZXMuXHJcbiAgICAgICAgICB0aGlzLnNlYXJjaFNlcnZpY2VcclxuICAgICAgICAgICAgLmluaXRpYWxMb29rdXAodmFsdWVzKVxyXG4gICAgICAgICAgICAudGhlbihpdGVtcyA9PiB0aGlzLnNlbGVjdGVkT3B0aW9ucyA9IGl0ZW1zKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjYWNoZSB0aGUgd3JpdHRlbiB2YWx1ZSBmb3Igd2hlbiBvcHRpb25zIGFyZSBzZXQuXHJcbiAgICAgICAgICB0aGlzLl93cml0dGVuT3B0aW9ucyA9IHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkT3B0aW9ucyA9IFtdO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNlbGVjdGVkT3B0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGRlc2VsZWN0T3B0aW9uKG9wdGlvbjogVCk6IHZvaWQge1xyXG4gICAgLy8gVXBkYXRlIHNlbGVjdGVkIG9wdGlvbnMgdG8gdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgb3B0aW9ucyBcXCB7b3B0aW9ufS5cclxuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25zID0gdGhpcy5zZWxlY3RlZE9wdGlvbnMuZmlsdGVyKHNvID0+IHNvICE9PSBvcHRpb24pO1xyXG4gICAgdGhpcy5zZWxlY3RlZE9wdGlvbnNDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkT3B0aW9ucy5tYXAobyA9PiB0aGlzLnZhbHVlR2V0dGVyKG8pKSk7XHJcblxyXG4gICAgLy8gQXV0b21hdGljYWxseSByZWZvY3VzIHRoZSBzZWFyY2ggaW5wdXQgZm9yIGJldHRlciBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5LlxyXG4gICAgdGhpcy5mb2N1cygpO1xyXG5cclxuICAgIGlmICghdGhpcy5oYXNMYWJlbHMpIHtcclxuICAgICAgdGhpcy5vbkF2YWlsYWJsZU9wdGlvbnNSZW5kZXJlZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIG9uUXVlcnlJbnB1dEtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlDb2RlLkJhY2tzcGFjZSAmJiB0aGlzLnF1ZXJ5ID09PSAnJyAmJiB0aGlzLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIERlc2VsZWN0IHRoZSByaWdodG1vc3Qgb3B0aW9uIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBiYWNrc3BhY2UgaW4gdGhlIHNlYXJjaCBpbnB1dC5cclxuICAgICAgdGhpcy5kZXNlbGVjdE9wdGlvbih0aGlzLnNlbGVjdGVkT3B0aW9uc1t0aGlzLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGggLSAxXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgb3B0aW9uc1VwZGF0ZUhvb2soKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX3dyaXR0ZW5PcHRpb25zICYmIHRoaXMuc2VsZWN0ZWRPcHRpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB0aGUgb3B0aW9ucyBzdGlsbCBleGlzdC5cclxuICAgICAgdGhpcy53cml0ZVZhbHVlKHRoaXMuc2VsZWN0ZWRPcHRpb25zLm1hcChvID0+IHRoaXMudmFsdWVHZXR0ZXIobykpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fd3JpdHRlbk9wdGlvbnMgJiYgdGhpcy5zZWFyY2hTZXJ2aWNlLm9wdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBJZiB0aGVyZSB3ZXJlIHZhbHVlcyB3cml0dGVuIGJ5IG5nTW9kZWwgYmVmb3JlIHRoZSBvcHRpb25zIGhhZCBiZWVuIGxvYWRlZCwgdGhpcyBydW5zIHRvIGZpeCBpdC5cclxuICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbnMgPSB0aGlzLl93cml0dGVuT3B0aW9uc1xyXG4gICAgICAvLyBub24tbnVsbCBhc3NlcnRpb24gYWRkZWQgaGVyZSBiZWNhdXNlIFR5cGVzY3JpcHQgZG9lc24ndCByZWNvZ25pc2UgdGhlIG5vbi1udWxsIGZpbHRlci5cclxuICAgICAgICAubWFwKHYgPT4gdGhpcy5maW5kT3B0aW9uKHRoaXMuc2VhcmNoU2VydmljZS5vcHRpb25zLCB2KSEpXHJcbiAgICAgICAgLmZpbHRlcih2ID0+IHYgIT0gdW5kZWZpbmVkKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPT09IHRoaXMuX3dyaXR0ZW5PcHRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuX3dyaXR0ZW5PcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgaW5pdGlhbGlzZVJlbmRlcmVkT3B0aW9uKG9wdGlvbjogRnVpU2VsZWN0T3B0aW9uPFQ+KTogdm9pZCB7XHJcbiAgICBzdXBlci5pbml0aWFsaXNlUmVuZGVyZWRPcHRpb24ob3B0aW9uKTtcclxuXHJcbiAgICAvLyBCb2xkZW5zIHRoZSBpdGVtIHNvIGl0IGFwcGVhcnMgc2VsZWN0ZWQgaW4gdGhlIGRyb3Bkb3duLlxyXG4gICAgb3B0aW9uLmlzQWN0aXZlID0gIXRoaXMuaGFzTGFiZWxzICYmIHRoaXMuc2VsZWN0ZWRPcHRpb25zLmluZGV4T2Yob3B0aW9uLnZhbHVlKSAhPT0gLTE7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBWYWx1ZSBhY2Nlc3NvciBkaXJlY3RpdmUgZm9yIHRoZSBzZWxlY3QgdG8gc3VwcG9ydCBuZ01vZGVsLlxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ2Z1aS1tdWx0aS1zZWxlY3QnLFxyXG4gIGhvc3Q6IHtcclxuICAgICcoc2VsZWN0ZWRPcHRpb25zQ2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQpJyxcclxuICAgICcodG91Y2hlZCknOiAnb25Ub3VjaGVkKCknXHJcbiAgfSxcclxuICBwcm92aWRlcnM6IFtjdXN0b21WYWx1ZUFjY2Vzc29yRmFjdG9yeShGdWlNdWx0aVNlbGVjdFZhbHVlQWNjZXNzb3IpXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRnVpTXVsdGlTZWxlY3RWYWx1ZUFjY2Vzc29yPFQsIFU+IGV4dGVuZHMgQ3VzdG9tVmFsdWVBY2Nlc3NvcjxVW10sIEZ1aU11bHRpU2VsZWN0PFQsIFU+PiB7XHJcbiAgY29uc3RydWN0b3IoaG9zdDogRnVpTXVsdGlTZWxlY3Q8VCwgVT4pIHtcclxuICAgIHN1cGVyKGhvc3QpO1xyXG4gIH1cclxufVxyXG4iXX0=