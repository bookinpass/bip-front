/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Component, ElementRef, EventEmitter, HostBinding, HostListener, Input, Output, Renderer2, TemplateRef, ViewChild, ViewContainerRef } from '@angular/core';
import { FuiTransition, Transition, TransitionController, TransitionDirection } from '../../transition/internal';
import { HandledEvent, FuiComponentFactory } from '../../../misc/util/internal';
// See https://github.com/Microsoft/TypeScript/issues/13449.
/** @type {?} */
const templateRef = TemplateRef;
/**
 * @template T
 */
export class FuiMultiSelectLabel extends FuiTransition {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     * @param {?} componentFactory
     */
    constructor(renderer, element, changeDetector, componentFactory) {
        super(renderer, element, changeDetector);
        this.componentFactory = componentFactory;
        // Initialise transition functionality.
        this._transitionController = new TransitionController(false, 'inline-block');
        this.setTransitionController(this._transitionController);
        this.onDeselected = new EventEmitter();
        this.hasClasses = true;
        this._transitionController.animate(new Transition('scale', 100, TransitionDirection.In));
    }
    /**
     * @return {?}
     */
    get template() {
        return this._template;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    set template(template) {
        this._template = template;
        if (this.template) {
            this.componentFactory.createView(this.templateSibling, this.template, {
                $implicit: this.value,
                query: this.query
            });
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    deselectOption(e) {
        e.eventHandled = true;
        this._transitionController.animate(new Transition('scale', 100, TransitionDirection.Out, (/**
         * @return {?}
         */
        () => this.onDeselected.emit(this.value))));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        e.eventHandled = true;
    }
}
FuiMultiSelectLabel.decorators = [
    { type: Component, args: [{
                selector: 'fui-multi-select-label',
                template: `
<span #templateSibling></span>
<span *ngIf="!template" [innerHTML]="formatter(value)"></span>
<i class="delete icon" (click)="deselectOption($event)"></i>
`
            }] }
];
/** @nocollapse */
FuiMultiSelectLabel.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: FuiComponentFactory }
];
FuiMultiSelectLabel.propDecorators = {
    hasClasses: [{ type: HostBinding, args: ['class.ui',] }, { type: HostBinding, args: ['class.label',] }],
    value: [{ type: Input }],
    query: [{ type: Input }],
    onDeselected: [{ type: Output, args: ['deselected',] }],
    formatter: [{ type: Input }],
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: false },] }],
    template: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    FuiMultiSelectLabel.prototype.hasClasses;
    /** @type {?} */
    FuiMultiSelectLabel.prototype.value;
    /** @type {?} */
    FuiMultiSelectLabel.prototype.query;
    /** @type {?} */
    FuiMultiSelectLabel.prototype.onDeselected;
    /** @type {?} */
    FuiMultiSelectLabel.prototype.formatter;
    /** @type {?} */
    FuiMultiSelectLabel.prototype.templateSibling;
    /**
     * @type {?}
     * @private
     */
    FuiMultiSelectLabel.prototype._transitionController;
    /**
     * @type {?}
     * @private
     */
    FuiMultiSelectLabel.prototype._template;
    /** @type {?} */
    FuiMultiSelectLabel.prototype.componentFactory;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVsdGktc2VsZWN0LWxhYmVsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWZvbWFudGljLXVpLyIsInNvdXJjZXMiOlsibW9kdWxlcy9zZWxlY3QvY29tcG9uZW50cy9tdWx0aS1zZWxlY3QtbGFiZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFNBQVMsRUFDVCxXQUFXLEVBQ1gsU0FBUyxFQUNULGdCQUFnQixFQUNqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMsYUFBYSxFQUFFLFVBQVUsRUFBRSxvQkFBb0IsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBQy9HLE9BQU8sRUFBQyxZQUFZLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQzs7O01BSXhFLFdBQVcsR0FBRyxXQUFXOzs7O0FBVS9CLE1BQU0sT0FBTyxtQkFBdUIsU0FBUSxhQUFhOzs7Ozs7O0lBcUJ2RCxZQUFZLFFBQW1CLEVBQ25CLE9BQW1CLEVBQ25CLGNBQWlDLEVBQzFCLGdCQUFxQztRQUV0RCxLQUFLLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQztRQUZ4QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQXFCO1FBSXRELHVDQUF1QztRQUN2QyxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxvQkFBb0IsQ0FBQyxLQUFLLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDN0UsSUFBSSxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBRXpELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxZQUFZLEVBQUssQ0FBQztRQUUxQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUV2QixJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLElBQUksVUFBVSxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsbUJBQW1CLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMzRixDQUFDOzs7O0lBSUQsSUFDVyxRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDOzs7OztJQUVELElBQVcsUUFBUSxDQUFDLFFBQW9EO1FBQ3RFLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO1FBQzFCLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDcEUsU0FBUyxFQUFFLElBQUksQ0FBQyxLQUFLO2dCQUNyQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7YUFDbEIsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDOzs7OztJQUVNLGNBQWMsQ0FBQyxDQUFlO1FBQ25DLENBQUMsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBRXRCLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQ2hDLElBQUksVUFBVSxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsbUJBQW1CLENBQUMsR0FBRzs7O1FBQUUsR0FBRyxFQUFFLENBQ3pELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBQyxDQUFDLENBQUM7SUFDM0MsQ0FBQzs7Ozs7SUFHTSxPQUFPLENBQUMsQ0FBZTtRQUM1QixDQUFDLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztJQUN4QixDQUFDOzs7WUEzRUYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSx3QkFBd0I7Z0JBQ2xDLFFBQVEsRUFBRTs7OztDQUlYO2FBQ0E7Ozs7WUFuQkMsU0FBUztZQU5ULFVBQVU7WUFGVixpQkFBaUI7WUFjRyxtQkFBbUI7Ozt5QkFpQnRDLFdBQVcsU0FBQyxVQUFVLGNBQ3RCLFdBQVcsU0FBQyxhQUFhO29CQUV6QixLQUFLO29CQUlMLEtBQUs7MkJBRUwsTUFBTSxTQUFDLFlBQVk7d0JBRW5CLEtBQUs7OEJBR0wsU0FBUyxTQUFDLGlCQUFpQixFQUFFLEVBQUMsSUFBSSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUM7dUJBd0JwRSxLQUFLO3NCQXVCTCxZQUFZLFNBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDOzs7O0lBN0RqQyx5Q0FFb0M7O0lBQ3BDLG9DQUNnQjs7SUFHaEIsb0NBQ3NCOztJQUN0QiwyQ0FDcUM7O0lBQ3JDLHdDQUNxQzs7SUFFckMsOENBQ3lDOzs7OztJQUN6QyxvREFBb0Q7Ozs7O0lBb0JwRCx3Q0FBbUQ7O0lBZnZDLCtDQUE0QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgQ29tcG9uZW50LFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEhvc3RCaW5kaW5nLFxyXG4gIEhvc3RMaXN0ZW5lcixcclxuICBJbnB1dCxcclxuICBPdXRwdXQsXHJcbiAgUmVuZGVyZXIyLFxyXG4gIFRlbXBsYXRlUmVmLFxyXG4gIFZpZXdDaGlsZCxcclxuICBWaWV3Q29udGFpbmVyUmVmXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7RnVpVHJhbnNpdGlvbiwgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkNvbnRyb2xsZXIsIFRyYW5zaXRpb25EaXJlY3Rpb259IGZyb20gJy4uLy4uL3RyYW5zaXRpb24vaW50ZXJuYWwnO1xyXG5pbXBvcnQge0hhbmRsZWRFdmVudCwgRnVpQ29tcG9uZW50RmFjdG9yeX0gZnJvbSAnLi4vLi4vLi4vbWlzYy91dGlsL2ludGVybmFsJztcclxuaW1wb3J0IHtJT3B0aW9uQ29udGV4dH0gZnJvbSAnLi4vY2xhc3Nlcy9zZWxlY3QtYmFzZSc7XHJcblxyXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMzQ0OS5cclxuY29uc3QgdGVtcGxhdGVSZWYgPSBUZW1wbGF0ZVJlZjtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnZnVpLW11bHRpLXNlbGVjdC1sYWJlbCcsXHJcbiAgdGVtcGxhdGU6IGBcclxuPHNwYW4gI3RlbXBsYXRlU2libGluZz48L3NwYW4+XHJcbjxzcGFuICpuZ0lmPVwiIXRlbXBsYXRlXCIgW2lubmVySFRNTF09XCJmb3JtYXR0ZXIodmFsdWUpXCI+PC9zcGFuPlxyXG48aSBjbGFzcz1cImRlbGV0ZSBpY29uXCIgKGNsaWNrKT1cImRlc2VsZWN0T3B0aW9uKCRldmVudClcIj48L2k+XHJcbmBcclxufSlcclxuZXhwb3J0IGNsYXNzIEZ1aU11bHRpU2VsZWN0TGFiZWw8VD4gZXh0ZW5kcyBGdWlUcmFuc2l0aW9uIHtcclxuXHJcbiAgLy8gRG9pbmcgaXQgb24gdGhlIGhvc3QgZW5hYmxlcyB1c2UgaW4gbWVudXMgZXRjLlxyXG4gIEBIb3N0QmluZGluZygnY2xhc3MudWknKVxyXG4gIEBIb3N0QmluZGluZygnY2xhc3MubGFiZWwnKVxyXG4gIHB1YmxpYyByZWFkb25seSBoYXNDbGFzc2VzOiBib29sZWFuO1xyXG4gIEBJbnB1dCgpXHJcbiAgcHVibGljIHZhbHVlOiBUO1xyXG5cclxuICAvLyBTZXRzIHRoZSBGb21hbnRpYyBVSSBjbGFzc2VzIG9uIHRoZSBob3N0IGVsZW1lbnQuXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgcXVlcnk/OiBzdHJpbmc7XHJcbiAgQE91dHB1dCgnZGVzZWxlY3RlZCcpXHJcbiAgcHVibGljIG9uRGVzZWxlY3RlZDogRXZlbnRFbWl0dGVyPFQ+O1xyXG4gIEBJbnB1dCgpXHJcbiAgcHVibGljIGZvcm1hdHRlcjogKG9iajogVCkgPT4gc3RyaW5nO1xyXG4gIC8vIFBsYWNlaG9sZGVyIHRvIGRyYXcgdGVtcGxhdGUgYmVzaWRlLlxyXG4gIEBWaWV3Q2hpbGQoJ3RlbXBsYXRlU2libGluZycsIHtyZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IGZhbHNlfSlcclxuICBwdWJsaWMgdGVtcGxhdGVTaWJsaW5nOiBWaWV3Q29udGFpbmVyUmVmO1xyXG4gIHByaXZhdGUgX3RyYW5zaXRpb25Db250cm9sbGVyOiBUcmFuc2l0aW9uQ29udHJvbGxlcjtcclxuXHJcbiAgY29uc3RydWN0b3IocmVuZGVyZXI6IFJlbmRlcmVyMixcclxuICAgICAgICAgICAgICBlbGVtZW50OiBFbGVtZW50UmVmLFxyXG4gICAgICAgICAgICAgIGNoYW5nZURldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgICAgICAgICAgICBwdWJsaWMgY29tcG9uZW50RmFjdG9yeTogRnVpQ29tcG9uZW50RmFjdG9yeSkge1xyXG5cclxuICAgIHN1cGVyKHJlbmRlcmVyLCBlbGVtZW50LCBjaGFuZ2VEZXRlY3Rvcik7XHJcblxyXG4gICAgLy8gSW5pdGlhbGlzZSB0cmFuc2l0aW9uIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICB0aGlzLl90cmFuc2l0aW9uQ29udHJvbGxlciA9IG5ldyBUcmFuc2l0aW9uQ29udHJvbGxlcihmYWxzZSwgJ2lubGluZS1ibG9jaycpO1xyXG4gICAgdGhpcy5zZXRUcmFuc2l0aW9uQ29udHJvbGxlcih0aGlzLl90cmFuc2l0aW9uQ29udHJvbGxlcik7XHJcblxyXG4gICAgdGhpcy5vbkRlc2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFQ+KCk7XHJcblxyXG4gICAgdGhpcy5oYXNDbGFzc2VzID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl90cmFuc2l0aW9uQ29udHJvbGxlci5hbmltYXRlKG5ldyBUcmFuc2l0aW9uKCdzY2FsZScsIDEwMCwgVHJhbnNpdGlvbkRpcmVjdGlvbi5JbikpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfdGVtcGxhdGU/OiBUZW1wbGF0ZVJlZjxJT3B0aW9uQ29udGV4dDxUPj47XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgcHVibGljIGdldCB0ZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxJT3B0aW9uQ29udGV4dDxUPj4gfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCB0ZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8SU9wdGlvbkNvbnRleHQ8VD4+IHwgdW5kZWZpbmVkKSB7XHJcbiAgICB0aGlzLl90ZW1wbGF0ZSA9IHRlbXBsYXRlO1xyXG4gICAgaWYgKHRoaXMudGVtcGxhdGUpIHtcclxuICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5LmNyZWF0ZVZpZXcodGhpcy50ZW1wbGF0ZVNpYmxpbmcsIHRoaXMudGVtcGxhdGUsIHtcclxuICAgICAgICAkaW1wbGljaXQ6IHRoaXMudmFsdWUsXHJcbiAgICAgICAgcXVlcnk6IHRoaXMucXVlcnlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZGVzZWxlY3RPcHRpb24oZTogSGFuZGxlZEV2ZW50KTogdm9pZCB7XHJcbiAgICBlLmV2ZW50SGFuZGxlZCA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5fdHJhbnNpdGlvbkNvbnRyb2xsZXIuYW5pbWF0ZShcclxuICAgICAgbmV3IFRyYW5zaXRpb24oJ3NjYWxlJywgMTAwLCBUcmFuc2l0aW9uRGlyZWN0aW9uLk91dCwgKCkgPT5cclxuICAgICAgICB0aGlzLm9uRGVzZWxlY3RlZC5lbWl0KHRoaXMudmFsdWUpKSk7XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXHJcbiAgcHVibGljIG9uQ2xpY2soZTogSGFuZGxlZEV2ZW50KTogdm9pZCB7XHJcbiAgICBlLmV2ZW50SGFuZGxlZCA9IHRydWU7XHJcbiAgfVxyXG59XHJcbiJdfQ==