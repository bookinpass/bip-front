/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, Output, QueryList } from '@angular/core';
import { HandledEvent, KeyCode } from '../../../misc/util/internal';
import { DropdownAutoCloseType, DropdownService } from '../services/dropdown.service';
import { FuiDropdownMenu } from './dropdown-menu';
export class FuiDropdown {
    /**
     * @param {?} _element
     */
    constructor(_element) {
        this._element = _element;
        this.service = new DropdownService();
        this.service.isOpenChange.subscribe((/**
         * @return {?}
         */
        () => {
            if (this.service.isOpen) {
                this._element.nativeElement.focus();
            }
        }));
    }
    /**
     * @return {?}
     */
    get isOpenChange() {
        return this.service.isOpenChange;
    }
    /**
     * @return {?}
     */
    get isActive() {
        // This is to ensure nested dropdowns don't get made bold.
        return this.service.isOpen && !this.service.isNested;
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this.service.isOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        // If we are opening the dropdown, we want to always open its parents.
        this.service.setOpenState(value, !!value);
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        return this.service.isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isDisabled(value) {
        this.service.setDisabledState(value);
    }
    /**
     * @return {?}
     */
    get autoClose() {
        return this.service.autoCloseMode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoClose(value) {
        this.service.autoCloseMode = value;
    }
    /**
     * @return {?}
     */
    get children() {
        // @ContentChildren includes the current element by default.
        return this._children.filter((/**
         * @param {?} c
         * @return {?}
         */
        c => c !== this));
    }
    /**
     * @return {?}
     */
    get tabIndex() {
        if (this.isDisabled || this.service.isNested) {
            // If disabled, remove from tabindex.
            return undefined;
        }
        if (this._tabIndex != undefined) {
            // If custom tabindex, default to that.
            return this._tabIndex;
        }
        // Otherwise, return default of 0.
        return 0;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this._menu) {
            throw new Error('You must set [fuiDropdownMenu] on the menu element.');
        }
        this._menu.service = this.service;
        this._menu.parentElement = this._element;
        this.childrenUpdated();
        this._children.changes
            .subscribe((/**
         * @return {?}
         */
        () => this.childrenUpdated()));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            this.service.toggleOpenState();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocusOut(e) {
        if (!this._element.nativeElement.contains(e.relatedTarget)) {
            this.externallyClose();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeypress(e) {
        // Block the keyboard event from being fired on parent dropdowns.
        if (!e.eventHandled) {
            if (e.keyCode === KeyCode.Enter) {
                e.eventHandled = true;
                this.service.setOpenState(true);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    childrenUpdated() {
        // Reregister child dropdowns each time the menu content changes.
        this.children
            .map((/**
         * @param {?} c
         * @return {?}
         */
        c => c.service))
            .forEach((/**
         * @param {?} s
         * @return {?}
         */
        s => this.service.registerChild(s)));
    }
    /**
     * @private
     * @return {?}
     */
    externallyClose() {
        if (this.service.autoCloseMode === DropdownAutoCloseType.ItemClick ||
            this.service.autoCloseMode === DropdownAutoCloseType.OutsideClick) {
            // No need to reflect in parent since they are also bound to document.
            this.service.setOpenState(false);
        }
    }
}
FuiDropdown.decorators = [
    { type: Directive, args: [{
                selector: '[fuiDropdown]'
            },] }
];
/** @nocollapse */
FuiDropdown.ctorParameters = () => [
    { type: ElementRef }
];
FuiDropdown.propDecorators = {
    _menu: [{ type: ContentChild, args: [FuiDropdownMenu, { static: false },] }],
    isOpenChange: [{ type: Output }],
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    isOpen: [{ type: Input }],
    isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    autoClose: [{ type: Input }],
    _children: [{ type: ContentChildren, args: [FuiDropdown, { descendants: true },] }],
    _tabIndex: [{ type: Input, args: ['tabindex',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onFocusOut: [{ type: HostListener, args: ['focusout', ['$event'],] }],
    onKeypress: [{ type: HostListener, args: ['keypress', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    FuiDropdown.prototype.service;
    /**
     * @type {?}
     * @private
     */
    FuiDropdown.prototype._menu;
    /**
     * @type {?}
     * @private
     */
    FuiDropdown.prototype._children;
    /**
     * @type {?}
     * @private
     */
    FuiDropdown.prototype._tabIndex;
    /**
     * @type {?}
     * @private
     */
    FuiDropdown.prototype._element;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtZm9tYW50aWMtdWkvIiwic291cmNlcyI6WyJtb2R1bGVzL2Ryb3Bkb3duL2RpcmVjdGl2ZXMvZHJvcGRvd24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFTCxZQUFZLEVBQ1osZUFBZSxFQUNmLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLFlBQVksRUFBZSxPQUFPLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUMvRSxPQUFPLEVBQUMscUJBQXFCLEVBQUUsZUFBZSxFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDcEYsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBS2hELE1BQU0sT0FBTyxXQUFXOzs7O0lBTXRCLFlBQW9CLFFBQW9CO1FBQXBCLGFBQVEsR0FBUixRQUFRLENBQVk7UUFDdEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLFNBQVM7OztRQUFDLEdBQUcsRUFBRTtZQUN2QyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFO2dCQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNyQztRQUNILENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7OztJQUVELElBQ1csWUFBWTtRQUNyQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDO0lBQ25DLENBQUM7Ozs7SUFFRCxJQUNXLFFBQVE7UUFDakIsMERBQTBEO1FBQzFELE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFD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SUFPMUMsZ0NBQzJCOzs7OztJQTFEZiwrQkFBNEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIEFmdGVyQ29udGVudEluaXQsXHJcbiAgQ29udGVudENoaWxkLFxyXG4gIENvbnRlbnRDaGlsZHJlbixcclxuICBEaXJlY3RpdmUsXHJcbiAgRWxlbWVudFJlZixcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSG9zdEJpbmRpbmcsXHJcbiAgSG9zdExpc3RlbmVyLFxyXG4gIElucHV0LFxyXG4gIE91dHB1dCxcclxuICBRdWVyeUxpc3RcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtIYW5kbGVkRXZlbnQsIElGb2N1c0V2ZW50LCBLZXlDb2RlfSBmcm9tICcuLi8uLi8uLi9taXNjL3V0aWwvaW50ZXJuYWwnO1xyXG5pbXBvcnQge0Ryb3Bkb3duQXV0b0Nsb3NlVHlwZSwgRHJvcGRvd25TZXJ2aWNlfSBmcm9tICcuLi9zZXJ2aWNlcy9kcm9wZG93bi5zZXJ2aWNlJztcclxuaW1wb3J0IHtGdWlEcm9wZG93bk1lbnV9IGZyb20gJy4vZHJvcGRvd24tbWVudSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tmdWlEcm9wZG93bl0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGdWlEcm9wZG93biBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xyXG5cclxuICBwdWJsaWMgc2VydmljZTogRHJvcGRvd25TZXJ2aWNlO1xyXG4gIEBDb250ZW50Q2hpbGQoRnVpRHJvcGRvd25NZW51LCB7c3RhdGljOiBmYWxzZX0pXHJcbiAgcHJpdmF0ZSBfbWVudTogRnVpRHJvcGRvd25NZW51O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmKSB7XHJcbiAgICB0aGlzLnNlcnZpY2UgPSBuZXcgRHJvcGRvd25TZXJ2aWNlKCk7XHJcbiAgICB0aGlzLnNlcnZpY2UuaXNPcGVuQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLnNlcnZpY2UuaXNPcGVuKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgQE91dHB1dCgpXHJcbiAgcHVibGljIGdldCBpc09wZW5DaGFuZ2UoKTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiB0aGlzLnNlcnZpY2UuaXNPcGVuQ2hhbmdlO1xyXG4gIH1cclxuXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5hY3RpdmUnKVxyXG4gIHB1YmxpYyBnZXQgaXNBY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICAvLyBUaGlzIGlzIHRvIGVuc3VyZSBuZXN0ZWQgZHJvcGRvd25zIGRvbid0IGdldCBtYWRlIGJvbGQuXHJcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmlzT3BlbiAmJiAhdGhpcy5zZXJ2aWNlLmlzTmVzdGVkO1xyXG4gIH1cclxuXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgZ2V0IGlzT3BlbigpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnNlcnZpY2UuaXNPcGVuO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCBpc09wZW4odmFsdWU6IGJvb2xlYW4pIHtcclxuICAgIC8vIElmIHdlIGFyZSBvcGVuaW5nIHRoZSBkcm9wZG93biwgd2Ugd2FudCB0byBhbHdheXMgb3BlbiBpdHMgcGFyZW50cy5cclxuICAgIHRoaXMuc2VydmljZS5zZXRPcGVuU3RhdGUodmFsdWUsICEhdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5kaXNhYmxlZCcpXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgZ2V0IGlzRGlzYWJsZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmlzRGlzYWJsZWQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0IGlzRGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMuc2VydmljZS5zZXREaXNhYmxlZFN0YXRlKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgcHVibGljIGdldCBhdXRvQ2xvc2UoKTogRHJvcGRvd25BdXRvQ2xvc2VUeXBlIHtcclxuICAgIHJldHVybiB0aGlzLnNlcnZpY2UuYXV0b0Nsb3NlTW9kZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXQgYXV0b0Nsb3NlKHZhbHVlOiBEcm9wZG93bkF1dG9DbG9zZVR5cGUpIHtcclxuICAgIHRoaXMuc2VydmljZS5hdXRvQ2xvc2VNb2RlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBAQ29udGVudENoaWxkcmVuKEZ1aURyb3Bkb3duLCB7ZGVzY2VuZGFudHM6IHRydWV9KVxyXG4gIHByaXZhdGUgX2NoaWxkcmVuOiBRdWVyeUxpc3Q8RnVpRHJvcGRvd24+O1xyXG5cclxuICBwdWJsaWMgZ2V0IGNoaWxkcmVuKCk6IEZ1aURyb3Bkb3duW10ge1xyXG4gICAgLy8gQENvbnRlbnRDaGlsZHJlbiBpbmNsdWRlcyB0aGUgY3VycmVudCBlbGVtZW50IGJ5IGRlZmF1bHQuXHJcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZmlsdGVyKGMgPT4gYyAhPT0gdGhpcyk7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoJ3RhYmluZGV4JylcclxuICBwcml2YXRlIF90YWJJbmRleD86IG51bWJlcjtcclxuXHJcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JylcclxuICBwdWJsaWMgZ2V0IHRhYkluZGV4KCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XHJcbiAgICBpZiAodGhpcy5pc0Rpc2FibGVkIHx8IHRoaXMuc2VydmljZS5pc05lc3RlZCkge1xyXG4gICAgICAvLyBJZiBkaXNhYmxlZCwgcmVtb3ZlIGZyb20gdGFiaW5kZXguXHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fdGFiSW5kZXggIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIElmIGN1c3RvbSB0YWJpbmRleCwgZGVmYXVsdCB0byB0aGF0LlxyXG4gICAgICByZXR1cm4gdGhpcy5fdGFiSW5kZXg7XHJcbiAgICB9XHJcbiAgICAvLyBPdGhlcndpc2UsIHJldHVybiBkZWZhdWx0IG9mIDAuXHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX21lbnUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzZXQgW2Z1aURyb3Bkb3duTWVudV0gb24gdGhlIG1lbnUgZWxlbWVudC4nKTtcclxuICAgIH1cclxuICAgIHRoaXMuX21lbnUuc2VydmljZSA9IHRoaXMuc2VydmljZTtcclxuICAgIHRoaXMuX21lbnUucGFyZW50RWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XHJcblxyXG4gICAgdGhpcy5jaGlsZHJlblVwZGF0ZWQoKTtcclxuICAgIHRoaXMuX2NoaWxkcmVuLmNoYW5nZXNcclxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNoaWxkcmVuVXBkYXRlZCgpKTtcclxuICB9XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSlcclxuICBwdWJsaWMgb25DbGljayhlOiBIYW5kbGVkRXZlbnQpOiB2b2lkIHtcclxuICAgIGlmICghZS5ldmVudEhhbmRsZWQpIHtcclxuICAgICAgZS5ldmVudEhhbmRsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgdGhpcy5zZXJ2aWNlLnRvZ2dsZU9wZW5TdGF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignZm9jdXNvdXQnLCBbJyRldmVudCddKVxyXG4gIHB1YmxpYyBvbkZvY3VzT3V0KGU6IElGb2N1c0V2ZW50KTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSB7XHJcbiAgICAgIHRoaXMuZXh0ZXJuYWxseUNsb3NlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdrZXlwcmVzcycsIFsnJGV2ZW50J10pXHJcbiAgcHVibGljIG9uS2V5cHJlc3MoZTogSGFuZGxlZEV2ZW50ICYgS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgLy8gQmxvY2sgdGhlIGtleWJvYXJkIGV2ZW50IGZyb20gYmVpbmcgZmlyZWQgb24gcGFyZW50IGRyb3Bkb3ducy5cclxuICAgIGlmICghZS5ldmVudEhhbmRsZWQpIHtcclxuXHJcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IEtleUNvZGUuRW50ZXIpIHtcclxuICAgICAgICBlLmV2ZW50SGFuZGxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuc2VydmljZS5zZXRPcGVuU3RhdGUodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2hpbGRyZW5VcGRhdGVkKCk6IHZvaWQge1xyXG4gICAgLy8gUmVyZWdpc3RlciBjaGlsZCBkcm9wZG93bnMgZWFjaCB0aW1lIHRoZSBtZW51IGNvbnRlbnQgY2hhbmdlcy5cclxuICAgIHRoaXMuY2hpbGRyZW5cclxuICAgICAgLm1hcChjID0+IGMuc2VydmljZSlcclxuICAgICAgLmZvckVhY2gocyA9PiB0aGlzLnNlcnZpY2UucmVnaXN0ZXJDaGlsZChzKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGV4dGVybmFsbHlDbG9zZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnNlcnZpY2UuYXV0b0Nsb3NlTW9kZSA9PT0gRHJvcGRvd25BdXRvQ2xvc2VUeXBlLkl0ZW1DbGljayB8fFxyXG4gICAgICB0aGlzLnNlcnZpY2UuYXV0b0Nsb3NlTW9kZSA9PT0gRHJvcGRvd25BdXRvQ2xvc2VUeXBlLk91dHNpZGVDbGljaykge1xyXG4gICAgICAvLyBObyBuZWVkIHRvIHJlZmxlY3QgaW4gcGFyZW50IHNpbmNlIHRoZXkgYXJlIGFsc28gYm91bmQgdG8gZG9jdW1lbnQuXHJcbiAgICAgIHRoaXMuc2VydmljZS5zZXRPcGVuU3RhdGUoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=