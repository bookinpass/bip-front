/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, ContentChild, ContentChildren, Directive, ElementRef, forwardRef, HostListener, Input, QueryList, Renderer2 } from '@angular/core';
import { FuiTransition, Transition, TransitionController, TransitionDirection } from '../../transition/internal';
import { KeyCode } from '../../../misc/util/internal';
import { DropdownAutoCloseType } from '../services/dropdown.service';
// Polyfill for IE
import 'element-closest';
export class FuiDropdownMenuItem {
    /**
     * @param {?} _renderer
     * @param {?} element
     */
    constructor(_renderer, element) {
        this._renderer = _renderer;
        this.element = element;
        this.isSelected = false;
        this.selectedClass = 'selected';
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        // We must use nativeElement as Angular doesn't have a way of reading class information.
        /** @type {?} */
        const element = (/** @type {?} */ (this.element.nativeElement));
        return element.classList.contains('disabled');
    }
    /**
     * @return {?}
     */
    get hasChildDropdown() {
        return !!this.childDropdownMenu;
    }
    /**
     * @return {?}
     */
    get isSelected() {
        return this._isSelected;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isSelected(value) {
        // Renderer is used to enable a dynamic class name.
        if (value) {
            this._renderer.addClass(this.element.nativeElement, this.selectedClass);
        }
        else {
            this._renderer.removeClass(this.element.nativeElement, this.selectedClass);
        }
    }
    /**
     * @return {?}
     */
    performClick() {
        // Using directly because Renderer2 doesn't have invokeElementMethod method anymore.
        this.element.nativeElement.click();
    }
}
FuiDropdownMenuItem.decorators = [
    { type: Directive, args: [{
                // We must attach to every '.item' as Angular doesn't support > selectors.
                selector: '.item'
            },] }
];
/** @nocollapse */
FuiDropdownMenuItem.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FuiDropdownMenuItem.propDecorators = {
    childDropdownMenu: [{ type: ContentChild, args: [forwardRef((/**
                 * @return {?}
                 */
                () => FuiDropdownMenu)), { static: false },] }]
};
if (false) {
    /** @type {?} */
    FuiDropdownMenuItem.prototype.selectedClass;
    /** @type {?} */
    FuiDropdownMenuItem.prototype.childDropdownMenu;
    /**
     * @type {?}
     * @private
     */
    FuiDropdownMenuItem.prototype._isSelected;
    /**
     * @type {?}
     * @private
     */
    FuiDropdownMenuItem.prototype._renderer;
    /** @type {?} */
    FuiDropdownMenuItem.prototype.element;
}
export class FuiDropdownMenu extends FuiTransition {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} changeDetector
     */
    constructor(renderer, element, changeDetector) {
        super(renderer, element, changeDetector);
        // Initialise transition functionality.
        this._transitionController = new TransitionController(false);
        this.setTransitionController(this._transitionController);
        this.menuTransition = 'slide down';
        this.menuTransitionDuration = 200;
        this.menuAutoSelectFirst = false;
        this.menuSelectedItemClass = 'selected';
        // In case the dropdown menu is destroyed before it has a chance to be fully initialised.
        this._parentKeyDownListener = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set parentElement(value) {
        this._parentKeyDownListener = this._renderer
            .listen(value.nativeElement, 'keydown', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.onParentKeyDown(e)));
    }
    /**
     * @param {?} items
     * @return {?}
     */
    set items(items) {
        this._itemsQueryOverride = items;
    }
    /**
     * @return {?}
     */
    get service() {
        return this._service;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set service(value) {
        this._service = value;
        /** @type {?} */
        let previousIsOpen = this._service.isOpen;
        this._service.isOpenChange.subscribe((/**
         * @param {?} isOpen
         * @return {?}
         */
        (isOpen) => {
            if (isOpen !== previousIsOpen) {
                // Only run transitions if the open state has changed.
                this._transitionController.stopAll();
                this._transitionController.animate(new Transition(this.menuTransition, this.menuTransitionDuration, TransitionDirection.Either, (/**
                 * @return {?}
                 */
                () => this._service.isAnimating = false)));
            }
            if (!isOpen) {
                // Reset the item selections when a nested item is selected to avoid incosistent open states.
                if (this.selectedItems.length > 1) {
                    this.resetSelection();
                }
            }
            previousIsOpen = isOpen;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    get _itemsQuery() {
        return this._itemsQueryOverride || this._itemsQueryInternal;
    }
    // Get the list of items, ignoring those that are disabled.
    /**
     * @private
     * @return {?}
     */
    get _items() {
        return this._itemsQuery.filter((/**
         * @param {?} i
         * @return {?}
         */
        i => !i.isDisabled));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        if (!e.eventHandled) {
            e.eventHandled = true;
            if (this._service.autoCloseMode === DropdownAutoCloseType.ItemClick) {
                /** @type {?} */
                const target = (/** @type {?} */ (e.target));
                if (this._element.nativeElement.contains(target.closest('.item')) && !/input|textarea/i.test(target.tagName)) {
                    // Once an item is selected, we can close the entire dropdown.
                    this._service.setOpenState(false, true);
                }
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onParentKeyDown(e) {
        // Only the root dropdown (i.e. not nested dropdowns) is responsible for keeping track of the currently selected item.
        if (this._service && this._service.isOpen && !this._service.isNested) {
            // Stop document events like scrolling while open.
            /** @type {?} */
            const target = (/** @type {?} */ (e.target));
            if (!/input/i.test(target.tagName) &&
                [KeyCode.Escape, KeyCode.Enter, KeyCode.Up, KeyCode.Down, KeyCode.Left, KeyCode.Right].find((/**
                 * @param {?} kC
                 * @return {?}
                 */
                kC => kC === e.keyCode))) {
                e.preventDefault();
            }
            // Gets the top selected item from the stack.
            const [selected] = this.selectedItems.slice(-1);
            // Keeping track of the menu containing the currently selected element allows us to easily determine its siblings.
            /** @type {?} */
            let selectedContainer = this;
            if (this.selectedItems.length >= 2) {
                const [selectedParent] = this.selectedItems.slice(-2);
                selectedContainer = selectedParent.childDropdownMenu;
            }
            switch (e.keyCode) {
                // Escape : close the entire dropdown.
                case KeyCode.Escape: {
                    this._service.setOpenState(false);
                    break;
                }
                // Down : select the next item below the current one, or the 1st if none selected.
                case KeyCode.Down:
                // Up : select the next item above the current one, or the 1st if none selected.
                case KeyCode.Up: {
                    this.selectedItems.pop();
                    this.selectedItems.push(selectedContainer.updateSelection(selected, e.keyCode));
                    // Prevent default regardless of whether we are in an input, to stop jumping to the start or end of the query string.
                    e.preventDefault();
                    break;
                }
                // Enter : if the item doesn't contain a nested dropdown, 'click' it. Otherwise, fall through to 'Right' action.
                case KeyCode.Enter: {
                    if (selected && !selected.hasChildDropdown) {
                        selected.performClick();
                        break;
                    }
                }
                // falls through
                // Right : if the selected item contains a nested dropdown, open the dropdown & select the 1st item.
                case KeyCode.Right: {
                    if (selected && selected.hasChildDropdown) {
                        selected.childDropdownMenu.service.setOpenState(true);
                        this.selectedItems.push(selected.childDropdownMenu.updateSelection(selected, e.keyCode));
                    }
                    break;
                }
                // Left : if the selected item is in a nested dropdown, close it and select the containing item.
                case KeyCode.Left: {
                    if (this.selectedItems.length >= 2) {
                        this.selectedItems.pop();
                        const [selectedParent] = this.selectedItems.slice(-1);
                        selectedParent.childDropdownMenu.service.setOpenState(false);
                        selectedParent.isSelected = true;
                    }
                    break;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    resetSelection() {
        this.selectedItems = [];
        this._items.forEach((/**
         * @param {?} i
         * @return {?}
         */
        i => {
            i.selectedClass = this.menuSelectedItemClass;
            i.isSelected = false;
        }));
        if (this.menuAutoSelectFirst && this._items.length > 0) {
            // Autoselect 1st item if required & possible.
            this._items[0].isSelected = true;
            this.scrollToItem(this._items[0]);
            this.selectedItems.push(this._itemsQuery.first);
        }
    }
    // Determines the item to next be selected, based on the keyboard input & the currently selected item.
    /**
     * @param {?} selectedItem
     * @param {?} keyCode
     * @return {?}
     */
    updateSelection(selectedItem, keyCode) {
        if (selectedItem) {
            // Remove the selected status on the previously selected item.
            selectedItem.isSelected = false;
        }
        /** @type {?} */
        let selectedIndex = this._items
            .findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => i === selectedItem));
        /** @type {?} */
        let newSelection;
        switch (keyCode) {
            case KeyCode.Enter:
            case KeyCode.Right:
            case KeyCode.Down:
                selectedIndex += 1;
                break;
            case KeyCode.Up:
                if (selectedIndex === -1) {
                    // If none are selected, select the 1st item. Should this be `this.items.last - 1`?
                    selectedIndex = 0;
                    break;
                }
                selectedIndex -= 1;
                break;
        }
        // Select the item at the updated index. The || is to stop us selecting past the start or end of the item list.
        newSelection = this._items[selectedIndex] || selectedItem;
        if (newSelection) {
            // Set the selected status on the newly selected item.
            newSelection.isSelected = true;
            // Set the current scroll position to the location of the newly selected item.
            this.scrollToItem(newSelection);
        }
        return newSelection;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    scrollToItem(item) {
        /** @type {?} */
        const menu = this._element.nativeElement;
        /** @type {?} */
        const selectedRect = item.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const menuRect = menu.getBoundingClientRect();
        /** @type {?} */
        let scrollAmount = 0;
        if (selectedRect.bottom > menuRect.bottom) {
            scrollAmount = selectedRect.bottom - menuRect.bottom;
        }
        if (selectedRect.top < menuRect.top) {
            scrollAmount = selectedRect.top - menuRect.top;
        }
        menu.scrollTop += Math.round(scrollAmount);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.onItemsChanged();
        this._itemsQuery.changes.subscribe((/**
         * @return {?}
         */
        () => this.onItemsChanged()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._parentKeyDownListener();
    }
    /**
     * @private
     * @return {?}
     */
    onItemsChanged() {
        // We use `_items` rather than `items` in case one or more have become disabled.
        this.resetSelection();
    }
}
FuiDropdownMenu.decorators = [
    { type: Directive, args: [{
                selector: '[fuiDropdownMenu]'
            },] }
];
/** @nocollapse */
FuiDropdownMenu.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
FuiDropdownMenu.propDecorators = {
    menuTransition: [{ type: Input }],
    menuTransitionDuration: [{ type: Input }],
    menuAutoSelectFirst: [{ type: Input }],
    menuSelectedItemClass: [{ type: Input }],
    _itemsQueryInternal: [{ type: ContentChildren, args: [FuiDropdownMenuItem,] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    FuiDropdownMenu.prototype.menuTransition;
    /** @type {?} */
    FuiDropdownMenu.prototype.menuTransitionDuration;
    /** @type {?} */
    FuiDropdownMenu.prototype.selectedItems;
    /** @type {?} */
    FuiDropdownMenu.prototype.menuAutoSelectFirst;
    /** @type {?} */
    FuiDropdownMenu.prototype.menuSelectedItemClass;
    /**
     * @type {?}
     * @private
     */
    FuiDropdownMenu.prototype._transitionController;
    /**
     * @type {?}
     * @private
     */
    FuiDropdownMenu.prototype._itemsQueryInternal;
    /**
     * @type {?}
     * @private
     */
    FuiDropdownMenu.prototype._itemsQueryOverride;
    /**
     * @type {?}
     * @private
     */
    FuiDropdownMenu.prototype._parentKeyDownListener;
    /**
     * @type {?}
     * @private
     */
    FuiDropdownMenu.prototype._service;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24tbWVudS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1mb21hbnRpYy11aS8iLCJzb3VyY2VzIjpbIm1vZHVsZXMvZHJvcGRvd24vZGlyZWN0aXZlcy9kcm9wZG93bi1tZW51LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBRUwsaUJBQWlCLEVBQ2pCLFlBQVksRUFDWixlQUFlLEVBQ2YsU0FBUyxFQUNULFVBQVUsRUFDVixVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFFTCxTQUFTLEVBQ1QsU0FBUyxFQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBQyxhQUFhLEVBQUUsVUFBVSxFQUFFLG9CQUFvQixFQUFFLG1CQUFtQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDL0csT0FBTyxFQUFrQyxPQUFPLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUNyRixPQUFPLEVBQUMscUJBQXFCLEVBQWtCLE1BQU0sOEJBQThCLENBQUM7O0FBRXBGLE9BQU8saUJBQWlCLENBQUM7QUFNekIsTUFBTSxPQUFPLG1CQUFtQjs7Ozs7SUFPOUIsWUFBb0IsU0FBb0IsRUFBUyxPQUFtQjtRQUFoRCxjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQVMsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUNsRSxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUV4QixJQUFJLENBQUMsYUFBYSxHQUFHLFVBQVUsQ0FBQztJQUNsQyxDQUFDOzs7O0lBRUQsSUFBVyxVQUFVOzs7Y0FFYixPQUFPLEdBQUcsbUJBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQVc7UUFDckQsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNoRCxDQUFDOzs7O0lBRUQsSUFBVyxnQkFBZ0I7UUFDekIsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDO0lBQ2xDLENBQUM7Ozs7SUFJRCxJQUFX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dGVudCI6WyJpbXBvcnQge1xyXG4gIEFmdGVyQ29udGVudEluaXQsXHJcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgQ29udGVudENoaWxkLFxyXG4gIENvbnRlbnRDaGlsZHJlbixcclxuICBEaXJlY3RpdmUsXHJcbiAgRWxlbWVudFJlZixcclxuICBmb3J3YXJkUmVmLFxyXG4gIEhvc3RMaXN0ZW5lcixcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgUXVlcnlMaXN0LFxyXG4gIFJlbmRlcmVyMlxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0Z1aVRyYW5zaXRpb24sIFRyYW5zaXRpb24sIFRyYW5zaXRpb25Db250cm9sbGVyLCBUcmFuc2l0aW9uRGlyZWN0aW9ufSBmcm9tICcuLi8uLi90cmFuc2l0aW9uL2ludGVybmFsJztcclxuaW1wb3J0IHtIYW5kbGVkRXZlbnQsIElBdWdtZW50ZWRFbGVtZW50LCBLZXlDb2RlfSBmcm9tICcuLi8uLi8uLi9taXNjL3V0aWwvaW50ZXJuYWwnO1xyXG5pbXBvcnQge0Ryb3Bkb3duQXV0b0Nsb3NlVHlwZSwgRHJvcGRvd25TZXJ2aWNlfSBmcm9tICcuLi9zZXJ2aWNlcy9kcm9wZG93bi5zZXJ2aWNlJztcclxuLy8gUG9seWZpbGwgZm9yIElFXHJcbmltcG9ydCAnZWxlbWVudC1jbG9zZXN0JztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIC8vIFdlIG11c3QgYXR0YWNoIHRvIGV2ZXJ5ICcuaXRlbScgYXMgQW5ndWxhciBkb2Vzbid0IHN1cHBvcnQgPiBzZWxlY3RvcnMuXHJcbiAgc2VsZWN0b3I6ICcuaXRlbSdcclxufSlcclxuZXhwb3J0IGNsYXNzIEZ1aURyb3Bkb3duTWVudUl0ZW0ge1xyXG5cclxuICAvLyBTdG9yZXMgdGhlIGNsYXNzIG5hbWUgdXNlZCBmb3IgYSAnc2VsZWN0ZWQnIGl0ZW0uXHJcbiAgcHVibGljIHNlbGVjdGVkQ2xhc3M6IHN0cmluZztcclxuICBAQ29udGVudENoaWxkKGZvcndhcmRSZWYoKCkgPT4gRnVpRHJvcGRvd25NZW51KSwge3N0YXRpYzogZmFsc2V9KVxyXG4gIHB1YmxpYyBjaGlsZERyb3Bkb3duTWVudTogRnVpRHJvcGRvd25NZW51O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLCBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZikge1xyXG4gICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5zZWxlY3RlZENsYXNzID0gJ3NlbGVjdGVkJztcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgaXNEaXNhYmxlZCgpOiBib29sZWFuIHtcclxuICAgIC8vIFdlIG11c3QgdXNlIG5hdGl2ZUVsZW1lbnQgYXMgQW5ndWxhciBkb2Vzbid0IGhhdmUgYSB3YXkgb2YgcmVhZGluZyBjbGFzcyBpbmZvcm1hdGlvbi5cclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCBhcyBFbGVtZW50O1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBoYXNDaGlsZERyb3Bkb3duKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jaGlsZERyb3Bkb3duTWVudTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX2lzU2VsZWN0ZWQ6IGJvb2xlYW47XHJcblxyXG4gIHB1YmxpYyBnZXQgaXNTZWxlY3RlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCBpc1NlbGVjdGVkKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAvLyBSZW5kZXJlciBpcyB1c2VkIHRvIGVuYWJsZSBhIGR5bmFtaWMgY2xhc3MgbmFtZS5cclxuICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgdGhpcy5zZWxlY3RlZENsYXNzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCB0aGlzLnNlbGVjdGVkQ2xhc3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHBlcmZvcm1DbGljaygpOiB2b2lkIHtcclxuICAgIC8vIFVzaW5nIGRpcmVjdGx5IGJlY2F1c2UgUmVuZGVyZXIyIGRvZXNuJ3QgaGF2ZSBpbnZva2VFbGVtZW50TWV0aG9kIG1ldGhvZCBhbnltb3JlLlxyXG4gICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY2xpY2soKTtcclxuICB9XHJcbn1cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW2Z1aURyb3Bkb3duTWVudV0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGdWlEcm9wZG93bk1lbnUgZXh0ZW5kcyBGdWlUcmFuc2l0aW9uIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcclxuXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgbWVudVRyYW5zaXRpb246IHN0cmluZztcclxuXHJcbiAgLy8gU3RhY2sgdGhhdCBrZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0uXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgbWVudVRyYW5zaXRpb25EdXJhdGlvbjogbnVtYmVyO1xyXG4gIC8vIFNlbGVjdGVkIGl0ZW1zIGxvd2VyIGluIHRoZSBzdGFjayBhcmUgbmVjZXNzYXJpbHkgdGhlIHBhcmVudCBvZiB0aGUgaXRlbSBvbmUgaGlnaGVyLlxyXG4gIHB1YmxpYyBzZWxlY3RlZEl0ZW1zOiBGdWlEcm9wZG93bk1lbnVJdGVtW107XHJcbiAgLy8gU2V0cyB3aGV0aGVyIG9yIG5vdCB0byBhdXRvbWF0aWNhbGx5IHNlbGVjdCB0aGUgMXN0IGl0ZW0gd2hlbiB0aGUgZHJvcGRvd24gaXMgb3BlbmVkLlxyXG4gIEBJbnB1dCgpXHJcbiAgcHVibGljIG1lbnVBdXRvU2VsZWN0Rmlyc3Q6IGJvb2xlYW47XHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgbWVudVNlbGVjdGVkSXRlbUNsYXNzOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfdHJhbnNpdGlvbkNvbnRyb2xsZXI6IFRyYW5zaXRpb25Db250cm9sbGVyO1xyXG4gIEBDb250ZW50Q2hpbGRyZW4oRnVpRHJvcGRvd25NZW51SXRlbSlcclxuICBwcml2YXRlIF9pdGVtc1F1ZXJ5SW50ZXJuYWw6IFF1ZXJ5TGlzdDxGdWlEcm9wZG93bk1lbnVJdGVtPjtcclxuICBwcml2YXRlIF9pdGVtc1F1ZXJ5T3ZlcnJpZGU6IFF1ZXJ5TGlzdDxGdWlEcm9wZG93bk1lbnVJdGVtPjtcclxuICBwcml2YXRlIF9wYXJlbnRLZXlEb3duTGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyOiBSZW5kZXJlcjIsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGNoYW5nZURldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZikge1xyXG4gICAgc3VwZXIocmVuZGVyZXIsIGVsZW1lbnQsIGNoYW5nZURldGVjdG9yKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXNlIHRyYW5zaXRpb24gZnVuY3Rpb25hbGl0eS5cclxuICAgIHRoaXMuX3RyYW5zaXRpb25Db250cm9sbGVyID0gbmV3IFRyYW5zaXRpb25Db250cm9sbGVyKGZhbHNlKTtcclxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbkNvbnRyb2xsZXIodGhpcy5fdHJhbnNpdGlvbkNvbnRyb2xsZXIpO1xyXG5cclxuICAgIHRoaXMubWVudVRyYW5zaXRpb24gPSAnc2xpZGUgZG93bic7XHJcbiAgICB0aGlzLm1lbnVUcmFuc2l0aW9uRHVyYXRpb24gPSAyMDA7XHJcblxyXG4gICAgdGhpcy5tZW51QXV0b1NlbGVjdEZpcnN0ID0gZmFsc2U7XHJcbiAgICB0aGlzLm1lbnVTZWxlY3RlZEl0ZW1DbGFzcyA9ICdzZWxlY3RlZCc7XHJcblxyXG4gICAgLy8gSW4gY2FzZSB0aGUgZHJvcGRvd24gbWVudSBpcyBkZXN0cm95ZWQgYmVmb3JlIGl0IGhhcyBhIGNoYW5jZSB0byBiZSBmdWxseSBpbml0aWFsaXNlZC5cclxuICAgIHRoaXMuX3BhcmVudEtleURvd25MaXN0ZW5lciA9ICgpID0+IHtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0IHBhcmVudEVsZW1lbnQodmFsdWU6IEVsZW1lbnRSZWYpIHtcclxuICAgIHRoaXMuX3BhcmVudEtleURvd25MaXN0ZW5lciA9IHRoaXMuX3JlbmRlcmVyXHJcbiAgICAgIC5saXN0ZW4odmFsdWUubmF0aXZlRWxlbWVudCwgJ2tleWRvd24nLCAoZTogS2V5Ym9hcmRFdmVudCkgPT5cclxuICAgICAgICB0aGlzLm9uUGFyZW50S2V5RG93bihlKSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0IGl0ZW1zKGl0ZW1zOiBRdWVyeUxpc3Q8RnVpRHJvcGRvd25NZW51SXRlbT4pIHtcclxuICAgIHRoaXMuX2l0ZW1zUXVlcnlPdmVycmlkZSA9IGl0ZW1zO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc2VydmljZTogRHJvcGRvd25TZXJ2aWNlO1xyXG5cclxuICBwdWJsaWMgZ2V0IHNlcnZpY2UoKTogRHJvcGRvd25TZXJ2aWNlIHtcclxuICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCBzZXJ2aWNlKHZhbHVlOiBEcm9wZG93blNlcnZpY2UpIHtcclxuICAgIHRoaXMuX3NlcnZpY2UgPSB2YWx1ZTtcclxuXHJcbiAgICBsZXQgcHJldmlvdXNJc09wZW4gPSB0aGlzLl9zZXJ2aWNlLmlzT3BlbjtcclxuICAgIHRoaXMuX3NlcnZpY2UuaXNPcGVuQ2hhbmdlLnN1YnNjcmliZSgoaXNPcGVuOiBib29sZWFuKSA9PiB7XHJcbiAgICAgIGlmIChpc09wZW4gIT09IHByZXZpb3VzSXNPcGVuKSB7XHJcbiAgICAgICAgLy8gT25seSBydW4gdHJhbnNpdGlvbnMgaWYgdGhlIG9wZW4gc3RhdGUgaGFzIGNoYW5nZWQuXHJcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkNvbnRyb2xsZXIuc3RvcEFsbCgpO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25Db250cm9sbGVyLmFuaW1hdGUoXHJcbiAgICAgICAgICBuZXcgVHJhbnNpdGlvbihcclxuICAgICAgICAgICAgdGhpcy5tZW51VHJhbnNpdGlvbixcclxuICAgICAgICAgICAgdGhpcy5tZW51VHJhbnNpdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgICAgICBUcmFuc2l0aW9uRGlyZWN0aW9uLkVpdGhlcixcclxuICAgICAgICAgICAgKCkgPT4gdGhpcy5fc2VydmljZS5pc0FuaW1hdGluZyA9IGZhbHNlKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXNPcGVuKSB7XHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIGl0ZW0gc2VsZWN0aW9ucyB3aGVuIGEgbmVzdGVkIGl0ZW0gaXMgc2VsZWN0ZWQgdG8gYXZvaWQgaW5jb3Npc3RlbnQgb3BlbiBzdGF0ZXMuXHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBwcmV2aW91c0lzT3BlbiA9IGlzT3BlbjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXQgX2l0ZW1zUXVlcnkoKTogUXVlcnlMaXN0PEZ1aURyb3Bkb3duTWVudUl0ZW0+IHtcclxuICAgIHJldHVybiB0aGlzLl9pdGVtc1F1ZXJ5T3ZlcnJpZGUgfHwgdGhpcy5faXRlbXNRdWVyeUludGVybmFsO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRoZSBsaXN0IG9mIGl0ZW1zLCBpZ25vcmluZyB0aG9zZSB0aGF0IGFyZSBkaXNhYmxlZC5cclxuICBwcml2YXRlIGdldCBfaXRlbXMoKTogRnVpRHJvcGRvd25NZW51SXRlbVtdIHtcclxuICAgIHJldHVybiB0aGlzLl9pdGVtc1F1ZXJ5LmZpbHRlcihpID0+ICFpLmlzRGlzYWJsZWQpO1xyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxyXG4gIHB1YmxpYyBvbkNsaWNrKGU6IEhhbmRsZWRFdmVudCAmIE1vdXNlRXZlbnQpOiB2b2lkIHtcclxuICAgIGlmICghZS5ldmVudEhhbmRsZWQpIHtcclxuICAgICAgZS5ldmVudEhhbmRsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX3NlcnZpY2UuYXV0b0Nsb3NlTW9kZSA9PT0gRHJvcGRvd25BdXRvQ2xvc2VUeXBlLkl0ZW1DbGljaykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIElBdWdtZW50ZWRFbGVtZW50O1xyXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGFyZ2V0LmNsb3Nlc3QoJy5pdGVtJykpICYmICEvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHRhcmdldC50YWdOYW1lKSkge1xyXG4gICAgICAgICAgLy8gT25jZSBhbiBpdGVtIGlzIHNlbGVjdGVkLCB3ZSBjYW4gY2xvc2UgdGhlIGVudGlyZSBkcm9wZG93bi5cclxuICAgICAgICAgIHRoaXMuX3NlcnZpY2Uuc2V0T3BlblN0YXRlKGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBvblBhcmVudEtleURvd24oZTogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgLy8gT25seSB0aGUgcm9vdCBkcm9wZG93biAoaS5lLiBub3QgbmVzdGVkIGRyb3Bkb3ducykgaXMgcmVzcG9uc2libGUgZm9yIGtlZXBpbmcgdHJhY2sgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLlxyXG4gICAgaWYgKHRoaXMuX3NlcnZpY2UgJiYgdGhpcy5fc2VydmljZS5pc09wZW4gJiYgIXRoaXMuX3NlcnZpY2UuaXNOZXN0ZWQpIHtcclxuICAgICAgLy8gU3RvcCBkb2N1bWVudCBldmVudHMgbGlrZSBzY3JvbGxpbmcgd2hpbGUgb3Blbi5cclxuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgRWxlbWVudDtcclxuICAgICAgaWYgKCEvaW5wdXQvaS50ZXN0KHRhcmdldC50YWdOYW1lKSAmJlxyXG4gICAgICAgIFtLZXlDb2RlLkVzY2FwZSwgS2V5Q29kZS5FbnRlciwgS2V5Q29kZS5VcCwgS2V5Q29kZS5Eb3duLCBLZXlDb2RlLkxlZnQsIEtleUNvZGUuUmlnaHRdLmZpbmQoa0MgPT4ga0MgPT09IGUua2V5Q29kZSkpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdldHMgdGhlIHRvcCBzZWxlY3RlZCBpdGVtIGZyb20gdGhlIHN0YWNrLlxyXG4gICAgICBjb25zdCBbc2VsZWN0ZWRdID0gdGhpcy5zZWxlY3RlZEl0ZW1zLnNsaWNlKC0xKTtcclxuICAgICAgLy8gS2VlcGluZyB0cmFjayBvZiB0aGUgbWVudSBjb250YWluaW5nIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWxlbWVudCBhbGxvd3MgdXMgdG8gZWFzaWx5IGRldGVybWluZSBpdHMgc2libGluZ3MuXHJcbiAgICAgIGxldCBzZWxlY3RlZENvbnRhaW5lcjogRnVpRHJvcGRvd25NZW51ID0gdGhpcztcclxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgIGNvbnN0IFtzZWxlY3RlZFBhcmVudF0gPSB0aGlzLnNlbGVjdGVkSXRlbXMuc2xpY2UoLTIpO1xyXG4gICAgICAgIHNlbGVjdGVkQ29udGFpbmVyID0gc2VsZWN0ZWRQYXJlbnQuY2hpbGREcm9wZG93bk1lbnU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XHJcbiAgICAgICAgLy8gRXNjYXBlIDogY2xvc2UgdGhlIGVudGlyZSBkcm9wZG93bi5cclxuICAgICAgICBjYXNlIEtleUNvZGUuRXNjYXBlOiB7XHJcbiAgICAgICAgICB0aGlzLl9zZXJ2aWNlLnNldE9wZW5TdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG93biA6IHNlbGVjdCB0aGUgbmV4dCBpdGVtIGJlbG93IHRoZSBjdXJyZW50IG9uZSwgb3IgdGhlIDFzdCBpZiBub25lIHNlbGVjdGVkLlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5Eb3duOlxyXG4gICAgICAgIC8vIFVwIDogc2VsZWN0IHRoZSBuZXh0IGl0ZW0gYWJvdmUgdGhlIGN1cnJlbnQgb25lLCBvciB0aGUgMXN0IGlmIG5vbmUgc2VsZWN0ZWQuXHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLlVwOiB7XHJcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMucG9wKCk7XHJcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMucHVzaChzZWxlY3RlZENvbnRhaW5lci51cGRhdGVTZWxlY3Rpb24oc2VsZWN0ZWQsIGUua2V5Q29kZSkpO1xyXG4gICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB3ZSBhcmUgaW4gYW4gaW5wdXQsIHRvIHN0b3AganVtcGluZyB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBxdWVyeSBzdHJpbmcuXHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRW50ZXIgOiBpZiB0aGUgaXRlbSBkb2Vzbid0IGNvbnRhaW4gYSBuZXN0ZWQgZHJvcGRvd24sICdjbGljaycgaXQuIE90aGVyd2lzZSwgZmFsbCB0aHJvdWdoIHRvICdSaWdodCcgYWN0aW9uLlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5FbnRlcjoge1xyXG4gICAgICAgICAgaWYgKHNlbGVjdGVkICYmICFzZWxlY3RlZC5oYXNDaGlsZERyb3Bkb3duKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkLnBlcmZvcm1DbGljaygpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxyXG4gICAgICAgIC8vIFJpZ2h0IDogaWYgdGhlIHNlbGVjdGVkIGl0ZW0gY29udGFpbnMgYSBuZXN0ZWQgZHJvcGRvd24sIG9wZW4gdGhlIGRyb3Bkb3duICYgc2VsZWN0IHRoZSAxc3QgaXRlbS5cclxuICAgICAgICBjYXNlIEtleUNvZGUuUmlnaHQ6IHtcclxuICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5oYXNDaGlsZERyb3Bkb3duKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkLmNoaWxkRHJvcGRvd25NZW51LnNlcnZpY2Uuc2V0T3BlblN0YXRlKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zLnB1c2goc2VsZWN0ZWQuY2hpbGREcm9wZG93bk1lbnUudXBkYXRlU2VsZWN0aW9uKHNlbGVjdGVkLCBlLmtleUNvZGUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMZWZ0IDogaWYgdGhlIHNlbGVjdGVkIGl0ZW0gaXMgaW4gYSBuZXN0ZWQgZHJvcGRvd24sIGNsb3NlIGl0IGFuZCBzZWxlY3QgdGhlIGNvbnRhaW5pbmcgaXRlbS5cclxuICAgICAgICBjYXNlIEtleUNvZGUuTGVmdDoge1xyXG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMucG9wKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IFtzZWxlY3RlZFBhcmVudF0gPSB0aGlzLnNlbGVjdGVkSXRlbXMuc2xpY2UoLTEpO1xyXG5cclxuICAgICAgICAgICAgc2VsZWN0ZWRQYXJlbnQuY2hpbGREcm9wZG93bk1lbnUuc2VydmljZS5zZXRPcGVuU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZWxlY3RlZFBhcmVudC5pc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlc2V0U2VsZWN0aW9uKCk6IHZvaWQge1xyXG4gICAgdGhpcy5zZWxlY3RlZEl0ZW1zID0gW107XHJcbiAgICB0aGlzLl9pdGVtcy5mb3JFYWNoKGkgPT4ge1xyXG4gICAgICBpLnNlbGVjdGVkQ2xhc3MgPSB0aGlzLm1lbnVTZWxlY3RlZEl0ZW1DbGFzcztcclxuICAgICAgaS5pc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5tZW51QXV0b1NlbGVjdEZpcnN0ICYmIHRoaXMuX2l0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgLy8gQXV0b3NlbGVjdCAxc3QgaXRlbSBpZiByZXF1aXJlZCAmIHBvc3NpYmxlLlxyXG4gICAgICB0aGlzLl9pdGVtc1swXS5pc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5zY3JvbGxUb0l0ZW0odGhpcy5faXRlbXNbMF0pO1xyXG4gICAgICB0aGlzLnNlbGVjdGVkSXRlbXMucHVzaCh0aGlzLl9pdGVtc1F1ZXJ5LmZpcnN0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIERldGVybWluZXMgdGhlIGl0ZW0gdG8gbmV4dCBiZSBzZWxlY3RlZCwgYmFzZWQgb24gdGhlIGtleWJvYXJkIGlucHV0ICYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLlxyXG4gIHB1YmxpYyB1cGRhdGVTZWxlY3Rpb24oc2VsZWN0ZWRJdGVtOiBGdWlEcm9wZG93bk1lbnVJdGVtLCBrZXlDb2RlOiBLZXlDb2RlKTogRnVpRHJvcGRvd25NZW51SXRlbSB7XHJcbiAgICBpZiAoc2VsZWN0ZWRJdGVtKSB7XHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgc2VsZWN0ZWQgc3RhdHVzIG9uIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIGl0ZW0uXHJcbiAgICAgIHNlbGVjdGVkSXRlbS5pc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHNlbGVjdGVkSW5kZXggPSB0aGlzLl9pdGVtc1xyXG4gICAgICAuZmluZEluZGV4KGkgPT4gaSA9PT0gc2VsZWN0ZWRJdGVtKTtcclxuXHJcbiAgICBsZXQgbmV3U2VsZWN0aW9uOiBGdWlEcm9wZG93bk1lbnVJdGVtO1xyXG5cclxuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xyXG4gICAgICBjYXNlIEtleUNvZGUuRW50ZXI6XHJcbiAgICAgIGNhc2UgS2V5Q29kZS5SaWdodDpcclxuICAgICAgY2FzZSBLZXlDb2RlLkRvd246XHJcbiAgICAgICAgc2VsZWN0ZWRJbmRleCArPSAxO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIEtleUNvZGUuVXA6XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAvLyBJZiBub25lIGFyZSBzZWxlY3RlZCwgc2VsZWN0IHRoZSAxc3QgaXRlbS4gU2hvdWxkIHRoaXMgYmUgYHRoaXMuaXRlbXMubGFzdCAtIDFgP1xyXG4gICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IDA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGVjdGVkSW5kZXggLT0gMTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWxlY3QgdGhlIGl0ZW0gYXQgdGhlIHVwZGF0ZWQgaW5kZXguIFRoZSB8fCBpcyB0byBzdG9wIHVzIHNlbGVjdGluZyBwYXN0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGl0ZW0gbGlzdC5cclxuICAgIG5ld1NlbGVjdGlvbiA9IHRoaXMuX2l0ZW1zW3NlbGVjdGVkSW5kZXhdIHx8IHNlbGVjdGVkSXRlbTtcclxuXHJcbiAgICBpZiAobmV3U2VsZWN0aW9uKSB7XHJcbiAgICAgIC8vIFNldCB0aGUgc2VsZWN0ZWQgc3RhdHVzIG9uIHRoZSBuZXdseSBzZWxlY3RlZCBpdGVtLlxyXG4gICAgICBuZXdTZWxlY3Rpb24uaXNTZWxlY3RlZCA9IHRydWU7XHJcblxyXG4gICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgbmV3bHkgc2VsZWN0ZWQgaXRlbS5cclxuICAgICAgdGhpcy5zY3JvbGxUb0l0ZW0obmV3U2VsZWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3U2VsZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNjcm9sbFRvSXRlbShpdGVtOiBGdWlEcm9wZG93bk1lbnVJdGVtKTogdm9pZCB7XHJcbiAgICBjb25zdCBtZW51OiBFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRSZWN0OiBDbGllbnRSZWN0ID0gaXRlbS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgY29uc3QgbWVudVJlY3QgPSBtZW51LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgIGxldCBzY3JvbGxBbW91bnQgPSAwO1xyXG5cclxuICAgIGlmIChzZWxlY3RlZFJlY3QuYm90dG9tID4gbWVudVJlY3QuYm90dG9tKSB7XHJcbiAgICAgIHNjcm9sbEFtb3VudCA9IHNlbGVjdGVkUmVjdC5ib3R0b20gLSBtZW51UmVjdC5ib3R0b207XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbGVjdGVkUmVjdC50b3AgPCBtZW51UmVjdC50b3ApIHtcclxuICAgICAgc2Nyb2xsQW1vdW50ID0gc2VsZWN0ZWRSZWN0LnRvcCAtIG1lbnVSZWN0LnRvcDtcclxuICAgIH1cclxuXHJcbiAgICBtZW51LnNjcm9sbFRvcCArPSBNYXRoLnJvdW5kKHNjcm9sbEFtb3VudCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5vbkl0ZW1zQ2hhbmdlZCgpO1xyXG4gICAgdGhpcy5faXRlbXNRdWVyeS5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uSXRlbXNDaGFuZ2VkKCkpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fcGFyZW50S2V5RG93bkxpc3RlbmVyKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9uSXRlbXNDaGFuZ2VkKCk6IHZvaWQge1xyXG4gICAgLy8gV2UgdXNlIGBfaXRlbXNgIHJhdGhlciB0aGFuIGBpdGVtc2AgaW4gY2FzZSBvbmUgb3IgbW9yZSBoYXZlIGJlY29tZSBkaXNhYmxlZC5cclxuICAgIHRoaXMucmVzZXRTZWxlY3Rpb24oKTtcclxuICB9XHJcbn1cclxuIl19