/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { EventEmitter } from '@angular/core';
// Creates essentially a 'string' enum.
/** @type {?} */
export const DropdownAutoCloseType = {
    ItemClick: (/** @type {?} */ ('itemClick')),
    OutsideClick: (/** @type {?} */ ('outsideClick')),
    Disabled: (/** @type {?} */ ('disabled'))
};
export class DropdownService {
    /**
     * @param {?=} autoCloseMode
     */
    constructor(autoCloseMode = DropdownAutoCloseType.ItemClick) {
        this.isOpen = false;
        this.isOpenChange = new EventEmitter();
        this.isDisabled = false;
        this.autoCloseMode = autoCloseMode;
        this.children = [];
    }
    /**
     * @return {?}
     */
    get isNested() {
        return !!this.parent;
    }
    /**
     * @param {?} isOpen
     * @param {?=} reflectInParent
     * @return {?}
     */
    setOpenState(isOpen, reflectInParent = false) {
        if (this.isOpen !== isOpen && !this.isDisabled) {
            // Only update the state if it has changed, and the dropdown isn't disabled.
            this.isOpen = !!isOpen;
            this.isAnimating = true;
            // We must delay the emitting to avoid the 'changed after checked' Angular errors.
            this.delay((/**
             * @return {?}
             */
            () => this.isOpenChange.emit(this.isOpen)));
            if (!this.isOpen) {
                // Close the child dropdowns when this one closes.
                this.children.forEach((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => c.setOpenState(this.isOpen)));
            }
            if (this.parent && reflectInParent) {
                // Open the parent dropdowns when this one opens.
                this.parent.setOpenState(this.isOpen, true);
            }
        }
        else if (this.isOpen !== isOpen && this.isDisabled) {
            // If the state has changed, but the dropdown is disabled, re-emit the original isOpen value.
            this.delay((/**
             * @return {?}
             */
            () => this.isOpenChange.emit(this.isOpen)));
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        if (this.isDisabled !== isDisabled) {
            if (!!isDisabled) {
                // Close the dropdown as it is now disabled
                this.setOpenState(false);
            }
            this.isDisabled = !!isDisabled;
        }
    }
    /**
     * @return {?}
     */
    toggleOpenState() {
        this.setOpenState(!this.isOpen);
    }
    // Registers a dropdown service as a child of this service.
    /**
     * @param {?} child
     * @return {?}
     */
    registerChild(child) {
        if (!this.isChildRegistered(child)) {
            this.children.push(child);
            child.parent = this;
        }
    }
    // Recursive method to check if the provided dropdown is already registered as a child, or is a descendant of a child.
    /**
     * @param {?} child
     * @return {?}
     */
    isChildRegistered(child) {
        return this === child || !!this.children
            .find((/**
         * @param {?} c
         * @return {?}
         */
        c => !!c.children
            .find((/**
         * @param {?} cChild
         * @return {?}
         */
        cChild => cChild.isChildRegistered(child)))));
    }
    // Wipes any nested data, so all services can be cleanly reattached.
    /**
     * @return {?}
     */
    clearChildren() {
        this.children.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => {
            c.parent = undefined;
        }));
        this.children = [];
    }
    // Method for delaying an event into the next tick, to avoid Angular "changed after checked" error.
    /**
     * @private
     * @param {?} callback
     * @return {?}
     */
    delay(callback) {
        setTimeout((/**
         * @return {?}
         */
        () => callback()));
    }
}
if (false) {
    /** @type {?} */
    DropdownService.prototype.isOpen;
    /** @type {?} */
    DropdownService.prototype.isAnimating;
    /** @type {?} */
    DropdownService.prototype.isOpenChange;
    /** @type {?} */
    DropdownService.prototype.isDisabled;
    /** @type {?} */
    DropdownService.prototype.autoCloseMode;
    /** @type {?} */
    DropdownService.prototype.parent;
    /** @type {?} */
    DropdownService.prototype.children;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1mb21hbnRpYy11aS8iLCJzb3VyY2VzIjpbIm1vZHVsZXMvZHJvcGRvd24vc2VydmljZXMvZHJvcGRvd24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLGVBQWUsQ0FBQzs7O0FBSzNDLE1BQU0sT0FBTyxxQkFBcUIsR0FBRztJQUNuQyxTQUFTLEVBQUUsbUJBQUEsV0FBVyxFQUF5QjtJQUMvQyxZQUFZLEVBQUUsbUJBQUEsY0FBYyxFQUF5QjtJQUNyRCxRQUFRLEVBQUUsbUJBQUEsVUFBVSxFQUF5QjtDQUM5QztBQUVELE1BQU0sT0FBTyxlQUFlOzs7O0lBa0IxQixZQUFZLGdCQUF1QyxxQkFBcUIsQ0FBQyxTQUFTO1FBQ2hGLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxZQUFZLEVBQVcsQ0FBQztRQUVoRCxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUV4QixJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztRQUVuQyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNyQixDQUFDOzs7O0lBRUQsSUFBVyxRQUFRO1FBQ2pCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDdkIsQ0FBQzs7Ozs7O0lBRU0sWUFBWSxDQUFDLE1BQWUsRUFBRSxrQkFBMkIsS0FBSztRQUNuRSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUM5Qyw0RUFBNEU7WUFDNUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3hCLGtGQUFrRjtZQUNsRixJQUFJLENBQUMsS0FBSzs7O1lBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFDLENBQUM7WUFFdEQsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ2hCLGtEQUFrRDtnQkFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPOzs7O2dCQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUMsQ0FBQzthQUN6RDtZQUVELElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxlQUFlLEVBQUU7Z0JBQ2xDLGlEQUFpRDtnQkFDakQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQzthQUM3QztTQUNGO2FBQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ3BELDZGQUE2RjtZQUM3RixJQUFJLENBQUMsS0FBSzs7O1lBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFDLENBQUM7U0FDdkQ7SUFDSCxDQUFDOzs7OztJQUVNLGdCQUFnQixDQUFDLFVBQW1CO1FBQ3pDLElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLEVBQUU7WUFDbEMsSUFBSSxDQUFDLENBQUMsVUFBVSxFQUFFO2dCQUNoQiwyQ0FBMkM7Z0JBQzNDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDMUI7WUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUM7U0FDaEM7SUFDSCxDQUFDOzs7O0lBRU0sZUFBZTtRQUNwQixJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2xDLENBQUM7Ozs7OztJQUdNLGFBQWEsQ0FBQyxLQUFzQjtRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2xDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzFCLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1NBQ3JCO0lBQ0gsQ0FBQzs7Ozs7O0lBR00saUJBQWlCLENBQUMsS0FBc0I7UUFDN0MsT0FBTyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUTthQUNyQyxJQUFJOzs7O1FBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVE7YUFDcEIsSUFBSTs7OztRQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxFQUFDLEVBQUMsQ0FBQztJQUN4RCxDQUFDOzs7OztJQUdNLGFBQWE7UUFDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPOzs7O1FBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDeEIsQ0FBQyxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7UUFDdkIsQ0FBQyxFQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNyQixDQUFDOzs7Ozs7O0lBR08sS0FBSyxDQUFDLFFBQW9CO1FBQ2hDLFVBQVU7OztRQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFDLENBQUM7SUFDL0IsQ0FBQztDQUNGOzs7SUFoR0MsaUNBQXVCOztJQUV2QixzQ0FBNEI7O0lBRTVCLHVDQUEyQzs7SUFFM0MscUNBQTJCOztJQUczQix3Q0FBNEM7O0lBRzVDLGlDQUFnQzs7SUFFaEMsbUNBQW1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtFdmVudEVtaXR0ZXJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuZXhwb3J0IHR5cGUgRHJvcGRvd25BdXRvQ2xvc2VUeXBlID0gJ2l0ZW1DbGljaycgfCAnb3V0c2lkZUNsaWNrJyB8ICdkaXNhYmxlZCc7XHJcblxyXG4vLyBDcmVhdGVzIGVzc2VudGlhbGx5IGEgJ3N0cmluZycgZW51bS5cclxuZXhwb3J0IGNvbnN0IERyb3Bkb3duQXV0b0Nsb3NlVHlwZSA9IHtcclxuICBJdGVtQ2xpY2s6ICdpdGVtQ2xpY2snIGFzIERyb3Bkb3duQXV0b0Nsb3NlVHlwZSxcclxuICBPdXRzaWRlQ2xpY2s6ICdvdXRzaWRlQ2xpY2snIGFzIERyb3Bkb3duQXV0b0Nsb3NlVHlwZSxcclxuICBEaXNhYmxlZDogJ2Rpc2FibGVkJyBhcyBEcm9wZG93bkF1dG9DbG9zZVR5cGVcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBEcm9wZG93blNlcnZpY2Uge1xyXG4gIC8vIE9wZW4gc3RhdGUgb2YgdGhlIGRyb3Bkb3duXHJcbiAgcHVibGljIGlzT3BlbjogYm9vbGVhbjtcclxuICAvLyBBbmltYXRpbmcgc3RhdGUgb2YgdGhlIGRyb3Bkb3duLlxyXG4gIHB1YmxpYyBpc0FuaW1hdGluZzogYm9vbGVhbjtcclxuICAvLyBFbWl0dGVyIGZvciB3aGVuIGRyb3Bkb3duIG9wZW4gc3RhdGUgY2hhbmdlcy5cclxuICBwdWJsaWMgaXNPcGVuQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XHJcblxyXG4gIHB1YmxpYyBpc0Rpc2FibGVkOiBib29sZWFuO1xyXG5cclxuICAvLyBTZXRzIHRoZSBcImF1dG9jbG9zZVwiIG1vZGUgb2YgdGhlIGRyb3Bkb3duIC0gaS5lLiB3aGF0IHVzZXIgYWN0aW9uIGNhdXNlcyBpdCB0byBhdXRvY2xvc2UuXHJcbiAgcHVibGljIGF1dG9DbG9zZU1vZGU6IERyb3Bkb3duQXV0b0Nsb3NlVHlwZTtcclxuXHJcbiAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY29udGFpbmluZyBkcm9wZG93biBzbyB3ZSBjYW4gb3BlbiBpdCBhcyBuZWNlc3NhcnkuXHJcbiAgcHVibGljIHBhcmVudD86IERyb3Bkb3duU2VydmljZTtcclxuICAvLyBBbHNvIGtlZXAgdHJhY2sgb2YgZHJvcGRvd25zIG5lc3RlZCBpbiB0aGlzIG9uZSBzbyB3ZSBjYW4gY2xvc2UgdGhlbSBhcyBuZWNlc3NhcnkuXHJcbiAgcHVibGljIGNoaWxkcmVuOiBEcm9wZG93blNlcnZpY2VbXTtcclxuXHJcbiAgY29uc3RydWN0b3IoYXV0b0Nsb3NlTW9kZTogRHJvcGRvd25BdXRvQ2xvc2VUeXBlID0gRHJvcGRvd25BdXRvQ2xvc2VUeXBlLkl0ZW1DbGljaykge1xyXG4gICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcclxuICAgIHRoaXMuaXNPcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xyXG5cclxuICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuYXV0b0Nsb3NlTW9kZSA9IGF1dG9DbG9zZU1vZGU7XHJcblxyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBpc05lc3RlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAhIXRoaXMucGFyZW50O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldE9wZW5TdGF0ZShpc09wZW46IGJvb2xlYW4sIHJlZmxlY3RJblBhcmVudDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5pc09wZW4gIT09IGlzT3BlbiAmJiAhdGhpcy5pc0Rpc2FibGVkKSB7XHJcbiAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBzdGF0ZSBpZiBpdCBoYXMgY2hhbmdlZCwgYW5kIHRoZSBkcm9wZG93biBpc24ndCBkaXNhYmxlZC5cclxuICAgICAgdGhpcy5pc09wZW4gPSAhIWlzT3BlbjtcclxuICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XHJcbiAgICAgIC8vIFdlIG11c3QgZGVsYXkgdGhlIGVtaXR0aW5nIHRvIGF2b2lkIHRoZSAnY2hhbmdlZCBhZnRlciBjaGVja2VkJyBBbmd1bGFyIGVycm9ycy5cclxuICAgICAgdGhpcy5kZWxheSgoKSA9PiB0aGlzLmlzT3BlbkNoYW5nZS5lbWl0KHRoaXMuaXNPcGVuKSk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XHJcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGNoaWxkIGRyb3Bkb3ducyB3aGVuIHRoaXMgb25lIGNsb3Nlcy5cclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goYyA9PiBjLnNldE9wZW5TdGF0ZSh0aGlzLmlzT3BlbikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5wYXJlbnQgJiYgcmVmbGVjdEluUGFyZW50KSB7XHJcbiAgICAgICAgLy8gT3BlbiB0aGUgcGFyZW50IGRyb3Bkb3ducyB3aGVuIHRoaXMgb25lIG9wZW5zLlxyXG4gICAgICAgIHRoaXMucGFyZW50LnNldE9wZW5TdGF0ZSh0aGlzLmlzT3BlbiwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5pc09wZW4gIT09IGlzT3BlbiAmJiB0aGlzLmlzRGlzYWJsZWQpIHtcclxuICAgICAgLy8gSWYgdGhlIHN0YXRlIGhhcyBjaGFuZ2VkLCBidXQgdGhlIGRyb3Bkb3duIGlzIGRpc2FibGVkLCByZS1lbWl0IHRoZSBvcmlnaW5hbCBpc09wZW4gdmFsdWUuXHJcbiAgICAgIHRoaXMuZGVsYXkoKCkgPT4gdGhpcy5pc09wZW5DaGFuZ2UuZW1pdCh0aGlzLmlzT3BlbikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCAhPT0gaXNEaXNhYmxlZCkge1xyXG4gICAgICBpZiAoISFpc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGRyb3Bkb3duIGFzIGl0IGlzIG5vdyBkaXNhYmxlZFxyXG4gICAgICAgIHRoaXMuc2V0T3BlblN0YXRlKGZhbHNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5pc0Rpc2FibGVkID0gISFpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHRvZ2dsZU9wZW5TdGF0ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuc2V0T3BlblN0YXRlKCF0aGlzLmlzT3Blbik7XHJcbiAgfVxyXG5cclxuICAvLyBSZWdpc3RlcnMgYSBkcm9wZG93biBzZXJ2aWNlIGFzIGEgY2hpbGQgb2YgdGhpcyBzZXJ2aWNlLlxyXG4gIHB1YmxpYyByZWdpc3RlckNoaWxkKGNoaWxkOiBEcm9wZG93blNlcnZpY2UpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5pc0NoaWxkUmVnaXN0ZXJlZChjaGlsZCkpIHtcclxuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlY3Vyc2l2ZSBtZXRob2QgdG8gY2hlY2sgaWYgdGhlIHByb3ZpZGVkIGRyb3Bkb3duIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBhcyBhIGNoaWxkLCBvciBpcyBhIGRlc2NlbmRhbnQgb2YgYSBjaGlsZC5cclxuICBwdWJsaWMgaXNDaGlsZFJlZ2lzdGVyZWQoY2hpbGQ6IERyb3Bkb3duU2VydmljZSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMgPT09IGNoaWxkIHx8ICEhdGhpcy5jaGlsZHJlblxyXG4gICAgICAuZmluZChjID0+ICEhYy5jaGlsZHJlblxyXG4gICAgICAgIC5maW5kKGNDaGlsZCA9PiBjQ2hpbGQuaXNDaGlsZFJlZ2lzdGVyZWQoY2hpbGQpKSk7XHJcbiAgfVxyXG5cclxuICAvLyBXaXBlcyBhbnkgbmVzdGVkIGRhdGEsIHNvIGFsbCBzZXJ2aWNlcyBjYW4gYmUgY2xlYW5seSByZWF0dGFjaGVkLlxyXG4gIHB1YmxpYyBjbGVhckNoaWxkcmVuKCk6IHZvaWQge1xyXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xyXG4gICAgICBjLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLy8gTWV0aG9kIGZvciBkZWxheWluZyBhbiBldmVudCBpbnRvIHRoZSBuZXh0IHRpY2ssIHRvIGF2b2lkIEFuZ3VsYXIgXCJjaGFuZ2VkIGFmdGVyIGNoZWNrZWRcIiBlcnJvci5cclxuICBwcml2YXRlIGRlbGF5KGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKCkpO1xyXG4gIH1cclxufVxyXG4iXX0=