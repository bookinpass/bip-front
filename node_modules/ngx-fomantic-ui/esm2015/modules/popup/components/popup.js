/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, HostBinding, HostListener, ViewChild, ViewContainerRef } from '@angular/core';
import { PositioningService } from '../../../misc/util/internal';
import { Transition, TransitionController, TransitionDirection } from '../../transition/internal';
export class FuiPopup {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.transitionController = new TransitionController(false);
        this._isOpen = false;
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this.tabindex = 0;
    }
    // Returns the direction (`top`, `left`, `right`, `bottom`) of the current placement.
    /**
     * @return {?}
     */
    get direction() {
        // We need to set direction attribute before popper init to allow correct positioning
        return this.config.placement.split(' ').shift();
    }
    // Returns the alignment (`top`, `left`, `right`, `bottom`) of the current placement.
    /**
     * @return {?}
     */
    get alignment() {
        return this.config.placement.split(' ').pop();
    }
    /**
     * @return {?}
     */
    get dynamicClasses() {
        /** @type {?} */
        const classes = {};
        if (this.direction) {
            classes[this.direction] = true;
        }
        if (this.alignment) {
            classes[this.alignment] = true;
        }
        if (this.config.isInverted) {
            classes.inverted = true;
        }
        if (this.config.isBasic) {
            classes.basic = true;
        }
        if (this.config.isFlowing) {
            classes.flowing = true;
        }
        if (this.config.size) {
            classes[this.config.size] = true;
        }
        if (this.config.width) {
            classes[this.config.width] = true;
        }
        return classes;
    }
    /**
     * @param {?} anchor
     * @return {?}
     */
    set anchor(anchor) {
        this._anchor = anchor;
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @return {?}
     */
    open() {
        // Only attempt to open if currently closed.
        if (!this.isOpen) {
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Create positioning service after a brief delay.
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.positioningService = new PositioningService(this._anchor, this._container.element, this.config.placement, '.dynamic.arrow');
                this.positioningService.hasArrow = !this.config.isBasic;
            }));
            // Cancel all other transitions, and initiate the opening transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.In, (/**
             * @return {?}
             */
            () => {
                // Focus any element with [autofocus] attribute.
                /** @type {?} */
                const autoFocus = (/** @type {?} */ (this.elementRef.nativeElement.querySelector('[autofocus]')));
                if (autoFocus) {
                    // Autofocus after the browser has had time to process other event handlers.
                    setTimeout((/**
                     * @return {?}
                     */
                    () => autoFocus.focus()), 10);
                    // Try to focus again when the modal has opened so that autofocus works in IE11.
                    setTimeout((/**
                     * @return {?}
                     */
                    () => autoFocus.focus()), this.config.transitionDuration);
                }
            })));
            // Finally, set the popup to be open.
            this._isOpen = true;
            this.onOpen.emit();
        }
    }
    /**
     * @return {?}
     */
    toggle() {
        if (!this.isOpen) {
            return this.open();
        }
        return this.close();
    }
    /**
     * @return {?}
     */
    close() {
        // Only attempt to close if currently open.
        if (this.isOpen) {
            // Cancel all other transitions, and initiate the closing transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.Out));
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Start the closing timer, that fires the `onClose` event after the transition duration number of milliseconds.
            this.closingTimeout = window.setTimeout((/**
             * @return {?}
             */
            () => this.onClose.emit()), this.config.transitionDuration);
            // Finally, set the popup to be closed.
            this._isOpen = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        // Makes sense here, as the popup shouldn't be attached to any DOM element.
        event.stopPropagation();
    }
}
FuiPopup.decorators = [
    { type: Component, args: [{
                selector: 'fui-popup',
                template: `
<div class="ui popup"
     [ngClass]="dynamicClasses"
     [fuiTransition]="transitionController"
     [attr.direction]="direction"
     #container>

    <ng-container *ngIf="!config.template && (!!config.header || !!config.text)">
        <div class="header" *ngIf="config.header">{{ config.header }}</div>
        <div class="content">{{ config.text }}</div>
    </ng-container>
    <div #templateSibling></div>

    <fui-popup-arrow *ngIf="!config.isBasic"
                     [placement]="config.placement"
                     [inverted]="config.isInverted"></fui-popup-arrow>
</div>
`,
                styles: [`
.ui.popup {
    /* Autofit popup to the contents. */
    right: auto;
    margin: 0;
}

.ui.animating.popup {
    /* When the popup is animating, it may not initially be in the correct position.
       This fires a mouse event, causing the anchor's mouseleave to fire - making the popup flicker.
       Setting pointer-events to none while animating fixes this bug. */
    pointer-events: none;
}

.ui.popup::before {
    /* Hide the Fomantic UI CSS arrow. */
    display: none;
}

/* Offset popup by 0.75em above and below when placed 'vertically'. */
.ui.popup[direction="top"],
.ui.popup[direction="bottom"] {
    margin-top: 0.75em;
    margin-bottom: 0.75em;
}

/* Offset popup by 0.75em either side when placed 'horizontally'. */
.ui.popup[direction="left"],
.ui.popup[direction="right"] {
    margin-left: 0.75em;
    margin-right: 0.75em;
}
`]
            }] }
];
/** @nocollapse */
FuiPopup.ctorParameters = () => [
    { type: ElementRef }
];
FuiPopup.propDecorators = {
    templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: true },] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    _container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: false },] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    FuiPopup.prototype.config;
    /** @type {?} */
    FuiPopup.prototype.transitionController;
    /** @type {?} */
    FuiPopup.prototype.positioningService;
    /** @type {?} */
    FuiPopup.prototype.closingTimeout;
    /** @type {?} */
    FuiPopup.prototype.onOpen;
    /** @type {?} */
    FuiPopup.prototype.onClose;
    /** @type {?} */
    FuiPopup.prototype.templateSibling;
    /** @type {?} */
    FuiPopup.prototype.tabindex;
    /**
     * @type {?}
     * @private
     */
    FuiPopup.prototype._container;
    /**
     * @type {?}
     * @private
     */
    FuiPopup.prototype._anchor;
    /**
     * @type {?}
     * @private
     */
    FuiPopup.prototype._isOpen;
    /** @type {?} */
    FuiPopup.prototype.elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wdXAuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtZm9tYW50aWMtdWkvIiwic291cmNlcyI6WyJtb2R1bGVzL3BvcHVwL2NvbXBvbmVudHMvcG9wdXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUMxSCxPQUFPLEVBQWtCLGtCQUFrQixFQUFDLE1BQU0sNkJBQTZCLENBQUM7QUFDaEYsT0FBTyxFQUFDLFVBQVUsRUFBRSxvQkFBb0IsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBMERoRyxNQUFNLE9BQU8sUUFBUTs7OztJQXFCbkIsWUFBbUIsVUFBc0I7UUFBdEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN2QyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU1RCxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUVyQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7UUFDdkMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBRXhDLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0lBQ3BCLENBQUM7Ozs7O0lBR0QsSUFBVyxTQUFTO1FBQ2xCLHFGQUFxRjtRQUNyRixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNsRCxDQUFDOzs7OztJQUdELElBQVcsU0FBUztRQUNsQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNoRCxDQUFDOzs7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O3lCQUNVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdDVjthQUNBOzs7O1lBM0RrQixVQUFVOzs7OEJBeUUxQixTQUFTLFNBQUMsaUJBQWlCLEVBQUUsRUFBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBQzt1QkFFbkUsV0FBVyxTQUFDLGVBQWU7eUJBRzNCLFNBQVMsU0FBQyxXQUFXLEVBQUUsRUFBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBQztzQkErSDlELFlBQVksU0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUM7Ozs7SUE5SWpDLDBCQUF3Qzs7SUFDeEMsd0NBQWtEOztJQUNsRCxzQ0FBOEM7O0lBRTlDLGtDQUE4Qjs7SUFFOUIsMEJBQWtDOztJQUVsQywyQkFBbUM7O0lBRW5DLG1DQUN5Qzs7SUFDekMsNEJBQ2lDOzs7OztJQUVqQyw4QkFDcUM7Ozs7O0lBa0RyQywyQkFBNEI7Ozs7O0lBTzVCLDJCQUF5Qjs7SUF2RGIsOEJBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtJRHluYW1pY0NsYXNzZXMsIFBvc2l0aW9uaW5nU2VydmljZX0gZnJvbSAnLi4vLi4vLi4vbWlzYy91dGlsL2ludGVybmFsJztcclxuaW1wb3J0IHtUcmFuc2l0aW9uLCBUcmFuc2l0aW9uQ29udHJvbGxlciwgVHJhbnNpdGlvbkRpcmVjdGlvbn0gZnJvbSAnLi4vLi4vdHJhbnNpdGlvbi9pbnRlcm5hbCc7XHJcbmltcG9ydCB7SVBvcHVwfSBmcm9tICcuLi9jbGFzc2VzL3BvcHVwLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQge1RlbXBsYXRlUG9wdXBDb25maWd9IGZyb20gJy4uL2NsYXNzZXMvcG9wdXAtdGVtcGxhdGUtY29udHJvbGxlcic7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2Z1aS1wb3B1cCcsXHJcbiAgdGVtcGxhdGU6IGBcclxuPGRpdiBjbGFzcz1cInVpIHBvcHVwXCJcclxuICAgICBbbmdDbGFzc109XCJkeW5hbWljQ2xhc3Nlc1wiXHJcbiAgICAgW2Z1aVRyYW5zaXRpb25dPVwidHJhbnNpdGlvbkNvbnRyb2xsZXJcIlxyXG4gICAgIFthdHRyLmRpcmVjdGlvbl09XCJkaXJlY3Rpb25cIlxyXG4gICAgICNjb250YWluZXI+XHJcblxyXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFjb25maWcudGVtcGxhdGUgJiYgKCEhY29uZmlnLmhlYWRlciB8fCAhIWNvbmZpZy50ZXh0KVwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJoZWFkZXJcIiAqbmdJZj1cImNvbmZpZy5oZWFkZXJcIj57eyBjb25maWcuaGVhZGVyIH19PC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj57eyBjb25maWcudGV4dCB9fTwvZGl2PlxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcbiAgICA8ZGl2ICN0ZW1wbGF0ZVNpYmxpbmc+PC9kaXY+XHJcblxyXG4gICAgPGZ1aS1wb3B1cC1hcnJvdyAqbmdJZj1cIiFjb25maWcuaXNCYXNpY1wiXHJcbiAgICAgICAgICAgICAgICAgICAgIFtwbGFjZW1lbnRdPVwiY29uZmlnLnBsYWNlbWVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgIFtpbnZlcnRlZF09XCJjb25maWcuaXNJbnZlcnRlZFwiPjwvZnVpLXBvcHVwLWFycm93PlxyXG48L2Rpdj5cclxuYCxcclxuICBzdHlsZXM6IFtgXHJcbi51aS5wb3B1cCB7XHJcbiAgICAvKiBBdXRvZml0IHBvcHVwIHRvIHRoZSBjb250ZW50cy4gKi9cclxuICAgIHJpZ2h0OiBhdXRvO1xyXG4gICAgbWFyZ2luOiAwO1xyXG59XHJcblxyXG4udWkuYW5pbWF0aW5nLnBvcHVwIHtcclxuICAgIC8qIFdoZW4gdGhlIHBvcHVwIGlzIGFuaW1hdGluZywgaXQgbWF5IG5vdCBpbml0aWFsbHkgYmUgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24uXHJcbiAgICAgICBUaGlzIGZpcmVzIGEgbW91c2UgZXZlbnQsIGNhdXNpbmcgdGhlIGFuY2hvcidzIG1vdXNlbGVhdmUgdG8gZmlyZSAtIG1ha2luZyB0aGUgcG9wdXAgZmxpY2tlci5cclxuICAgICAgIFNldHRpbmcgcG9pbnRlci1ldmVudHMgdG8gbm9uZSB3aGlsZSBhbmltYXRpbmcgZml4ZXMgdGhpcyBidWcuICovXHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxufVxyXG5cclxuLnVpLnBvcHVwOjpiZWZvcmUge1xyXG4gICAgLyogSGlkZSB0aGUgRm9tYW50aWMgVUkgQ1NTIGFycm93LiAqL1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxufVxyXG5cclxuLyogT2Zmc2V0IHBvcHVwIGJ5IDAuNzVlbSBhYm92ZSBhbmQgYmVsb3cgd2hlbiBwbGFjZWQgJ3ZlcnRpY2FsbHknLiAqL1xyXG4udWkucG9wdXBbZGlyZWN0aW9uPVwidG9wXCJdLFxyXG4udWkucG9wdXBbZGlyZWN0aW9uPVwiYm90dG9tXCJdIHtcclxuICAgIG1hcmdpbi10b3A6IDAuNzVlbTtcclxuICAgIG1hcmdpbi1ib3R0b206IDAuNzVlbTtcclxufVxyXG5cclxuLyogT2Zmc2V0IHBvcHVwIGJ5IDAuNzVlbSBlaXRoZXIgc2lkZSB3aGVuIHBsYWNlZCAnaG9yaXpvbnRhbGx5Jy4gKi9cclxuLnVpLnBvcHVwW2RpcmVjdGlvbj1cImxlZnRcIl0sXHJcbi51aS5wb3B1cFtkaXJlY3Rpb249XCJyaWdodFwiXSB7XHJcbiAgICBtYXJnaW4tbGVmdDogMC43NWVtO1xyXG4gICAgbWFyZ2luLXJpZ2h0OiAwLjc1ZW07XHJcbn1cclxuYF1cclxufSlcclxuZXhwb3J0IGNsYXNzIEZ1aVBvcHVwIGltcGxlbWVudHMgSVBvcHVwIHtcclxuXHJcbiAgLy8gQ29uZmlnIHNldHRpbmdzIGZvciB0aGlzIHBvcHVwLlxyXG4gIHB1YmxpYyBjb25maWc6IFRlbXBsYXRlUG9wdXBDb25maWc8YW55PjtcclxuICBwdWJsaWMgdHJhbnNpdGlvbkNvbnRyb2xsZXI6IFRyYW5zaXRpb25Db250cm9sbGVyO1xyXG4gIHB1YmxpYyBwb3NpdGlvbmluZ1NlcnZpY2U6IFBvc2l0aW9uaW5nU2VydmljZTtcclxuICAvLyBgc2V0VGltZW91dGAgdGltZXIgcG9pbnRlciBmb3IgY2FuY2VsbGluZyBwb3B1cCBjbG9zZS5cclxuICBwdWJsaWMgY2xvc2luZ1RpbWVvdXQ6IG51bWJlcjtcclxuICAvLyBGaXJlcyB3aGVuIHRoZSBwb3B1cCBvcGVucyAoYW5kIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVkKS5cclxuICBwdWJsaWMgb25PcGVuOiBFdmVudEVtaXR0ZXI8dm9pZD47XHJcbiAgLy8gRmlyZXMgd2hlbiB0aGUgcG9wdXAgY2xvc2VzIChhbmQgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZWQpLlxyXG4gIHB1YmxpYyBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8dm9pZD47XHJcbiAgLy8gYFZpZXdDb250YWluZXJSZWZgIGZvciB0aGUgZWxlbWVudCB0aGUgdGVtcGxhdGUgZ2V0cyBpbmplY3RlZCBhcyBhIHNpYmxpbmcgb2YuXHJcbiAgQFZpZXdDaGlsZCgndGVtcGxhdGVTaWJsaW5nJywge3JlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogdHJ1ZX0pXHJcbiAgcHVibGljIHRlbXBsYXRlU2libGluZzogVmlld0NvbnRhaW5lclJlZjtcclxuICBASG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKVxyXG4gIHB1YmxpYyByZWFkb25seSB0YWJpbmRleDogbnVtYmVyO1xyXG4gIC8vIGBFbGVtZW50UmVmYCBmb3IgdGhlIHBvc2l0aW9uaW5nIHN1YmplY3QuXHJcbiAgQFZpZXdDaGlsZCgnY29udGFpbmVyJywge3JlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogZmFsc2V9KVxyXG4gIHByaXZhdGUgX2NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcclxuXHJcbiAgY29uc3RydWN0b3IocHVibGljIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcclxuICAgIHRoaXMudHJhbnNpdGlvbkNvbnRyb2xsZXIgPSBuZXcgVHJhbnNpdGlvbkNvbnRyb2xsZXIoZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMub25PcGVuID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG4gICAgdGhpcy5vbkNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuICAgIHRoaXMudGFiaW5kZXggPSAwO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJucyB0aGUgZGlyZWN0aW9uIChgdG9wYCwgYGxlZnRgLCBgcmlnaHRgLCBgYm90dG9tYCkgb2YgdGhlIGN1cnJlbnQgcGxhY2VtZW50LlxyXG4gIHB1YmxpYyBnZXQgZGlyZWN0aW9uKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgICAvLyBXZSBuZWVkIHRvIHNldCBkaXJlY3Rpb24gYXR0cmlidXRlIGJlZm9yZSBwb3BwZXIgaW5pdCB0byBhbGxvdyBjb3JyZWN0IHBvc2l0aW9uaW5nXHJcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGxhY2VtZW50LnNwbGl0KCcgJykuc2hpZnQoKTtcclxuICB9XHJcblxyXG4gIC8vIFJldHVybnMgdGhlIGFsaWdubWVudCAoYHRvcGAsIGBsZWZ0YCwgYHJpZ2h0YCwgYGJvdHRvbWApIG9mIHRoZSBjdXJyZW50IHBsYWNlbWVudC5cclxuICBwdWJsaWMgZ2V0IGFsaWdubWVudCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsYWNlbWVudC5zcGxpdCgnICcpLnBvcCgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBkeW5hbWljQ2xhc3NlcygpOiBJRHluYW1pY0NsYXNzZXMge1xyXG4gICAgY29uc3QgY2xhc3NlczogSUR5bmFtaWNDbGFzc2VzID0ge307XHJcbiAgICBpZiAodGhpcy5kaXJlY3Rpb24pIHtcclxuICAgICAgY2xhc3Nlc1t0aGlzLmRpcmVjdGlvbl0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuYWxpZ25tZW50KSB7XHJcbiAgICAgIGNsYXNzZXNbdGhpcy5hbGlnbm1lbnRdID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNvbmZpZy5pc0ludmVydGVkKSB7XHJcbiAgICAgIGNsYXNzZXMuaW52ZXJ0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY29uZmlnLmlzQmFzaWMpIHtcclxuICAgICAgY2xhc3Nlcy5iYXNpYyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jb25maWcuaXNGbG93aW5nKSB7XHJcbiAgICAgIGNsYXNzZXMuZmxvd2luZyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jb25maWcuc2l6ZSkge1xyXG4gICAgICBjbGFzc2VzW3RoaXMuY29uZmlnLnNpemVdID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNvbmZpZy53aWR0aCkge1xyXG4gICAgICBjbGFzc2VzW3RoaXMuY29uZmlnLndpZHRoXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xhc3NlcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX2FuY2hvcjogRWxlbWVudFJlZjtcclxuXHJcbiAgcHVibGljIHNldCBhbmNob3IoYW5jaG9yOiBFbGVtZW50UmVmKSB7XHJcbiAgICB0aGlzLl9hbmNob3IgPSBhbmNob3I7XHJcbiAgfVxyXG5cclxuICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSBwb3B1cCBpcyBvcGVuIGludGVybmFsbHkuXHJcbiAgcHJpdmF0ZSBfaXNPcGVuOiBib29sZWFuO1xyXG5cclxuICBwdWJsaWMgZ2V0IGlzT3BlbigpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9pc09wZW47XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgb3BlbigpOiB2b2lkIHtcclxuICAgIC8vIE9ubHkgYXR0ZW1wdCB0byBvcGVuIGlmIGN1cnJlbnRseSBjbG9zZWQuXHJcbiAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XHJcbiAgICAgIC8vIENhbmNlbCB0aGUgY2xvc2luZyB0aW1lci5cclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2luZ1RpbWVvdXQpO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIHBvc2l0aW9uaW5nIHNlcnZpY2UgYWZ0ZXIgYSBicmllZiBkZWxheS5cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbmluZ1NlcnZpY2UgPSBuZXcgUG9zaXRpb25pbmdTZXJ2aWNlKFxyXG4gICAgICAgICAgdGhpcy5fYW5jaG9yLFxyXG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyLmVsZW1lbnQsXHJcbiAgICAgICAgICB0aGlzLmNvbmZpZy5wbGFjZW1lbnQsXHJcbiAgICAgICAgICAnLmR5bmFtaWMuYXJyb3cnXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uaW5nU2VydmljZS5oYXNBcnJvdyA9ICF0aGlzLmNvbmZpZy5pc0Jhc2ljO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIENhbmNlbCBhbGwgb3RoZXIgdHJhbnNpdGlvbnMsIGFuZCBpbml0aWF0ZSB0aGUgb3BlbmluZyB0cmFuc2l0aW9uLlxyXG4gICAgICB0aGlzLnRyYW5zaXRpb25Db250cm9sbGVyLnN0b3BBbGwoKTtcclxuICAgICAgdGhpcy50cmFuc2l0aW9uQ29udHJvbGxlci5hbmltYXRlKFxyXG4gICAgICAgIG5ldyBUcmFuc2l0aW9uKHRoaXMuY29uZmlnLnRyYW5zaXRpb24sIHRoaXMuY29uZmlnLnRyYW5zaXRpb25EdXJhdGlvbiwgVHJhbnNpdGlvbkRpcmVjdGlvbi5JbiwgKCkgPT4ge1xyXG4gICAgICAgICAgLy8gRm9jdXMgYW55IGVsZW1lbnQgd2l0aCBbYXV0b2ZvY3VzXSBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICBjb25zdCBhdXRvRm9jdXMgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdbYXV0b2ZvY3VzXScpIGFzIEhUTUxFbGVtZW50IHwgbnVsbDtcclxuICAgICAgICAgIGlmIChhdXRvRm9jdXMpIHtcclxuICAgICAgICAgICAgLy8gQXV0b2ZvY3VzIGFmdGVyIHRoZSBicm93c2VyIGhhcyBoYWQgdGltZSB0byBwcm9jZXNzIG90aGVyIGV2ZW50IGhhbmRsZXJzLlxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGF1dG9Gb2N1cy5mb2N1cygpLCAxMCk7XHJcbiAgICAgICAgICAgIC8vIFRyeSB0byBmb2N1cyBhZ2FpbiB3aGVuIHRoZSBtb2RhbCBoYXMgb3BlbmVkIHNvIHRoYXQgYXV0b2ZvY3VzIHdvcmtzIGluIElFMTEuXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gYXV0b0ZvY3VzLmZvY3VzKCksIHRoaXMuY29uZmlnLnRyYW5zaXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgLy8gRmluYWxseSwgc2V0IHRoZSBwb3B1cCB0byBiZSBvcGVuLlxyXG4gICAgICB0aGlzLl9pc09wZW4gPSB0cnVlO1xyXG4gICAgICB0aGlzLm9uT3Blbi5lbWl0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdG9nZ2xlKCk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLmlzT3Blbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5vcGVuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuY2xvc2UoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBjbG9zZSgpOiB2b2lkIHtcclxuICAgIC8vIE9ubHkgYXR0ZW1wdCB0byBjbG9zZSBpZiBjdXJyZW50bHkgb3Blbi5cclxuICAgIGlmICh0aGlzLmlzT3Blbikge1xyXG4gICAgICAvLyBDYW5jZWwgYWxsIG90aGVyIHRyYW5zaXRpb25zLCBhbmQgaW5pdGlhdGUgdGhlIGNsb3NpbmcgdHJhbnNpdGlvbi5cclxuICAgICAgdGhpcy50cmFuc2l0aW9uQ29udHJvbGxlci5zdG9wQWxsKCk7XHJcbiAgICAgIHRoaXMudHJhbnNpdGlvbkNvbnRyb2xsZXIuYW5pbWF0ZShcclxuICAgICAgICBuZXcgVHJhbnNpdGlvbih0aGlzLmNvbmZpZy50cmFuc2l0aW9uLCB0aGlzLmNvbmZpZy50cmFuc2l0aW9uRHVyYXRpb24sIFRyYW5zaXRpb25EaXJlY3Rpb24uT3V0KSk7XHJcblxyXG4gICAgICAvLyBDYW5jZWwgdGhlIGNsb3NpbmcgdGltZXIuXHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb3NpbmdUaW1lb3V0KTtcclxuICAgICAgLy8gU3RhcnQgdGhlIGNsb3NpbmcgdGltZXIsIHRoYXQgZmlyZXMgdGhlIGBvbkNsb3NlYCBldmVudCBhZnRlciB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxyXG4gICAgICB0aGlzLmNsb3NpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5vbkNsb3NlLmVtaXQoKSwgdGhpcy5jb25maWcudHJhbnNpdGlvbkR1cmF0aW9uKTtcclxuXHJcbiAgICAgIC8vIEZpbmFsbHksIHNldCB0aGUgcG9wdXAgdG8gYmUgY2xvc2VkLlxyXG4gICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSlcclxuICBwdWJsaWMgb25DbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgLy8gTWFrZXMgc2Vuc2UgaGVyZSwgYXMgdGhlIHBvcHVwIHNob3VsZG4ndCBiZSBhdHRhY2hlZCB0byBhbnkgRE9NIGVsZW1lbnQuXHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICB9XHJcbn1cclxuIl19