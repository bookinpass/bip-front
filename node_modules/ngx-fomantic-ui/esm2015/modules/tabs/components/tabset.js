/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChildren, QueryList } from '@angular/core';
import { FuiTabHeader } from '../directives/tab-header';
import { FuiTabContent } from '../directives/tab-content';
import { Tab } from '../classes/tab';
export class FuiTabset {
    constructor() {
        this.tabs = [];
        this._barrierCount = 0;
    }
    // When setting a tab as the currently active tab, it automatically gains
    /**
     * @return {?}
     */
    get activeTab() {
        return this._activeTab;
    }
    // `isActive` status (saves littering `isActive = true` everywhere).
    /**
     * @param {?} tab
     * @return {?}
     */
    set activeTab(tab) {
        this._activeTab = tab;
        tab.isActive = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Fire `internalComponentsUpdated` when the query lists change.
        this._tabHeaders.changes.subscribe((/**
         * @return {?}
         */
        () => this.internalComponentsUpdated()));
        this._tabContents.changes.subscribe((/**
         * @return {?}
         */
        () => this.internalComponentsUpdated()));
        // Initially load the tabs.
        this.loadTabs();
    }
    // Activate the first tab in the set.
    /**
     * @return {?}
     */
    activateFirstTab() {
        this.activeTab = this.tabs[0];
    }
    // Activates the closest available tab to a given one.
    /**
     * @param {?} tab
     * @return {?}
     */
    activateClosestTab(tab) {
        /** @type {?} */
        let nextAvailable;
        // When the exited tab's index is higher than all available tabs,
        if (tab.index >= this.tabs.length) {
            // Activate the last tab.
            nextAvailable = this.tabs[this.tabs.length - 1];
        }
        // If that didn't work, try the following cases:
        if (!nextAvailable) {
            if (!this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            t => t === tab))) { // When the exited tab no longer exists,
                // Replace it with a tab at the same index.
                nextAvailable = this.tabs[tab.index];
            }
            else { // Or if the exited tab still exists,
                // Go to the tab immediately to the left.
                nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];
            }
        }
        // However, if the chosen tab is disabled,
        if (nextAvailable.isDisabled) {
            // Activate the closest available tab to it.
            return this.activateClosestTab(nextAvailable);
        }
        this.activeTab = nextAvailable;
    }
    // Fires whenever either the tab headers or tab contents query lists update.
    /**
     * @private
     * @return {?}
     */
    internalComponentsUpdated() {
        // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.
        // This is so that both the headers and contents query lists can update before we run code that matches the two up.
        this._barrierCount++;
        if (this._barrierCount === 2) {
            // Reset the barrier so it can be called again.
            this._barrierCount = 0;
            // Update the tabs.
            this.loadTabs();
        }
    }
    // Connects tab headers to tab contents, and creates a tab instance for each pairing.
    /**
     * @private
     * @return {?}
     */
    loadTabs() {
        // Remove any tabs that no longer have an associated header.
        this.tabs = this.tabs.filter((/**
         * @param {?} t
         * @return {?}
         */
        t => !!this._tabHeaders.find((/**
         * @param {?} tH
         * @return {?}
         */
        tH => tH === t.header))));
        this._tabHeaders
            // Filter out the loaded headers with attached tab instances.
            .filter((/**
         * @param {?} tH
         * @return {?}
         */
        tH => !this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        t => t.header === tH))))
            .forEach((/**
         * @param {?} tH
         * @return {?}
         */
        tH => {
            /** @type {?} */
            const content = this._tabContents.find((/**
             * @param {?} tC
             * @return {?}
             */
            tC => tC.id === tH.id));
            if (!content) {
                // Error if an associated tab content cannot be found for the given header.
                throw new Error('A [fuiTabHeader] must have a related [fuiTabContent].');
            }
            // Create a new tab instance for this header & content combo.
            /** @type {?} */
            const tab = new Tab(tH, content);
            // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.
            tab.header.isActiveExternalChange.subscribe((/**
             * @return {?}
             */
            () => this.onHeaderActiveChanged(tab)));
            // Add the new instance to the list of tabs.
            this.tabs.push(tab);
        }));
        // Assign each tab an index (which denotes the order they physically appear in).
        this._tabHeaders
            .forEach((/**
         * @param {?} tH
         * @param {?} i
         * @return {?}
         */
        (tH, i) => {
            /** @type {?} */
            const tab = this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            t => t.header === tH));
            if (tab) {
                tab.index = i;
            }
        }));
        // Sort the tabs by their index.
        this.tabs.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => a.index - b.index));
        if (!this.activeTab) { // Check if there are no current existing active tabs.
            // If so, we must activate the first available tab.
            this.activateFirstTab();
        }
        else if (!this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        t => t === this.activeTab))) { // O'wise check if current active tab has been deleted.
            // If so, we must find the closest.
            // Use `setTimeout` as this causes a 'changed after checked' error o'wise.
            setTimeout((/**
             * @return {?}
             */
            () => this.activateClosestTab(this.activeTab)));
        }
        if (this.tabs.length === 0) {
            // Error if there aren't any tabs in the tabset.
            throw new Error('You cannot have no tabs!');
        }
    }
    // Fires whenever a tab header's active state is externally changed.
    /**
     * @private
     * @param {?} tab
     * @return {?}
     */
    onHeaderActiveChanged(tab) {
        // If the tab has become activated, but was not previously the active tab:
        if (tab.isActive && this.activeTab !== tab) {
            // Deactivate all of the tabs.
            this.tabs.filter((/**
             * @param {?} t
             * @return {?}
             */
            t => t !== tab)).forEach((/**
             * @param {?} t
             * @return {?}
             */
            t => t.isActive = false));
            // Set the currently active tab to this one.
            this.activeTab = tab;
        }
        // If the tab has become deactivated, but was previously the active tab:
        if (!tab.isActive && this.activeTab === tab) {
            // Activate the closest tab to it.
            this.activateClosestTab(tab);
        }
    }
}
FuiTabset.decorators = [
    { type: Component, args: [{
                selector: 'fui-tabset',
                template: `<ng-content></ng-content>`
            }] }
];
/** @nocollapse */
FuiTabset.ctorParameters = () => [];
FuiTabset.propDecorators = {
    _tabHeaders: [{ type: ContentChildren, args: [FuiTabHeader,] }],
    _tabContents: [{ type: ContentChildren, args: [FuiTabContent,] }]
};
if (false) {
    /** @type {?} */
    FuiTabset.prototype.tabs;
    /**
     * @type {?}
     * @private
     */
    FuiTabset.prototype._tabHeaders;
    /**
     * @type {?}
     * @private
     */
    FuiTabset.prototype._tabContents;
    /**
     * @type {?}
     * @private
     */
    FuiTabset.prototype._barrierCount;
    /**
     * @type {?}
     * @private
     */
    FuiTabset.prototype._activeTab;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFic2V0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWZvbWFudGljLXVpLyIsInNvdXJjZXMiOlsibW9kdWxlcy90YWJzL2NvbXBvbmVudHMvdGFic2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQW1CLFNBQVMsRUFBRSxlQUFlLEVBQUUsU0FBUyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3RGLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDeEQsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBTW5DLE1BQU0sT0FBTyxTQUFTO0lBV3BCO1FBQ0UsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7UUFDZixJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztJQUN6QixDQUFDOzs7OztJQU9ELElBQVcsU0FBUztRQUNsQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQzs7Ozs7O0lBR0QsSUFBVyxTQUFTLENBQUMsR0FBUTtRQUMzQixJQUFJLENBQUMsVUFBVSxHQUFHLEdBQUcsQ0FBQztRQUN0QixHQUFHLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztJQUN0QixDQUFDOzs7O0lBRU0sa0JBQWtCO1FBQ3ZCLGdFQUFnRTtRQUNoRSxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxTQUFTOzs7UUFBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMseUJBQXlCLEVBQUUsRUFBQyxDQUFDO1FBQzNFLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFNBQVM7OztRQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxFQUFDLENBQUM7UUFFNUUsMkJBQTJCO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNsQixDQUFDOzs7OztJQUdNLGdC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QWdEO1lBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztTQUM3QztJQUNILENBQUM7Ozs7Ozs7SUFHTyxxQkFBcUIsQ0FBQyxHQUFRO1FBQ3BDLDBFQUEwRTtRQUMxRSxJQUFJLEdBQUcsQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxHQUFHLEVBQUU7WUFDMUMsOEJBQThCO1lBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTTs7OztZQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBQyxDQUFDLE9BQU87Ozs7WUFBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsS0FBSyxFQUFDLENBQUM7WUFFbEUsNENBQTRDO1lBQzVDLElBQUksQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDO1NBQ3RCO1FBRUQsd0VBQXdFO1FBQ3hFLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssR0FBRyxFQUFFO1lBQzNDLGtDQUFrQztZQUNsQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDOUI7SUFDSCxDQUFDOzs7WUFwS0YsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxZQUFZO2dCQUN0QixRQUFRLEVBQUUsMkJBQTJCO2FBQ3RDOzs7OzswQkFLRSxlQUFlLFNBQUMsWUFBWTsyQkFFNUIsZUFBZSxTQUFDLGFBQWE7Ozs7SUFIOUIseUJBQW1COzs7OztJQUNuQixnQ0FDNkM7Ozs7O0lBQzdDLGlDQUMrQzs7Ozs7SUFFL0Msa0NBQThCOzs7OztJQVE5QiwrQkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0FmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBRdWVyeUxpc3R9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0Z1aVRhYkhlYWRlcn0gZnJvbSAnLi4vZGlyZWN0aXZlcy90YWItaGVhZGVyJztcclxuaW1wb3J0IHtGdWlUYWJDb250ZW50fSBmcm9tICcuLi9kaXJlY3RpdmVzL3RhYi1jb250ZW50JztcclxuaW1wb3J0IHtUYWJ9IGZyb20gJy4uL2NsYXNzZXMvdGFiJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnZnVpLXRhYnNldCcsXHJcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRnVpVGFic2V0IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gIC8vIExpc3Qgb2YgYWxsIHRhYnMgaW4gdGhlIHRhYnNldC5cclxuICBwdWJsaWMgdGFiczogVGFiW107XHJcbiAgQENvbnRlbnRDaGlsZHJlbihGdWlUYWJIZWFkZXIpXHJcbiAgcHJpdmF0ZSBfdGFiSGVhZGVyczogUXVlcnlMaXN0PEZ1aVRhYkhlYWRlcj47XHJcbiAgQENvbnRlbnRDaGlsZHJlbihGdWlUYWJDb250ZW50KVxyXG4gIHByaXZhdGUgX3RhYkNvbnRlbnRzOiBRdWVyeUxpc3Q8RnVpVGFiQ29udGVudD47XHJcbiAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIG51bWJlciBvZiB0aW1lcyBgaW50ZXJuYWxDb21wb25lbnRzVXBkYXRlZGAgaXMgY2FsbGVkLlxyXG4gIHByaXZhdGUgX2JhcnJpZXJDb3VudDogbnVtYmVyO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMudGFicyA9IFtdO1xyXG4gICAgdGhpcy5fYmFycmllckNvdW50ID0gMDtcclxuICB9XHJcblxyXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYi5cclxuICBwcml2YXRlIF9hY3RpdmVUYWI6IFRhYjtcclxuXHJcbiAgLy8gV2hlbiBzZXR0aW5nIGEgdGFiIGFzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYiwgaXQgYXV0b21hdGljYWxseSBnYWluc1xyXG5cclxuICBwdWJsaWMgZ2V0IGFjdGl2ZVRhYigpOiBUYWIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRhYjtcclxuICB9XHJcblxyXG4gIC8vIGBpc0FjdGl2ZWAgc3RhdHVzIChzYXZlcyBsaXR0ZXJpbmcgYGlzQWN0aXZlID0gdHJ1ZWAgZXZlcnl3aGVyZSkuXHJcbiAgcHVibGljIHNldCBhY3RpdmVUYWIodGFiOiBUYWIpIHtcclxuICAgIHRoaXMuX2FjdGl2ZVRhYiA9IHRhYjtcclxuICAgIHRhYi5pc0FjdGl2ZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xyXG4gICAgLy8gRmlyZSBgaW50ZXJuYWxDb21wb25lbnRzVXBkYXRlZGAgd2hlbiB0aGUgcXVlcnkgbGlzdHMgY2hhbmdlLlxyXG4gICAgdGhpcy5fdGFiSGVhZGVycy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLmludGVybmFsQ29tcG9uZW50c1VwZGF0ZWQoKSk7XHJcbiAgICB0aGlzLl90YWJDb250ZW50cy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLmludGVybmFsQ29tcG9uZW50c1VwZGF0ZWQoKSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGx5IGxvYWQgdGhlIHRhYnMuXHJcbiAgICB0aGlzLmxvYWRUYWJzKCk7XHJcbiAgfVxyXG5cclxuICAvLyBBY3RpdmF0ZSB0aGUgZmlyc3QgdGFiIGluIHRoZSBzZXQuXHJcbiAgcHVibGljIGFjdGl2YXRlRmlyc3RUYWIoKTogdm9pZCB7XHJcbiAgICB0aGlzLmFjdGl2ZVRhYiA9IHRoaXMudGFic1swXTtcclxuICB9XHJcblxyXG4gIC8vIEFjdGl2YXRlcyB0aGUgY2xvc2VzdCBhdmFpbGFibGUgdGFiIHRvIGEgZ2l2ZW4gb25lLlxyXG4gIHB1YmxpYyBhY3RpdmF0ZUNsb3Nlc3RUYWIodGFiOiBUYWIpOiB2b2lkIHtcclxuICAgIGxldCBuZXh0QXZhaWxhYmxlOiBUYWIgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gV2hlbiB0aGUgZXhpdGVkIHRhYidzIGluZGV4IGlzIGhpZ2hlciB0aGFuIGFsbCBhdmFpbGFibGUgdGFicyxcclxuICAgIGlmICh0YWIuaW5kZXggPj0gdGhpcy50YWJzLmxlbmd0aCkge1xyXG4gICAgICAvLyBBY3RpdmF0ZSB0aGUgbGFzdCB0YWIuXHJcbiAgICAgIG5leHRBdmFpbGFibGUgPSB0aGlzLnRhYnNbdGhpcy50YWJzLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoYXQgZGlkbid0IHdvcmssIHRyeSB0aGUgZm9sbG93aW5nIGNhc2VzOlxyXG4gICAgaWYgKCFuZXh0QXZhaWxhYmxlKSB7XHJcbiAgICAgIGlmICghdGhpcy50YWJzLmZpbmQodCA9PiB0ID09PSB0YWIpKSB7IC8vIFdoZW4gdGhlIGV4aXRlZCB0YWIgbm8gbG9uZ2VyIGV4aXN0cyxcclxuICAgICAgICAvLyBSZXBsYWNlIGl0IHdpdGggYSB0YWIgYXQgdGhlIHNhbWUgaW5kZXguXHJcbiAgICAgICAgbmV4dEF2YWlsYWJsZSA9IHRoaXMudGFic1t0YWIuaW5kZXhdO1xyXG4gICAgICB9IGVsc2UgeyAvLyBPciBpZiB0aGUgZXhpdGVkIHRhYiBzdGlsbCBleGlzdHMsXHJcbiAgICAgICAgLy8gR28gdG8gdGhlIHRhYiBpbW1lZGlhdGVseSB0byB0aGUgbGVmdC5cclxuICAgICAgICBuZXh0QXZhaWxhYmxlID0gdGhpcy50YWJzW01hdGgubWF4KHRhYi5pbmRleCAtIDEsIDApXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBjaG9zZW4gdGFiIGlzIGRpc2FibGVkLFxyXG4gICAgaWYgKG5leHRBdmFpbGFibGUuaXNEaXNhYmxlZCkge1xyXG4gICAgICAvLyBBY3RpdmF0ZSB0aGUgY2xvc2VzdCBhdmFpbGFibGUgdGFiIHRvIGl0LlxyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZUNsb3Nlc3RUYWIobmV4dEF2YWlsYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hY3RpdmVUYWIgPSBuZXh0QXZhaWxhYmxlO1xyXG4gIH1cclxuXHJcbiAgLy8gRmlyZXMgd2hlbmV2ZXIgZWl0aGVyIHRoZSB0YWIgaGVhZGVycyBvciB0YWIgY29udGVudHMgcXVlcnkgbGlzdHMgdXBkYXRlLlxyXG4gIHByaXZhdGUgaW50ZXJuYWxDb21wb25lbnRzVXBkYXRlZCgpOiB2b2lkIHtcclxuICAgIC8vIFdlIGFyZSB1c2luZyBhICdjb3VudGluZyBiYXJyaWVyIG9mIG4gPSAyJywgaS5lLiB0aGUgY29kZSB3aXRoaW4gb25seSBydW5zIGFmdGVyIHRoZSBtZXRob2QgaXMgY2FsbGVkIHR3aWNlLlxyXG4gICAgLy8gVGhpcyBpcyBzbyB0aGF0IGJvdGggdGhlIGhlYWRlcnMgYW5kIGNvbnRlbnRzIHF1ZXJ5IGxpc3RzIGNhbiB1cGRhdGUgYmVmb3JlIHdlIHJ1biBjb2RlIHRoYXQgbWF0Y2hlcyB0aGUgdHdvIHVwLlxyXG4gICAgdGhpcy5fYmFycmllckNvdW50Kys7XHJcblxyXG4gICAgaWYgKHRoaXMuX2JhcnJpZXJDb3VudCA9PT0gMikge1xyXG4gICAgICAvLyBSZXNldCB0aGUgYmFycmllciBzbyBpdCBjYW4gYmUgY2FsbGVkIGFnYWluLlxyXG4gICAgICB0aGlzLl9iYXJyaWVyQ291bnQgPSAwO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSB0YWJzLlxyXG4gICAgICB0aGlzLmxvYWRUYWJzKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDb25uZWN0cyB0YWIgaGVhZGVycyB0byB0YWIgY29udGVudHMsIGFuZCBjcmVhdGVzIGEgdGFiIGluc3RhbmNlIGZvciBlYWNoIHBhaXJpbmcuXHJcbiAgcHJpdmF0ZSBsb2FkVGFicygpOiB2b2lkIHtcclxuICAgIC8vIFJlbW92ZSBhbnkgdGFicyB0aGF0IG5vIGxvbmdlciBoYXZlIGFuIGFzc29jaWF0ZWQgaGVhZGVyLlxyXG4gICAgdGhpcy50YWJzID0gdGhpcy50YWJzLmZpbHRlcih0ID0+ICEhdGhpcy5fdGFiSGVhZGVycy5maW5kKHRIID0+IHRIID09PSB0LmhlYWRlcikpO1xyXG5cclxuICAgIHRoaXMuX3RhYkhlYWRlcnNcclxuICAgIC8vIEZpbHRlciBvdXQgdGhlIGxvYWRlZCBoZWFkZXJzIHdpdGggYXR0YWNoZWQgdGFiIGluc3RhbmNlcy5cclxuICAgICAgLmZpbHRlcih0SCA9PiAhdGhpcy50YWJzLmZpbmQodCA9PiB0LmhlYWRlciA9PT0gdEgpKVxyXG4gICAgICAuZm9yRWFjaCh0SCA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuX3RhYkNvbnRlbnRzLmZpbmQodEMgPT4gdEMuaWQgPT09IHRILmlkKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb250ZW50KSB7XHJcbiAgICAgICAgICAvLyBFcnJvciBpZiBhbiBhc3NvY2lhdGVkIHRhYiBjb250ZW50IGNhbm5vdCBiZSBmb3VuZCBmb3IgdGhlIGdpdmVuIGhlYWRlci5cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBbZnVpVGFiSGVhZGVyXSBtdXN0IGhhdmUgYSByZWxhdGVkIFtmdWlUYWJDb250ZW50XS4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0YWIgaW5zdGFuY2UgZm9yIHRoaXMgaGVhZGVyICYgY29udGVudCBjb21iby5cclxuICAgICAgICBjb25zdCB0YWIgPSBuZXcgVGFiKHRILCBjb250ZW50KTtcclxuXHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGFueSBleHRlcm5hbCBjaGFuZ2VzIGluIHRoZSB0YWIgaGVhZGVyJ3MgYWN0aXZlIHN0YXRlLiBFeHRlcm5hbCBjaGFuZ2VzIGFyZSB0cmlnZ2VyZWQgYnkgdXNlciBpbnB1dC5cclxuICAgICAgICB0YWIuaGVhZGVyLmlzQWN0aXZlRXh0ZXJuYWxDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHRoaXMub25IZWFkZXJBY3RpdmVDaGFuZ2VkKHRhYikpO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG5ldyBpbnN0YW5jZSB0byB0aGUgbGlzdCBvZiB0YWJzLlxyXG4gICAgICAgIHRoaXMudGFicy5wdXNoKHRhYik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2lnbiBlYWNoIHRhYiBhbiBpbmRleCAod2hpY2ggZGVub3RlcyB0aGUgb3JkZXIgdGhleSBwaHlzaWNhbGx5IGFwcGVhciBpbikuXHJcbiAgICB0aGlzLl90YWJIZWFkZXJzXHJcbiAgICAgIC5mb3JFYWNoKCh0SCwgaSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhYiA9IHRoaXMudGFicy5maW5kKHQgPT4gdC5oZWFkZXIgPT09IHRIKTtcclxuICAgICAgICBpZiAodGFiKSB7XHJcbiAgICAgICAgICB0YWIuaW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gU29ydCB0aGUgdGFicyBieSB0aGVpciBpbmRleC5cclxuICAgIHRoaXMudGFicy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XHJcblxyXG5cclxuICAgIGlmICghdGhpcy5hY3RpdmVUYWIpIHsgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIG5vIGN1cnJlbnQgZXhpc3RpbmcgYWN0aXZlIHRhYnMuXHJcbiAgICAgIC8vIElmIHNvLCB3ZSBtdXN0IGFjdGl2YXRlIHRoZSBmaXJzdCBhdmFpbGFibGUgdGFiLlxyXG4gICAgICB0aGlzLmFjdGl2YXRlRmlyc3RUYWIoKTtcclxuICAgIH0gZWxzZSBpZiAoIXRoaXMudGFicy5maW5kKHQgPT4gdCA9PT0gdGhpcy5hY3RpdmVUYWIpKSB7IC8vIE8nd2lzZSBjaGVjayBpZiBjdXJyZW50IGFjdGl2ZSB0YWIgaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICAgLy8gSWYgc28sIHdlIG11c3QgZmluZCB0aGUgY2xvc2VzdC5cclxuICAgICAgLy8gVXNlIGBzZXRUaW1lb3V0YCBhcyB0aGlzIGNhdXNlcyBhICdjaGFuZ2VkIGFmdGVyIGNoZWNrZWQnIGVycm9yIG8nd2lzZS5cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRlQ2xvc2VzdFRhYih0aGlzLmFjdGl2ZVRhYikpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnRhYnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIC8vIEVycm9yIGlmIHRoZXJlIGFyZW4ndCBhbnkgdGFicyBpbiB0aGUgdGFic2V0LlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSBubyB0YWJzIScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmlyZXMgd2hlbmV2ZXIgYSB0YWIgaGVhZGVyJ3MgYWN0aXZlIHN0YXRlIGlzIGV4dGVybmFsbHkgY2hhbmdlZC5cclxuICBwcml2YXRlIG9uSGVhZGVyQWN0aXZlQ2hhbmdlZCh0YWI6IFRhYik6IHZvaWQge1xyXG4gICAgLy8gSWYgdGhlIHRhYiBoYXMgYmVjb21lIGFjdGl2YXRlZCwgYnV0IHdhcyBub3QgcHJldmlvdXNseSB0aGUgYWN0aXZlIHRhYjpcclxuICAgIGlmICh0YWIuaXNBY3RpdmUgJiYgdGhpcy5hY3RpdmVUYWIgIT09IHRhYikge1xyXG4gICAgICAvLyBEZWFjdGl2YXRlIGFsbCBvZiB0aGUgdGFicy5cclxuICAgICAgdGhpcy50YWJzLmZpbHRlcih0ID0+IHQgIT09IHRhYikuZm9yRWFjaCh0ID0+IHQuaXNBY3RpdmUgPSBmYWxzZSk7XHJcblxyXG4gICAgICAvLyBTZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiIHRvIHRoaXMgb25lLlxyXG4gICAgICB0aGlzLmFjdGl2ZVRhYiA9IHRhYjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgdGFiIGhhcyBiZWNvbWUgZGVhY3RpdmF0ZWQsIGJ1dCB3YXMgcHJldmlvdXNseSB0aGUgYWN0aXZlIHRhYjpcclxuICAgIGlmICghdGFiLmlzQWN0aXZlICYmIHRoaXMuYWN0aXZlVGFiID09PSB0YWIpIHtcclxuICAgICAgLy8gQWN0aXZhdGUgdGhlIGNsb3Nlc3QgdGFiIHRvIGl0LlxyXG4gICAgICB0aGlzLmFjdGl2YXRlQ2xvc2VzdFRhYih0YWIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=