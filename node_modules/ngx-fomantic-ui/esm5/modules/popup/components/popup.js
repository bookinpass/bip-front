/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, HostBinding, HostListener, ViewChild, ViewContainerRef } from '@angular/core';
import { PositioningService } from '../../../misc/util/internal';
import { Transition, TransitionController, TransitionDirection } from '../../transition/internal';
var FuiPopup = /** @class */ (function () {
    function FuiPopup(elementRef) {
        this.elementRef = elementRef;
        this.transitionController = new TransitionController(false);
        this._isOpen = false;
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this.tabindex = 0;
    }
    Object.defineProperty(FuiPopup.prototype, "direction", {
        // Returns the direction (`top`, `left`, `right`, `bottom`) of the current placement.
        get: 
        // Returns the direction (`top`, `left`, `right`, `bottom`) of the current placement.
        /**
         * @return {?}
         */
        function () {
            // We need to set direction attribute before popper init to allow correct positioning
            return this.config.placement.split(' ').shift();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopup.prototype, "alignment", {
        // Returns the alignment (`top`, `left`, `right`, `bottom`) of the current placement.
        get: 
        // Returns the alignment (`top`, `left`, `right`, `bottom`) of the current placement.
        /**
         * @return {?}
         */
        function () {
            return this.config.placement.split(' ').pop();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopup.prototype, "dynamicClasses", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var classes = {};
            if (this.direction) {
                classes[this.direction] = true;
            }
            if (this.alignment) {
                classes[this.alignment] = true;
            }
            if (this.config.isInverted) {
                classes.inverted = true;
            }
            if (this.config.isBasic) {
                classes.basic = true;
            }
            if (this.config.isFlowing) {
                classes.flowing = true;
            }
            if (this.config.size) {
                classes[this.config.size] = true;
            }
            if (this.config.width) {
                classes[this.config.width] = true;
            }
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopup.prototype, "anchor", {
        set: /**
         * @param {?} anchor
         * @return {?}
         */
        function (anchor) {
            this._anchor = anchor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiPopup.prototype, "isOpen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isOpen;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiPopup.prototype.open = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Only attempt to open if currently closed.
        if (!this.isOpen) {
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Create positioning service after a brief delay.
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this.positioningService = new PositioningService(_this._anchor, _this._container.element, _this.config.placement, '.dynamic.arrow');
                _this.positioningService.hasArrow = !_this.config.isBasic;
            }));
            // Cancel all other transitions, and initiate the opening transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.In, (/**
             * @return {?}
             */
            function () {
                // Focus any element with [autofocus] attribute.
                /** @type {?} */
                var autoFocus = (/** @type {?} */ (_this.elementRef.nativeElement.querySelector('[autofocus]')));
                if (autoFocus) {
                    // Autofocus after the browser has had time to process other event handlers.
                    setTimeout((/**
                     * @return {?}
                     */
                    function () { return autoFocus.focus(); }), 10);
                    // Try to focus again when the modal has opened so that autofocus works in IE11.
                    setTimeout((/**
                     * @return {?}
                     */
                    function () { return autoFocus.focus(); }), _this.config.transitionDuration);
                }
            })));
            // Finally, set the popup to be open.
            this._isOpen = true;
            this.onOpen.emit();
        }
    };
    /**
     * @return {?}
     */
    FuiPopup.prototype.toggle = /**
     * @return {?}
     */
    function () {
        if (!this.isOpen) {
            return this.open();
        }
        return this.close();
    };
    /**
     * @return {?}
     */
    FuiPopup.prototype.close = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Only attempt to close if currently open.
        if (this.isOpen) {
            // Cancel all other transitions, and initiate the closing transition.
            this.transitionController.stopAll();
            this.transitionController.animate(new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.Out));
            // Cancel the closing timer.
            clearTimeout(this.closingTimeout);
            // Start the closing timer, that fires the `onClose` event after the transition duration number of milliseconds.
            this.closingTimeout = window.setTimeout((/**
             * @return {?}
             */
            function () { return _this.onClose.emit(); }), this.config.transitionDuration);
            // Finally, set the popup to be closed.
            this._isOpen = false;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    FuiPopup.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Makes sense here, as the popup shouldn't be attached to any DOM element.
        event.stopPropagation();
    };
    FuiPopup.decorators = [
        { type: Component, args: [{
                    selector: 'fui-popup',
                    template: "\n<div class=\"ui popup\"\n     [ngClass]=\"dynamicClasses\"\n     [fuiTransition]=\"transitionController\"\n     [attr.direction]=\"direction\"\n     #container>\n\n    <ng-container *ngIf=\"!config.template && (!!config.header || !!config.text)\">\n        <div class=\"header\" *ngIf=\"config.header\">{{ config.header }}</div>\n        <div class=\"content\">{{ config.text }}</div>\n    </ng-container>\n    <div #templateSibling></div>\n\n    <fui-popup-arrow *ngIf=\"!config.isBasic\"\n                     [placement]=\"config.placement\"\n                     [inverted]=\"config.isInverted\"></fui-popup-arrow>\n</div>\n",
                    styles: ["\n.ui.popup {\n    /* Autofit popup to the contents. */\n    right: auto;\n    margin: 0;\n}\n\n.ui.animating.popup {\n    /* When the popup is animating, it may not initially be in the correct position.\n       This fires a mouse event, causing the anchor's mouseleave to fire - making the popup flicker.\n       Setting pointer-events to none while animating fixes this bug. */\n    pointer-events: none;\n}\n\n.ui.popup::before {\n    /* Hide the Fomantic UI CSS arrow. */\n    display: none;\n}\n\n/* Offset popup by 0.75em above and below when placed 'vertically'. */\n.ui.popup[direction=\"top\"],\n.ui.popup[direction=\"bottom\"] {\n    margin-top: 0.75em;\n    margin-bottom: 0.75em;\n}\n\n/* Offset popup by 0.75em either side when placed 'horizontally'. */\n.ui.popup[direction=\"left\"],\n.ui.popup[direction=\"right\"] {\n    margin-left: 0.75em;\n    margin-right: 0.75em;\n}\n"]
                }] }
    ];
    /** @nocollapse */
    FuiPopup.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    FuiPopup.propDecorators = {
        templateSibling: [{ type: ViewChild, args: ['templateSibling', { read: ViewContainerRef, static: true },] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        _container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: false },] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return FuiPopup;
}());
export { FuiPopup };
if (false) {
    /** @type {?} */
    FuiPopup.prototype.config;
    /** @type {?} */
    FuiPopup.prototype.transitionController;
    /** @type {?} */
    FuiPopup.prototype.positioningService;
    /** @type {?} */
    FuiPopup.prototype.closingTimeout;
    /** @type {?} */
    FuiPopup.prototype.onOpen;
    /** @type {?} */
    FuiPopup.prototype.onClose;
    /** @type {?} */
    FuiPopup.prototype.templateSibling;
    /** @type {?} */
    FuiPopup.prototype.tabindex;
    /**
     * @type {?}
     * @private
     */
    FuiPopup.prototype._container;
    /**
     * @type {?}
     * @private
     */
    FuiPopup.prototype._anchor;
    /**
     * @type {?}
     * @private
     */
    FuiPopup.prototype._isOpen;
    /** @type {?} */
    FuiPopup.prototype.elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wdXAuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtZm9tYW50aWMtdWkvIiwic291cmNlcyI6WyJtb2R1bGVzL3BvcHVwL2NvbXBvbmVudHMvcG9wdXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUMxSCxPQUFPLEVBQWtCLGtCQUFrQixFQUFDLE1BQU0sNkJBQTZCLENBQUM7QUFDaEYsT0FBTyxFQUFDLFVBQVUsRUFBRSxvQkFBb0IsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBSWhHO0lBMkVFLGtCQUFtQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3ZDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTVELElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBRXJCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztRQUN2QyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7UUFFeEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUdELHNCQUFXLCtCQUFTO1FBRHBCLHFGQUFxRjs7Ozs7O1FBQ3JGO1lBQ0UscUZBQXFGO1lBQ3JGLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2xELENBQUM7OztPQUFBO0lBR0Qsc0JBQVcsK0JBQVM7UUFEcEIscUZBQXFGOzs7Ozs7UUFDckY7WUFDRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FB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O0lBRGQsVUFDZSxLQUFpQjtRQUM5QiwyRUFBMkU7UUFDM0UsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQzFCLENBQUM7O2dCQTNNRixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLFdBQVc7b0JBQ3JCLFFBQVEsRUFBRSx3bkJBaUJYOzZCQUNVLDQzQkFnQ1Y7aUJBQ0E7Ozs7Z0JBM0RrQixVQUFVOzs7a0NBeUUxQixTQUFTLFNBQUMsaUJBQWlCLEVBQUUsRUFBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBQzsyQkFFbkUsV0FBVyxTQUFDLGVBQWU7NkJBRzNCLFNBQVMsU0FBQyxXQUFXLEVBQUUsRUFBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBQzswQkErSDlELFlBQVksU0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUM7O0lBS25DLGVBQUM7Q0FBQSxBQTVNRCxJQTRNQztTQXRKWSxRQUFROzs7SUFHbkIsMEJBQXdDOztJQUN4Qyx3Q0FBa0Q7O0lBQ2xELHNDQUE4Qzs7SUFFOUMsa0NBQThCOztJQUU5QiwwQkFBa0M7O0lBRWxDLDJCQUFtQzs7SUFFbkMsbUNBQ3lDOztJQUN6Qyw0QkFDaUM7Ozs7O0lBRWpDLDhCQUNxQzs7Ozs7SUFrRHJDLDJCQUE0Qjs7Ozs7SUFPNUIsMkJBQXlCOztJQXZEYiw4QkFBNkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBWaWV3Q2hpbGQsIFZpZXdDb250YWluZXJSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0lEeW5hbWljQ2xhc3NlcywgUG9zaXRpb25pbmdTZXJ2aWNlfSBmcm9tICcuLi8uLi8uLi9taXNjL3V0aWwvaW50ZXJuYWwnO1xyXG5pbXBvcnQge1RyYW5zaXRpb24sIFRyYW5zaXRpb25Db250cm9sbGVyLCBUcmFuc2l0aW9uRGlyZWN0aW9ufSBmcm9tICcuLi8uLi90cmFuc2l0aW9uL2ludGVybmFsJztcclxuaW1wb3J0IHtJUG9wdXB9IGZyb20gJy4uL2NsYXNzZXMvcG9wdXAtY29udHJvbGxlcic7XHJcbmltcG9ydCB7VGVtcGxhdGVQb3B1cENvbmZpZ30gZnJvbSAnLi4vY2xhc3Nlcy9wb3B1cC10ZW1wbGF0ZS1jb250cm9sbGVyJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnZnVpLXBvcHVwJyxcclxuICB0ZW1wbGF0ZTogYFxyXG48ZGl2IGNsYXNzPVwidWkgcG9wdXBcIlxyXG4gICAgIFtuZ0NsYXNzXT1cImR5bmFtaWNDbGFzc2VzXCJcclxuICAgICBbZnVpVHJhbnNpdGlvbl09XCJ0cmFuc2l0aW9uQ29udHJvbGxlclwiXHJcbiAgICAgW2F0dHIuZGlyZWN0aW9uXT1cImRpcmVjdGlvblwiXHJcbiAgICAgI2NvbnRhaW5lcj5cclxuXHJcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWNvbmZpZy50ZW1wbGF0ZSAmJiAoISFjb25maWcuaGVhZGVyIHx8ICEhY29uZmlnLnRleHQpXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlclwiICpuZ0lmPVwiY29uZmlnLmhlYWRlclwiPnt7IGNvbmZpZy5oZWFkZXIgfX08L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPnt7IGNvbmZpZy50ZXh0IH19PC9kaXY+XHJcbiAgICA8L25nLWNvbnRhaW5lcj5cclxuICAgIDxkaXYgI3RlbXBsYXRlU2libGluZz48L2Rpdj5cclxuXHJcbiAgICA8ZnVpLXBvcHVwLWFycm93ICpuZ0lmPVwiIWNvbmZpZy5pc0Jhc2ljXCJcclxuICAgICAgICAgICAgICAgICAgICAgW3BsYWNlbWVudF09XCJjb25maWcucGxhY2VtZW50XCJcclxuICAgICAgICAgICAgICAgICAgICAgW2ludmVydGVkXT1cImNvbmZpZy5pc0ludmVydGVkXCI+PC9mdWktcG9wdXAtYXJyb3c+XHJcbjwvZGl2PlxyXG5gLFxyXG4gIHN0eWxlczogW2BcclxuLnVpLnBvcHVwIHtcclxuICAgIC8qIEF1dG9maXQgcG9wdXAgdG8gdGhlIGNvbnRlbnRzLiAqL1xyXG4gICAgcmlnaHQ6IGF1dG87XHJcbiAgICBtYXJnaW46IDA7XHJcbn1cclxuXHJcbi51aS5hbmltYXRpbmcucG9wdXAge1xyXG4gICAgLyogV2hlbiB0aGUgcG9wdXAgaXMgYW5pbWF0aW5nLCBpdCBtYXkgbm90IGluaXRpYWxseSBiZSBpbiB0aGUgY29ycmVjdCBwb3NpdGlvbi5cclxuICAgICAgIFRoaXMgZmlyZXMgYSBtb3VzZSBldmVudCwgY2F1c2luZyB0aGUgYW5jaG9yJ3MgbW91c2VsZWF2ZSB0byBmaXJlIC0gbWFraW5nIHRoZSBwb3B1cCBmbGlja2VyLlxyXG4gICAgICAgU2V0dGluZyBwb2ludGVyLWV2ZW50cyB0byBub25lIHdoaWxlIGFuaW1hdGluZyBmaXhlcyB0aGlzIGJ1Zy4gKi9cclxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG59XHJcblxyXG4udWkucG9wdXA6OmJlZm9yZSB7XHJcbiAgICAvKiBIaWRlIHRoZSBGb21hbnRpYyBVSSBDU1MgYXJyb3cuICovXHJcbiAgICBkaXNwbGF5OiBub25lO1xyXG59XHJcblxyXG4vKiBPZmZzZXQgcG9wdXAgYnkgMC43NWVtIGFib3ZlIGFuZCBiZWxvdyB3aGVuIHBsYWNlZCAndmVydGljYWxseScuICovXHJcbi51aS5wb3B1cFtkaXJlY3Rpb249XCJ0b3BcIl0sXHJcbi51aS5wb3B1cFtkaXJlY3Rpb249XCJib3R0b21cIl0ge1xyXG4gICAgbWFyZ2luLXRvcDogMC43NWVtO1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMC43NWVtO1xyXG59XHJcblxyXG4vKiBPZmZzZXQgcG9wdXAgYnkgMC43NWVtIGVpdGhlciBzaWRlIHdoZW4gcGxhY2VkICdob3Jpem9udGFsbHknLiAqL1xyXG4udWkucG9wdXBbZGlyZWN0aW9uPVwibGVmdFwiXSxcclxuLnVpLnBvcHVwW2RpcmVjdGlvbj1cInJpZ2h0XCJdIHtcclxuICAgIG1hcmdpbi1sZWZ0OiAwLjc1ZW07XHJcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNzVlbTtcclxufVxyXG5gXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRnVpUG9wdXAgaW1wbGVtZW50cyBJUG9wdXAge1xyXG5cclxuICAvLyBDb25maWcgc2V0dGluZ3MgZm9yIHRoaXMgcG9wdXAuXHJcbiAgcHVibGljIGNvbmZpZzogVGVtcGxhdGVQb3B1cENvbmZpZzxhbnk+O1xyXG4gIHB1YmxpYyB0cmFuc2l0aW9uQ29udHJvbGxlcjogVHJhbnNpdGlvbkNvbnRyb2xsZXI7XHJcbiAgcHVibGljIHBvc2l0aW9uaW5nU2VydmljZTogUG9zaXRpb25pbmdTZXJ2aWNlO1xyXG4gIC8vIGBzZXRUaW1lb3V0YCB0aW1lciBwb2ludGVyIGZvciBjYW5jZWxsaW5nIHBvcHVwIGNsb3NlLlxyXG4gIHB1YmxpYyBjbG9zaW5nVGltZW91dDogbnVtYmVyO1xyXG4gIC8vIEZpcmVzIHdoZW4gdGhlIHBvcHVwIG9wZW5zIChhbmQgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZWQpLlxyXG4gIHB1YmxpYyBvbk9wZW46IEV2ZW50RW1pdHRlcjx2b2lkPjtcclxuICAvLyBGaXJlcyB3aGVuIHRoZSBwb3B1cCBjbG9zZXMgKGFuZCB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlZCkuXHJcbiAgcHVibGljIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjx2b2lkPjtcclxuICAvLyBgVmlld0NvbnRhaW5lclJlZmAgZm9yIHRoZSBlbGVtZW50IHRoZSB0ZW1wbGF0ZSBnZXRzIGluamVjdGVkIGFzIGEgc2libGluZyBvZi5cclxuICBAVmlld0NoaWxkKCd0ZW1wbGF0ZVNpYmxpbmcnLCB7cmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlfSlcclxuICBwdWJsaWMgdGVtcGxhdGVTaWJsaW5nOiBWaWV3Q29udGFpbmVyUmVmO1xyXG4gIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpXHJcbiAgcHVibGljIHJlYWRvbmx5IHRhYmluZGV4OiBudW1iZXI7XHJcbiAgLy8gYEVsZW1lbnRSZWZgIGZvciB0aGUgcG9zaXRpb25pbmcgc3ViamVjdC5cclxuICBAVmlld0NoaWxkKCdjb250YWluZXInLCB7cmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiBmYWxzZX0pXHJcbiAgcHJpdmF0ZSBfY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmO1xyXG5cclxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xyXG4gICAgdGhpcy50cmFuc2l0aW9uQ29udHJvbGxlciA9IG5ldyBUcmFuc2l0aW9uQ29udHJvbGxlcihmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5vbk9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcbiAgICB0aGlzLm9uQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcblxyXG4gICAgdGhpcy50YWJpbmRleCA9IDA7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm5zIHRoZSBkaXJlY3Rpb24gKGB0b3BgLCBgbGVmdGAsIGByaWdodGAsIGBib3R0b21gKSBvZiB0aGUgY3VycmVudCBwbGFjZW1lbnQuXHJcbiAgcHVibGljIGdldCBkaXJlY3Rpb24oKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIC8vIFdlIG5lZWQgdG8gc2V0IGRpcmVjdGlvbiBhdHRyaWJ1dGUgYmVmb3JlIHBvcHBlciBpbml0IHRvIGFsbG93IGNvcnJlY3QgcG9zaXRpb25pbmdcclxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQuc3BsaXQoJyAnKS5zaGlmdCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJucyB0aGUgYWxpZ25tZW50IChgdG9wYCwgYGxlZnRgLCBgcmlnaHRgLCBgYm90dG9tYCkgb2YgdGhlIGN1cnJlbnQgcGxhY2VtZW50LlxyXG4gIHB1YmxpYyBnZXQgYWxpZ25tZW50KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGxhY2VtZW50LnNwbGl0KCcgJykucG9wKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IGR5bmFtaWNDbGFzc2VzKCk6IElEeW5hbWljQ2xhc3NlcyB7XHJcbiAgICBjb25zdCBjbGFzc2VzOiBJRHluYW1pY0NsYXNzZXMgPSB7fTtcclxuICAgIGlmICh0aGlzLmRpcmVjdGlvbikge1xyXG4gICAgICBjbGFzc2VzW3RoaXMuZGlyZWN0aW9uXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5hbGlnbm1lbnQpIHtcclxuICAgICAgY2xhc3Nlc1t0aGlzLmFsaWdubWVudF0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY29uZmlnLmlzSW52ZXJ0ZWQpIHtcclxuICAgICAgY2xhc3Nlcy5pbnZlcnRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jb25maWcuaXNCYXNpYykge1xyXG4gICAgICBjbGFzc2VzLmJhc2ljID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNvbmZpZy5pc0Zsb3dpbmcpIHtcclxuICAgICAgY2xhc3Nlcy5mbG93aW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNvbmZpZy5zaXplKSB7XHJcbiAgICAgIGNsYXNzZXNbdGhpcy5jb25maWcuc2l6ZV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY29uZmlnLndpZHRoKSB7XHJcbiAgICAgIGNsYXNzZXNbdGhpcy5jb25maWcud2lkdGhdID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbGFzc2VzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfYW5jaG9yOiBFbGVtZW50UmVmO1xyXG5cclxuICBwdWJsaWMgc2V0IGFuY2hvcihhbmNob3I6IEVsZW1lbnRSZWYpIHtcclxuICAgIHRoaXMuX2FuY2hvciA9IGFuY2hvcjtcclxuICB9XHJcblxyXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHBvcHVwIGlzIG9wZW4gaW50ZXJuYWxseS5cclxuICBwcml2YXRlIF9pc09wZW46IGJvb2xlYW47XHJcblxyXG4gIHB1YmxpYyBnZXQgaXNPcGVuKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzT3BlbjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBvcGVuKCk6IHZvaWQge1xyXG4gICAgLy8gT25seSBhdHRlbXB0IHRvIG9wZW4gaWYgY3VycmVudGx5IGNsb3NlZC5cclxuICAgIGlmICghdGhpcy5pc09wZW4pIHtcclxuICAgICAgLy8gQ2FuY2VsIHRoZSBjbG9zaW5nIHRpbWVyLlxyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zaW5nVGltZW91dCk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgcG9zaXRpb25pbmcgc2VydmljZSBhZnRlciBhIGJyaWVmIGRlbGF5LlxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uaW5nU2VydmljZSA9IG5ldyBQb3NpdGlvbmluZ1NlcnZpY2UoXHJcbiAgICAgICAgICB0aGlzLl9hbmNob3IsXHJcbiAgICAgICAgICB0aGlzLl9jb250YWluZXIuZWxlbWVudCxcclxuICAgICAgICAgIHRoaXMuY29uZmlnLnBsYWNlbWVudCxcclxuICAgICAgICAgICcuZHluYW1pYy5hcnJvdydcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb25pbmdTZXJ2aWNlLmhhc0Fycm93ID0gIXRoaXMuY29uZmlnLmlzQmFzaWM7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gQ2FuY2VsIGFsbCBvdGhlciB0cmFuc2l0aW9ucywgYW5kIGluaXRpYXRlIHRoZSBvcGVuaW5nIHRyYW5zaXRpb24uXHJcbiAgICAgIHRoaXMudHJhbnNpdGlvbkNvbnRyb2xsZXIuc3RvcEFsbCgpO1xyXG4gICAgICB0aGlzLnRyYW5zaXRpb25Db250cm9sbGVyLmFuaW1hdGUoXHJcbiAgICAgICAgbmV3IFRyYW5zaXRpb24odGhpcy5jb25maWcudHJhbnNpdGlvbiwgdGhpcy5jb25maWcudHJhbnNpdGlvbkR1cmF0aW9uLCBUcmFuc2l0aW9uRGlyZWN0aW9uLkluLCAoKSA9PiB7XHJcbiAgICAgICAgICAvLyBGb2N1cyBhbnkgZWxlbWVudCB3aXRoIFthdXRvZm9jdXNdIGF0dHJpYnV0ZS5cclxuICAgICAgICAgIGNvbnN0IGF1dG9Gb2N1cyA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1thdXRvZm9jdXNdJykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xyXG4gICAgICAgICAgaWYgKGF1dG9Gb2N1cykge1xyXG4gICAgICAgICAgICAvLyBBdXRvZm9jdXMgYWZ0ZXIgdGhlIGJyb3dzZXIgaGFzIGhhZCB0aW1lIHRvIHByb2Nlc3Mgb3RoZXIgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gYXV0b0ZvY3VzLmZvY3VzKCksIDEwKTtcclxuICAgICAgICAgICAgLy8gVHJ5IHRvIGZvY3VzIGFnYWluIHdoZW4gdGhlIG1vZGFsIGhhcyBvcGVuZWQgc28gdGhhdCBhdXRvZm9jdXMgd29ya3MgaW4gSUUxMS5cclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBhdXRvRm9jdXMuZm9jdXMoKSwgdGhpcy5jb25maWcudHJhbnNpdGlvbkR1cmF0aW9uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAvLyBGaW5hbGx5LCBzZXQgdGhlIHBvcHVwIHRvIGJlIG9wZW4uXHJcbiAgICAgIHRoaXMuX2lzT3BlbiA9IHRydWU7XHJcbiAgICAgIHRoaXMub25PcGVuLmVtaXQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyB0b2dnbGUoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm9wZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5jbG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGNsb3NlKCk6IHZvaWQge1xyXG4gICAgLy8gT25seSBhdHRlbXB0IHRvIGNsb3NlIGlmIGN1cnJlbnRseSBvcGVuLlxyXG4gICAgaWYgKHRoaXMuaXNPcGVuKSB7XHJcbiAgICAgIC8vIENhbmNlbCBhbGwgb3RoZXIgdHJhbnNpdGlvbnMsIGFuZCBpbml0aWF0ZSB0aGUgY2xvc2luZyB0cmFuc2l0aW9uLlxyXG4gICAgICB0aGlzLnRyYW5zaXRpb25Db250cm9sbGVyLnN0b3BBbGwoKTtcclxuICAgICAgdGhpcy50cmFuc2l0aW9uQ29udHJvbGxlci5hbmltYXRlKFxyXG4gICAgICAgIG5ldyBUcmFuc2l0aW9uKHRoaXMuY29uZmlnLnRyYW5zaXRpb24sIHRoaXMuY29uZmlnLnRyYW5zaXRpb25EdXJhdGlvbiwgVHJhbnNpdGlvbkRpcmVjdGlvbi5PdXQpKTtcclxuXHJcbiAgICAgIC8vIENhbmNlbCB0aGUgY2xvc2luZyB0aW1lci5cclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2luZ1RpbWVvdXQpO1xyXG4gICAgICAvLyBTdGFydCB0aGUgY2xvc2luZyB0aW1lciwgdGhhdCBmaXJlcyB0aGUgYG9uQ2xvc2VgIGV2ZW50IGFmdGVyIHRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXHJcbiAgICAgIHRoaXMuY2xvc2luZ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLm9uQ2xvc2UuZW1pdCgpLCB0aGlzLmNvbmZpZy50cmFuc2l0aW9uRHVyYXRpb24pO1xyXG5cclxuICAgICAgLy8gRmluYWxseSwgc2V0IHRoZSBwb3B1cCB0byBiZSBjbG9zZWQuXHJcbiAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxyXG4gIHB1YmxpYyBvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAvLyBNYWtlcyBzZW5zZSBoZXJlLCBhcyB0aGUgcG9wdXAgc2hvdWxkbid0IGJlIGF0dGFjaGVkIHRvIGFueSBET00gZWxlbWVudC5cclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH1cclxufVxyXG4iXX0=