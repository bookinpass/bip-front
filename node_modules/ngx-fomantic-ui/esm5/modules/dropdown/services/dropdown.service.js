/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { EventEmitter } from '@angular/core';
// Creates essentially a 'string' enum.
/** @type {?} */
export var DropdownAutoCloseType = {
    ItemClick: (/** @type {?} */ ('itemClick')),
    OutsideClick: (/** @type {?} */ ('outsideClick')),
    Disabled: (/** @type {?} */ ('disabled'))
};
var DropdownService = /** @class */ (function () {
    function DropdownService(autoCloseMode) {
        if (autoCloseMode === void 0) { autoCloseMode = DropdownAutoCloseType.ItemClick; }
        this.isOpen = false;
        this.isOpenChange = new EventEmitter();
        this.isDisabled = false;
        this.autoCloseMode = autoCloseMode;
        this.children = [];
    }
    Object.defineProperty(DropdownService.prototype, "isNested", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.parent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} isOpen
     * @param {?=} reflectInParent
     * @return {?}
     */
    DropdownService.prototype.setOpenState = /**
     * @param {?} isOpen
     * @param {?=} reflectInParent
     * @return {?}
     */
    function (isOpen, reflectInParent) {
        var _this = this;
        if (reflectInParent === void 0) { reflectInParent = false; }
        if (this.isOpen !== isOpen && !this.isDisabled) {
            // Only update the state if it has changed, and the dropdown isn't disabled.
            this.isOpen = !!isOpen;
            this.isAnimating = true;
            // We must delay the emitting to avoid the 'changed after checked' Angular errors.
            this.delay((/**
             * @return {?}
             */
            function () { return _this.isOpenChange.emit(_this.isOpen); }));
            if (!this.isOpen) {
                // Close the child dropdowns when this one closes.
                this.children.forEach((/**
                 * @param {?} c
                 * @return {?}
                 */
                function (c) { return c.setOpenState(_this.isOpen); }));
            }
            if (this.parent && reflectInParent) {
                // Open the parent dropdowns when this one opens.
                this.parent.setOpenState(this.isOpen, true);
            }
        }
        else if (this.isOpen !== isOpen && this.isDisabled) {
            // If the state has changed, but the dropdown is disabled, re-emit the original isOpen value.
            this.delay((/**
             * @return {?}
             */
            function () { return _this.isOpenChange.emit(_this.isOpen); }));
        }
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    DropdownService.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        if (this.isDisabled !== isDisabled) {
            if (!!isDisabled) {
                // Close the dropdown as it is now disabled
                this.setOpenState(false);
            }
            this.isDisabled = !!isDisabled;
        }
    };
    /**
     * @return {?}
     */
    DropdownService.prototype.toggleOpenState = /**
     * @return {?}
     */
    function () {
        this.setOpenState(!this.isOpen);
    };
    // Registers a dropdown service as a child of this service.
    // Registers a dropdown service as a child of this service.
    /**
     * @param {?} child
     * @return {?}
     */
    DropdownService.prototype.registerChild = 
    // Registers a dropdown service as a child of this service.
    /**
     * @param {?} child
     * @return {?}
     */
    function (child) {
        if (!this.isChildRegistered(child)) {
            this.children.push(child);
            child.parent = this;
        }
    };
    // Recursive method to check if the provided dropdown is already registered as a child, or is a descendant of a child.
    // Recursive method to check if the provided dropdown is already registered as a child, or is a descendant of a child.
    /**
     * @param {?} child
     * @return {?}
     */
    DropdownService.prototype.isChildRegistered = 
    // Recursive method to check if the provided dropdown is already registered as a child, or is a descendant of a child.
    /**
     * @param {?} child
     * @return {?}
     */
    function (child) {
        return this === child || !!this.children
            .find((/**
         * @param {?} c
         * @return {?}
         */
        function (c) { return !!c.children
            .find((/**
         * @param {?} cChild
         * @return {?}
         */
        function (cChild) { return cChild.isChildRegistered(child); })); }));
    };
    // Wipes any nested data, so all services can be cleanly reattached.
    // Wipes any nested data, so all services can be cleanly reattached.
    /**
     * @return {?}
     */
    DropdownService.prototype.clearChildren = 
    // Wipes any nested data, so all services can be cleanly reattached.
    /**
     * @return {?}
     */
    function () {
        this.children.forEach((/**
         * @param {?} c
         * @return {?}
         */
        function (c) {
            c.parent = undefined;
        }));
        this.children = [];
    };
    // Method for delaying an event into the next tick, to avoid Angular "changed after checked" error.
    // Method for delaying an event into the next tick, to avoid Angular "changed after checked" error.
    /**
     * @private
     * @param {?} callback
     * @return {?}
     */
    DropdownService.prototype.delay = 
    // Method for delaying an event into the next tick, to avoid Angular "changed after checked" error.
    /**
     * @private
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        setTimeout((/**
         * @return {?}
         */
        function () { return callback(); }));
    };
    return DropdownService;
}());
export { DropdownService };
if (false) {
    /** @type {?} */
    DropdownService.prototype.isOpen;
    /** @type {?} */
    DropdownService.prototype.isAnimating;
    /** @type {?} */
    DropdownService.prototype.isOpenChange;
    /** @type {?} */
    DropdownService.prototype.isDisabled;
    /** @type {?} */
    DropdownService.prototype.autoCloseMode;
    /** @type {?} */
    DropdownService.prototype.parent;
    /** @type {?} */
    DropdownService.prototype.children;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1mb21hbnRpYy11aS8iLCJzb3VyY2VzIjpbIm1vZHVsZXMvZHJvcGRvd24vc2VydmljZXMvZHJvcGRvd24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLGVBQWUsQ0FBQzs7O0FBSzNDLE1BQU0sS0FBTyxxQkFBcUIsR0FBRztJQUNuQyxTQUFTLEVBQUUsbUJBQUEsV0FBVyxFQUF5QjtJQUMvQyxZQUFZLEVBQUUsbUJBQUEsY0FBYyxFQUF5QjtJQUNyRCxRQUFRLEVBQUUsbUJBQUEsVUFBVSxFQUF5QjtDQUM5QztBQUVEO0lBa0JFLHlCQUFZLGFBQXNFO1FBQXRFLDhCQUFBLEVBQUEsZ0JBQXVDLHFCQUFxQixDQUFDLFNBQVM7UUFDaEYsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLFlBQVksRUFBVyxDQUFDO1FBRWhELElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBRXhCLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO1FBRW5DLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFRCxzQkFBVyxxQ0FBUTs7OztRQUFuQjtZQUNFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDdkIsQ0FBQzs7O09BQUE7Ozs7OztJQUVNLHNDQUFZOzs7OztJQUFuQixVQUFvQixNQUFlLEVBQUUsZUFBZ0M7UUFBckUsaUJBcUJDO1FBckJvQyxnQ0FBQSxFQUFBLHVCQUFnQztRQUNuRSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUM5Qyw0RUFBNEU7WUFDNUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3hCLGtGQUFrRjtZQUNsRixJQUFJLENBQUMsS0FBSzs7O1lBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsRUFBbkMsQ0FBbUMsRUFBQyxDQUFDO1lBRXRELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNoQixrREFBa0Q7Z0JBQ2xELElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTzs7OztnQkFBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxZQUFZLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxFQUEzQixDQUEyQixFQUFDLENBQUM7YUFDekQ7WUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksZUFBZSxFQUFFO2dCQUNsQyxpREFBaUQ7Z0JBQ2pELElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDN0M7U0FDRjthQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNwRCw2RkFBNkY7WUFDN0YsSUFBSSxDQUFDLEtBQUs7OztZQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLEVBQW5DLENBQW1DLEVBQUMsQ0FBQztTQUN2RDtJQUNILENBQUM7Ozs7O0lBRU0sMENBQWdCOzs7O0lBQXZCLFVBQXdCLFVBQW1CO1FBQ3pDLElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLEVBQUU7WUFDbEMsSUFBSSxDQUFDLENBQUMsVUFBVSxFQUFFO2dCQUNoQiwyQ0FBMkM7Z0JBQzNDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDMUI7WUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUM7U0FDaEM7SUFDSCxDQUFDOzs7O0lBRU0seUNBQWU7OztJQUF0QjtRQUNFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVELDJEQUEyRDs7Ozs7O0lBQ3BELHVDQUFhOzs7Ozs7SUFBcEIsVUFBcUIsS0FBc0I7UUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNsQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMxQixLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztTQUNyQjtJQUNILENBQUM7SUFFRCxzSEFBc0g7Ozs7OztJQUMvRywyQ0FBaUI7Ozs7OztJQUF4QixVQUF5QixLQUFzQjtRQUM3QyxPQUFPLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRO2FBQ3JDLElBQUk7Ozs7UUFBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUTthQUNwQixJQUFJOzs7O1FBQUMsVUFBQSxNQUFNLElBQUksT0FBQSxNQUFNLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLEVBQS9CLENBQStCLEVBQUMsRUFEdkMsQ0FDdUMsRUFBQyxDQUFDO0lBQ3hELENBQUM7SUFFRCxvRUFBb0U7Ozs7O0lBQzdELHVDQUFhOzs7OztJQUFwQjtRQUNFLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTzs7OztRQUFDLFVBQUEsQ0FBQztZQUNyQixDQUFDLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztRQUN2QixDQUFDLEVBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFRCxtR0FBbUc7Ozs7Ozs7SUFDM0YsK0JBQUs7Ozs7Ozs7SUFBYixVQUFjLFFBQW9CO1FBQ2hDLFVBQVU7OztRQUFDLGNBQU0sT0FBQSxRQUFRLEVBQUUsRUFBVixDQUFVLEVBQUMsQ0FBQztJQUMvQixDQUFDO0lBQ0gsc0JBQUM7QUFBRCxDQUFDLEFBbEdELElBa0dDOzs7O0lBaEdDLGlDQUF1Qjs7SUFFdkIsc0NBQTRCOztJQUU1Qix1Q0FBMkM7O0lBRTNDLHFDQUEyQjs7SUFHM0Isd0NBQTRDOztJQUc1QyxpQ0FBZ0M7O0lBRWhDLG1DQUFtQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RXZlbnRFbWl0dGVyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmV4cG9ydCB0eXBlIERyb3Bkb3duQXV0b0Nsb3NlVHlwZSA9ICdpdGVtQ2xpY2snIHwgJ291dHNpZGVDbGljaycgfCAnZGlzYWJsZWQnO1xyXG5cclxuLy8gQ3JlYXRlcyBlc3NlbnRpYWxseSBhICdzdHJpbmcnIGVudW0uXHJcbmV4cG9ydCBjb25zdCBEcm9wZG93bkF1dG9DbG9zZVR5cGUgPSB7XHJcbiAgSXRlbUNsaWNrOiAnaXRlbUNsaWNrJyBhcyBEcm9wZG93bkF1dG9DbG9zZVR5cGUsXHJcbiAgT3V0c2lkZUNsaWNrOiAnb3V0c2lkZUNsaWNrJyBhcyBEcm9wZG93bkF1dG9DbG9zZVR5cGUsXHJcbiAgRGlzYWJsZWQ6ICdkaXNhYmxlZCcgYXMgRHJvcGRvd25BdXRvQ2xvc2VUeXBlXHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgRHJvcGRvd25TZXJ2aWNlIHtcclxuICAvLyBPcGVuIHN0YXRlIG9mIHRoZSBkcm9wZG93blxyXG4gIHB1YmxpYyBpc09wZW46IGJvb2xlYW47XHJcbiAgLy8gQW5pbWF0aW5nIHN0YXRlIG9mIHRoZSBkcm9wZG93bi5cclxuICBwdWJsaWMgaXNBbmltYXRpbmc6IGJvb2xlYW47XHJcbiAgLy8gRW1pdHRlciBmb3Igd2hlbiBkcm9wZG93biBvcGVuIHN0YXRlIGNoYW5nZXMuXHJcbiAgcHVibGljIGlzT3BlbkNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+O1xyXG5cclxuICBwdWJsaWMgaXNEaXNhYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgLy8gU2V0cyB0aGUgXCJhdXRvY2xvc2VcIiBtb2RlIG9mIHRoZSBkcm9wZG93biAtIGkuZS4gd2hhdCB1c2VyIGFjdGlvbiBjYXVzZXMgaXQgdG8gYXV0b2Nsb3NlLlxyXG4gIHB1YmxpYyBhdXRvQ2xvc2VNb2RlOiBEcm9wZG93bkF1dG9DbG9zZVR5cGU7XHJcblxyXG4gIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGNvbnRhaW5pbmcgZHJvcGRvd24gc28gd2UgY2FuIG9wZW4gaXQgYXMgbmVjZXNzYXJ5LlxyXG4gIHB1YmxpYyBwYXJlbnQ/OiBEcm9wZG93blNlcnZpY2U7XHJcbiAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIGRyb3Bkb3ducyBuZXN0ZWQgaW4gdGhpcyBvbmUgc28gd2UgY2FuIGNsb3NlIHRoZW0gYXMgbmVjZXNzYXJ5LlxyXG4gIHB1YmxpYyBjaGlsZHJlbjogRHJvcGRvd25TZXJ2aWNlW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKGF1dG9DbG9zZU1vZGU6IERyb3Bkb3duQXV0b0Nsb3NlVHlwZSA9IERyb3Bkb3duQXV0b0Nsb3NlVHlwZS5JdGVtQ2xpY2spIHtcclxuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzT3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcclxuXHJcbiAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmF1dG9DbG9zZU1vZGUgPSBhdXRvQ2xvc2VNb2RlO1xyXG5cclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgaXNOZXN0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gISF0aGlzLnBhcmVudDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXRPcGVuU3RhdGUoaXNPcGVuOiBib29sZWFuLCByZWZsZWN0SW5QYXJlbnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuaXNPcGVuICE9PSBpc09wZW4gJiYgIXRoaXMuaXNEaXNhYmxlZCkge1xyXG4gICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgc3RhdGUgaWYgaXQgaGFzIGNoYW5nZWQsIGFuZCB0aGUgZHJvcGRvd24gaXNuJ3QgZGlzYWJsZWQuXHJcbiAgICAgIHRoaXMuaXNPcGVuID0gISFpc09wZW47XHJcbiAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAvLyBXZSBtdXN0IGRlbGF5IHRoZSBlbWl0dGluZyB0byBhdm9pZCB0aGUgJ2NoYW5nZWQgYWZ0ZXIgY2hlY2tlZCcgQW5ndWxhciBlcnJvcnMuXHJcbiAgICAgIHRoaXMuZGVsYXkoKCkgPT4gdGhpcy5pc09wZW5DaGFuZ2UuZW1pdCh0aGlzLmlzT3BlbikpO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xyXG4gICAgICAgIC8vIENsb3NlIHRoZSBjaGlsZCBkcm9wZG93bnMgd2hlbiB0aGlzIG9uZSBjbG9zZXMuXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gYy5zZXRPcGVuU3RhdGUodGhpcy5pc09wZW4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHJlZmxlY3RJblBhcmVudCkge1xyXG4gICAgICAgIC8vIE9wZW4gdGhlIHBhcmVudCBkcm9wZG93bnMgd2hlbiB0aGlzIG9uZSBvcGVucy5cclxuICAgICAgICB0aGlzLnBhcmVudC5zZXRPcGVuU3RhdGUodGhpcy5pc09wZW4sIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNPcGVuICE9PSBpc09wZW4gJiYgdGhpcy5pc0Rpc2FibGVkKSB7XHJcbiAgICAgIC8vIElmIHRoZSBzdGF0ZSBoYXMgY2hhbmdlZCwgYnV0IHRoZSBkcm9wZG93biBpcyBkaXNhYmxlZCwgcmUtZW1pdCB0aGUgb3JpZ2luYWwgaXNPcGVuIHZhbHVlLlxyXG4gICAgICB0aGlzLmRlbGF5KCgpID0+IHRoaXMuaXNPcGVuQ2hhbmdlLmVtaXQodGhpcy5pc09wZW4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQgIT09IGlzRGlzYWJsZWQpIHtcclxuICAgICAgaWYgKCEhaXNEaXNhYmxlZCkge1xyXG4gICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93biBhcyBpdCBpcyBub3cgZGlzYWJsZWRcclxuICAgICAgICB0aGlzLnNldE9wZW5TdGF0ZShmYWxzZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuaXNEaXNhYmxlZCA9ICEhaXNEaXNhYmxlZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyB0b2dnbGVPcGVuU3RhdGUoKTogdm9pZCB7XHJcbiAgICB0aGlzLnNldE9wZW5TdGF0ZSghdGhpcy5pc09wZW4pO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVnaXN0ZXJzIGEgZHJvcGRvd24gc2VydmljZSBhcyBhIGNoaWxkIG9mIHRoaXMgc2VydmljZS5cclxuICBwdWJsaWMgcmVnaXN0ZXJDaGlsZChjaGlsZDogRHJvcGRvd25TZXJ2aWNlKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuaXNDaGlsZFJlZ2lzdGVyZWQoY2hpbGQpKSB7XHJcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZWN1cnNpdmUgbWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBwcm92aWRlZCBkcm9wZG93biBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgYXMgYSBjaGlsZCwgb3IgaXMgYSBkZXNjZW5kYW50IG9mIGEgY2hpbGQuXHJcbiAgcHVibGljIGlzQ2hpbGRSZWdpc3RlcmVkKGNoaWxkOiBEcm9wZG93blNlcnZpY2UpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzID09PSBjaGlsZCB8fCAhIXRoaXMuY2hpbGRyZW5cclxuICAgICAgLmZpbmQoYyA9PiAhIWMuY2hpbGRyZW5cclxuICAgICAgICAuZmluZChjQ2hpbGQgPT4gY0NoaWxkLmlzQ2hpbGRSZWdpc3RlcmVkKGNoaWxkKSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gV2lwZXMgYW55IG5lc3RlZCBkYXRhLCBzbyBhbGwgc2VydmljZXMgY2FuIGJlIGNsZWFubHkgcmVhdHRhY2hlZC5cclxuICBwdWJsaWMgY2xlYXJDaGlsZHJlbigpOiB2b2lkIHtcclxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcclxuICAgICAgYy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICB9XHJcblxyXG4gIC8vIE1ldGhvZCBmb3IgZGVsYXlpbmcgYW4gZXZlbnQgaW50byB0aGUgbmV4dCB0aWNrLCB0byBhdm9pZCBBbmd1bGFyIFwiY2hhbmdlZCBhZnRlciBjaGVja2VkXCIgZXJyb3IuXHJcbiAgcHJpdmF0ZSBkZWxheShjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjaygpKTtcclxuICB9XHJcbn1cclxuIl19