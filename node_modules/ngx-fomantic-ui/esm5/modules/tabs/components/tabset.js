/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChildren, QueryList } from '@angular/core';
import { FuiTabHeader } from '../directives/tab-header';
import { FuiTabContent } from '../directives/tab-content';
import { Tab } from '../classes/tab';
var FuiTabset = /** @class */ (function () {
    function FuiTabset() {
        this.tabs = [];
        this._barrierCount = 0;
    }
    Object.defineProperty(FuiTabset.prototype, "activeTab", {
        // When setting a tab as the currently active tab, it automatically gains
        get: 
        // When setting a tab as the currently active tab, it automatically gains
        /**
         * @return {?}
         */
        function () {
            return this._activeTab;
        },
        // `isActive` status (saves littering `isActive = true` everywhere).
        set: 
        // `isActive` status (saves littering `isActive = true` everywhere).
        /**
         * @param {?} tab
         * @return {?}
         */
        function (tab) {
            this._activeTab = tab;
            tab.isActive = true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FuiTabset.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Fire `internalComponentsUpdated` when the query lists change.
        this._tabHeaders.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.internalComponentsUpdated(); }));
        this._tabContents.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.internalComponentsUpdated(); }));
        // Initially load the tabs.
        this.loadTabs();
    };
    // Activate the first tab in the set.
    // Activate the first tab in the set.
    /**
     * @return {?}
     */
    FuiTabset.prototype.activateFirstTab = 
    // Activate the first tab in the set.
    /**
     * @return {?}
     */
    function () {
        this.activeTab = this.tabs[0];
    };
    // Activates the closest available tab to a given one.
    // Activates the closest available tab to a given one.
    /**
     * @param {?} tab
     * @return {?}
     */
    FuiTabset.prototype.activateClosestTab = 
    // Activates the closest available tab to a given one.
    /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        /** @type {?} */
        var nextAvailable;
        // When the exited tab's index is higher than all available tabs,
        if (tab.index >= this.tabs.length) {
            // Activate the last tab.
            nextAvailable = this.tabs[this.tabs.length - 1];
        }
        // If that didn't work, try the following cases:
        if (!nextAvailable) {
            if (!this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return t === tab; }))) { // When the exited tab no longer exists,
                // Replace it with a tab at the same index.
                nextAvailable = this.tabs[tab.index];
            }
            else { // Or if the exited tab still exists,
                // Go to the tab immediately to the left.
                nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];
            }
        }
        // However, if the chosen tab is disabled,
        if (nextAvailable.isDisabled) {
            // Activate the closest available tab to it.
            return this.activateClosestTab(nextAvailable);
        }
        this.activeTab = nextAvailable;
    };
    // Fires whenever either the tab headers or tab contents query lists update.
    // Fires whenever either the tab headers or tab contents query lists update.
    /**
     * @private
     * @return {?}
     */
    FuiTabset.prototype.internalComponentsUpdated = 
    // Fires whenever either the tab headers or tab contents query lists update.
    /**
     * @private
     * @return {?}
     */
    function () {
        // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.
        // This is so that both the headers and contents query lists can update before we run code that matches the two up.
        this._barrierCount++;
        if (this._barrierCount === 2) {
            // Reset the barrier so it can be called again.
            this._barrierCount = 0;
            // Update the tabs.
            this.loadTabs();
        }
    };
    // Connects tab headers to tab contents, and creates a tab instance for each pairing.
    // Connects tab headers to tab contents, and creates a tab instance for each pairing.
    /**
     * @private
     * @return {?}
     */
    FuiTabset.prototype.loadTabs = 
    // Connects tab headers to tab contents, and creates a tab instance for each pairing.
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Remove any tabs that no longer have an associated header.
        this.tabs = this.tabs.filter((/**
         * @param {?} t
         * @return {?}
         */
        function (t) { return !!_this._tabHeaders.find((/**
         * @param {?} tH
         * @return {?}
         */
        function (tH) { return tH === t.header; })); }));
        this._tabHeaders
            // Filter out the loaded headers with attached tab instances.
            .filter((/**
         * @param {?} tH
         * @return {?}
         */
        function (tH) { return !_this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        function (t) { return t.header === tH; })); }))
            .forEach((/**
         * @param {?} tH
         * @return {?}
         */
        function (tH) {
            /** @type {?} */
            var content = _this._tabContents.find((/**
             * @param {?} tC
             * @return {?}
             */
            function (tC) { return tC.id === tH.id; }));
            if (!content) {
                // Error if an associated tab content cannot be found for the given header.
                throw new Error('A [fuiTabHeader] must have a related [fuiTabContent].');
            }
            // Create a new tab instance for this header & content combo.
            /** @type {?} */
            var tab = new Tab(tH, content);
            // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.
            tab.header.isActiveExternalChange.subscribe((/**
             * @return {?}
             */
            function () { return _this.onHeaderActiveChanged(tab); }));
            // Add the new instance to the list of tabs.
            _this.tabs.push(tab);
        }));
        // Assign each tab an index (which denotes the order they physically appear in).
        this._tabHeaders
            .forEach((/**
         * @param {?} tH
         * @param {?} i
         * @return {?}
         */
        function (tH, i) {
            /** @type {?} */
            var tab = _this.tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return t.header === tH; }));
            if (tab) {
                tab.index = i;
            }
        }));
        // Sort the tabs by their index.
        this.tabs.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) { return a.index - b.index; }));
        if (!this.activeTab) { // Check if there are no current existing active tabs.
            // If so, we must activate the first available tab.
            this.activateFirstTab();
        }
        else if (!this.tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        function (t) { return t === _this.activeTab; }))) { // O'wise check if current active tab has been deleted.
            // If so, we must find the closest.
            // Use `setTimeout` as this causes a 'changed after checked' error o'wise.
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.activateClosestTab(_this.activeTab); }));
        }
        if (this.tabs.length === 0) {
            // Error if there aren't any tabs in the tabset.
            throw new Error('You cannot have no tabs!');
        }
    };
    // Fires whenever a tab header's active state is externally changed.
    // Fires whenever a tab header's active state is externally changed.
    /**
     * @private
     * @param {?} tab
     * @return {?}
     */
    FuiTabset.prototype.onHeaderActiveChanged = 
    // Fires whenever a tab header's active state is externally changed.
    /**
     * @private
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        // If the tab has become activated, but was not previously the active tab:
        if (tab.isActive && this.activeTab !== tab) {
            // Deactivate all of the tabs.
            this.tabs.filter((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return t !== tab; })).forEach((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return t.isActive = false; }));
            // Set the currently active tab to this one.
            this.activeTab = tab;
        }
        // If the tab has become deactivated, but was previously the active tab:
        if (!tab.isActive && this.activeTab === tab) {
            // Activate the closest tab to it.
            this.activateClosestTab(tab);
        }
    };
    FuiTabset.decorators = [
        { type: Component, args: [{
                    selector: 'fui-tabset',
                    template: "<ng-content></ng-content>"
                }] }
    ];
    /** @nocollapse */
    FuiTabset.ctorParameters = function () { return []; };
    FuiTabset.propDecorators = {
        _tabHeaders: [{ type: ContentChildren, args: [FuiTabHeader,] }],
        _tabContents: [{ type: ContentChildren, args: [FuiTabContent,] }]
    };
    return FuiTabset;
}());
export { FuiTabset };
if (false) {
    /** @type {?} */
    FuiTabset.prototype.tabs;
    /**
     * @type {?}
     * @private
     */
    FuiTabset.prototype._tabHeaders;
    /**
     * @type {?}
     * @private
     */
    FuiTabset.prototype._tabContents;
    /**
     * @type {?}
     * @private
     */
    FuiTabset.prototype._barrierCount;
    /**
     * @type {?}
     * @private
     */
    FuiTabset.prototype._activeTab;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFic2V0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWZvbWFudGljLXVpLyIsInNvdXJjZXMiOlsibW9kdWxlcy90YWJzL2NvbXBvbmVudHMvdGFic2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQW1CLFNBQVMsRUFBRSxlQUFlLEVBQUUsU0FBUyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3RGLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDeEQsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBRW5DO0lBZUU7UUFDRSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNmLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFPRCxzQkFBVyxnQ0FBUztRQUZwQix5RUFBeUU7Ozs7OztRQUV6RTtZQUNFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUN6QixDQUFDO1FBRUQsb0VBQW9FOzs7Ozs7O1FBQ3BFLFVBQXFCLEdBQVE7WUFDM0IsSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUM7WUFDdEIsR0FBRyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDdEIsQ0FBQzs7O09BTkE7Ozs7SUFRTSxzQ0FBa0I7OztJQUF6QjtRQUFBLGlCQU9DO1FBTkMsZ0VBQWdFO1FBQ2hFLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLFNBQVM7OztRQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMseUJBQXlCLEVBQUUsRUFBaEMsQ0FBZ0MsRUFBQyxDQUFDO1FBQzNFLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFNBQVM7OztRQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMseUJBQXlCLEVBQUUsRUFBaEMsQ0FBZ0MsRUFBQyxDQUFDO1FBRTVFLDJCQUEyQjtRQUMz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Qzs7Ozs7OEJBS0UsZUFBZSxTQUFDLFlBQVk7K0JBRTVCLGVBQWUsU0FBQyxhQUFhOztJQTJKaEMsZ0JBQUM7Q0FBQSxBQXJLRCxJQXFLQztTQWpLWSxTQUFTOzs7SUFHcEIseUJBQW1COzs7OztJQUNuQixnQ0FDNkM7Ozs7O0lBQzdDLGlDQUMrQzs7Ozs7SUFFL0Msa0NBQThCOzs7OztJQVE5QiwrQkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0FmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBRdWVyeUxpc3R9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0Z1aVRhYkhlYWRlcn0gZnJvbSAnLi4vZGlyZWN0aXZlcy90YWItaGVhZGVyJztcclxuaW1wb3J0IHtGdWlUYWJDb250ZW50fSBmcm9tICcuLi9kaXJlY3RpdmVzL3RhYi1jb250ZW50JztcclxuaW1wb3J0IHtUYWJ9IGZyb20gJy4uL2NsYXNzZXMvdGFiJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnZnVpLXRhYnNldCcsXHJcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRnVpVGFic2V0IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gIC8vIExpc3Qgb2YgYWxsIHRhYnMgaW4gdGhlIHRhYnNldC5cclxuICBwdWJsaWMgdGFiczogVGFiW107XHJcbiAgQENvbnRlbnRDaGlsZHJlbihGdWlUYWJIZWFkZXIpXHJcbiAgcHJpdmF0ZSBfdGFiSGVhZGVyczogUXVlcnlMaXN0PEZ1aVRhYkhlYWRlcj47XHJcbiAgQENvbnRlbnRDaGlsZHJlbihGdWlUYWJDb250ZW50KVxyXG4gIHByaXZhdGUgX3RhYkNvbnRlbnRzOiBRdWVyeUxpc3Q8RnVpVGFiQ29udGVudD47XHJcbiAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIG51bWJlciBvZiB0aW1lcyBgaW50ZXJuYWxDb21wb25lbnRzVXBkYXRlZGAgaXMgY2FsbGVkLlxyXG4gIHByaXZhdGUgX2JhcnJpZXJDb3VudDogbnVtYmVyO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMudGFicyA9IFtdO1xyXG4gICAgdGhpcy5fYmFycmllckNvdW50ID0gMDtcclxuICB9XHJcblxyXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYi5cclxuICBwcml2YXRlIF9hY3RpdmVUYWI6IFRhYjtcclxuXHJcbiAgLy8gV2hlbiBzZXR0aW5nIGEgdGFiIGFzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYiwgaXQgYXV0b21hdGljYWxseSBnYWluc1xyXG5cclxuICBwdWJsaWMgZ2V0IGFjdGl2ZVRhYigpOiBUYWIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRhYjtcclxuICB9XHJcblxyXG4gIC8vIGBpc0FjdGl2ZWAgc3RhdHVzIChzYXZlcyBsaXR0ZXJpbmcgYGlzQWN0aXZlID0gdHJ1ZWAgZXZlcnl3aGVyZSkuXHJcbiAgcHVibGljIHNldCBhY3RpdmVUYWIodGFiOiBUYWIpIHtcclxuICAgIHRoaXMuX2FjdGl2ZVRhYiA9IHRhYjtcclxuICAgIHRhYi5pc0FjdGl2ZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xyXG4gICAgLy8gRmlyZSBgaW50ZXJuYWxDb21wb25lbnRzVXBkYXRlZGAgd2hlbiB0aGUgcXVlcnkgbGlzdHMgY2hhbmdlLlxyXG4gICAgdGhpcy5fdGFiSGVhZGVycy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLmludGVybmFsQ29tcG9uZW50c1VwZGF0ZWQoKSk7XHJcbiAgICB0aGlzLl90YWJDb250ZW50cy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLmludGVybmFsQ29tcG9uZW50c1VwZGF0ZWQoKSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGx5IGxvYWQgdGhlIHRhYnMuXHJcbiAgICB0aGlzLmxvYWRUYWJzKCk7XHJcbiAgfVxyXG5cclxuICAvLyBBY3RpdmF0ZSB0aGUgZmlyc3QgdGFiIGluIHRoZSBzZXQuXHJcbiAgcHVibGljIGFjdGl2YXRlRmlyc3RUYWIoKTogdm9pZCB7XHJcbiAgICB0aGlzLmFjdGl2ZVRhYiA9IHRoaXMudGFic1swXTtcclxuICB9XHJcblxyXG4gIC8vIEFjdGl2YXRlcyB0aGUgY2xvc2VzdCBhdmFpbGFibGUgdGFiIHRvIGEgZ2l2ZW4gb25lLlxyXG4gIHB1YmxpYyBhY3RpdmF0ZUNsb3Nlc3RUYWIodGFiOiBUYWIpOiB2b2lkIHtcclxuICAgIGxldCBuZXh0QXZhaWxhYmxlOiBUYWIgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gV2hlbiB0aGUgZXhpdGVkIHRhYidzIGluZGV4IGlzIGhpZ2hlciB0aGFuIGFsbCBhdmFpbGFibGUgdGFicyxcclxuICAgIGlmICh0YWIuaW5kZXggPj0gdGhpcy50YWJzLmxlbmd0aCkge1xyXG4gICAgICAvLyBBY3RpdmF0ZSB0aGUgbGFzdCB0YWIuXHJcbiAgICAgIG5leHRBdmFpbGFibGUgPSB0aGlzLnRhYnNbdGhpcy50YWJzLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoYXQgZGlkbid0IHdvcmssIHRyeSB0aGUgZm9sbG93aW5nIGNhc2VzOlxyXG4gICAgaWYgKCFuZXh0QXZhaWxhYmxlKSB7XHJcbiAgICAgIGlmICghdGhpcy50YWJzLmZpbmQodCA9PiB0ID09PSB0YWIpKSB7IC8vIFdoZW4gdGhlIGV4aXRlZCB0YWIgbm8gbG9uZ2VyIGV4aXN0cyxcclxuICAgICAgICAvLyBSZXBsYWNlIGl0IHdpdGggYSB0YWIgYXQgdGhlIHNhbWUgaW5kZXguXHJcbiAgICAgICAgbmV4dEF2YWlsYWJsZSA9IHRoaXMudGFic1t0YWIuaW5kZXhdO1xyXG4gICAgICB9IGVsc2UgeyAvLyBPciBpZiB0aGUgZXhpdGVkIHRhYiBzdGlsbCBleGlzdHMsXHJcbiAgICAgICAgLy8gR28gdG8gdGhlIHRhYiBpbW1lZGlhdGVseSB0byB0aGUgbGVmdC5cclxuICAgICAgICBuZXh0QXZhaWxhYmxlID0gdGhpcy50YWJzW01hdGgubWF4KHRhYi5pbmRleCAtIDEsIDApXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBjaG9zZW4gdGFiIGlzIGRpc2FibGVkLFxyXG4gICAgaWYgKG5leHRBdmFpbGFibGUuaXNEaXNhYmxlZCkge1xyXG4gICAgICAvLyBBY3RpdmF0ZSB0aGUgY2xvc2VzdCBhdmFpbGFibGUgdGFiIHRvIGl0LlxyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZUNsb3Nlc3RUYWIobmV4dEF2YWlsYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hY3RpdmVUYWIgPSBuZXh0QXZhaWxhYmxlO1xyXG4gIH1cclxuXHJcbiAgLy8gRmlyZXMgd2hlbmV2ZXIgZWl0aGVyIHRoZSB0YWIgaGVhZGVycyBvciB0YWIgY29udGVudHMgcXVlcnkgbGlzdHMgdXBkYXRlLlxyXG4gIHByaXZhdGUgaW50ZXJuYWxDb21wb25lbnRzVXBkYXRlZCgpOiB2b2lkIHtcclxuICAgIC8vIFdlIGFyZSB1c2luZyBhICdjb3VudGluZyBiYXJyaWVyIG9mIG4gPSAyJywgaS5lLiB0aGUgY29kZSB3aXRoaW4gb25seSBydW5zIGFmdGVyIHRoZSBtZXRob2QgaXMgY2FsbGVkIHR3aWNlLlxyXG4gICAgLy8gVGhpcyBpcyBzbyB0aGF0IGJvdGggdGhlIGhlYWRlcnMgYW5kIGNvbnRlbnRzIHF1ZXJ5IGxpc3RzIGNhbiB1cGRhdGUgYmVmb3JlIHdlIHJ1biBjb2RlIHRoYXQgbWF0Y2hlcyB0aGUgdHdvIHVwLlxyXG4gICAgdGhpcy5fYmFycmllckNvdW50Kys7XHJcblxyXG4gICAgaWYgKHRoaXMuX2JhcnJpZXJDb3VudCA9PT0gMikge1xyXG4gICAgICAvLyBSZXNldCB0aGUgYmFycmllciBzbyBpdCBjYW4gYmUgY2FsbGVkIGFnYWluLlxyXG4gICAgICB0aGlzLl9iYXJyaWVyQ291bnQgPSAwO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSB0YWJzLlxyXG4gICAgICB0aGlzLmxvYWRUYWJzKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDb25uZWN0cyB0YWIgaGVhZGVycyB0byB0YWIgY29udGVudHMsIGFuZCBjcmVhdGVzIGEgdGFiIGluc3RhbmNlIGZvciBlYWNoIHBhaXJpbmcuXHJcbiAgcHJpdmF0ZSBsb2FkVGFicygpOiB2b2lkIHtcclxuICAgIC8vIFJlbW92ZSBhbnkgdGFicyB0aGF0IG5vIGxvbmdlciBoYXZlIGFuIGFzc29jaWF0ZWQgaGVhZGVyLlxyXG4gICAgdGhpcy50YWJzID0gdGhpcy50YWJzLmZpbHRlcih0ID0+ICEhdGhpcy5fdGFiSGVhZGVycy5maW5kKHRIID0+IHRIID09PSB0LmhlYWRlcikpO1xyXG5cclxuICAgIHRoaXMuX3RhYkhlYWRlcnNcclxuICAgIC8vIEZpbHRlciBvdXQgdGhlIGxvYWRlZCBoZWFkZXJzIHdpdGggYXR0YWNoZWQgdGFiIGluc3RhbmNlcy5cclxuICAgICAgLmZpbHRlcih0SCA9PiAhdGhpcy50YWJzLmZpbmQodCA9PiB0LmhlYWRlciA9PT0gdEgpKVxyXG4gICAgICAuZm9yRWFjaCh0SCA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuX3RhYkNvbnRlbnRzLmZpbmQodEMgPT4gdEMuaWQgPT09IHRILmlkKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb250ZW50KSB7XHJcbiAgICAgICAgICAvLyBFcnJvciBpZiBhbiBhc3NvY2lhdGVkIHRhYiBjb250ZW50IGNhbm5vdCBiZSBmb3VuZCBmb3IgdGhlIGdpdmVuIGhlYWRlci5cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBbZnVpVGFiSGVhZGVyXSBtdXN0IGhhdmUgYSByZWxhdGVkIFtmdWlUYWJDb250ZW50XS4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0YWIgaW5zdGFuY2UgZm9yIHRoaXMgaGVhZGVyICYgY29udGVudCBjb21iby5cclxuICAgICAgICBjb25zdCB0YWIgPSBuZXcgVGFiKHRILCBjb250ZW50KTtcclxuXHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGFueSBleHRlcm5hbCBjaGFuZ2VzIGluIHRoZSB0YWIgaGVhZGVyJ3MgYWN0aXZlIHN0YXRlLiBFeHRlcm5hbCBjaGFuZ2VzIGFyZSB0cmlnZ2VyZWQgYnkgdXNlciBpbnB1dC5cclxuICAgICAgICB0YWIuaGVhZGVyLmlzQWN0aXZlRXh0ZXJuYWxDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHRoaXMub25IZWFkZXJBY3RpdmVDaGFuZ2VkKHRhYikpO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG5ldyBpbnN0YW5jZSB0byB0aGUgbGlzdCBvZiB0YWJzLlxyXG4gICAgICAgIHRoaXMudGFicy5wdXNoKHRhYik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2lnbiBlYWNoIHRhYiBhbiBpbmRleCAod2hpY2ggZGVub3RlcyB0aGUgb3JkZXIgdGhleSBwaHlzaWNhbGx5IGFwcGVhciBpbikuXHJcbiAgICB0aGlzLl90YWJIZWFkZXJzXHJcbiAgICAgIC5mb3JFYWNoKCh0SCwgaSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhYiA9IHRoaXMudGFicy5maW5kKHQgPT4gdC5oZWFkZXIgPT09IHRIKTtcclxuICAgICAgICBpZiAodGFiKSB7XHJcbiAgICAgICAgICB0YWIuaW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gU29ydCB0aGUgdGFicyBieSB0aGVpciBpbmRleC5cclxuICAgIHRoaXMudGFicy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XHJcblxyXG5cclxuICAgIGlmICghdGhpcy5hY3RpdmVUYWIpIHsgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIG5vIGN1cnJlbnQgZXhpc3RpbmcgYWN0aXZlIHRhYnMuXHJcbiAgICAgIC8vIElmIHNvLCB3ZSBtdXN0IGFjdGl2YXRlIHRoZSBmaXJzdCBhdmFpbGFibGUgdGFiLlxyXG4gICAgICB0aGlzLmFjdGl2YXRlRmlyc3RUYWIoKTtcclxuICAgIH0gZWxzZSBpZiAoIXRoaXMudGFicy5maW5kKHQgPT4gdCA9PT0gdGhpcy5hY3RpdmVUYWIpKSB7IC8vIE8nd2lzZSBjaGVjayBpZiBjdXJyZW50IGFjdGl2ZSB0YWIgaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICAgLy8gSWYgc28sIHdlIG11c3QgZmluZCB0aGUgY2xvc2VzdC5cclxuICAgICAgLy8gVXNlIGBzZXRUaW1lb3V0YCBhcyB0aGlzIGNhdXNlcyBhICdjaGFuZ2VkIGFmdGVyIGNoZWNrZWQnIGVycm9yIG8nd2lzZS5cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRlQ2xvc2VzdFRhYih0aGlzLmFjdGl2ZVRhYikpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnRhYnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIC8vIEVycm9yIGlmIHRoZXJlIGFyZW4ndCBhbnkgdGFicyBpbiB0aGUgdGFic2V0LlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSBubyB0YWJzIScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmlyZXMgd2hlbmV2ZXIgYSB0YWIgaGVhZGVyJ3MgYWN0aXZlIHN0YXRlIGlzIGV4dGVybmFsbHkgY2hhbmdlZC5cclxuICBwcml2YXRlIG9uSGVhZGVyQWN0aXZlQ2hhbmdlZCh0YWI6IFRhYik6IHZvaWQge1xyXG4gICAgLy8gSWYgdGhlIHRhYiBoYXMgYmVjb21lIGFjdGl2YXRlZCwgYnV0IHdhcyBub3QgcHJldmlvdXNseSB0aGUgYWN0aXZlIHRhYjpcclxuICAgIGlmICh0YWIuaXNBY3RpdmUgJiYgdGhpcy5hY3RpdmVUYWIgIT09IHRhYikge1xyXG4gICAgICAvLyBEZWFjdGl2YXRlIGFsbCBvZiB0aGUgdGFicy5cclxuICAgICAgdGhpcy50YWJzLmZpbHRlcih0ID0+IHQgIT09IHRhYikuZm9yRWFjaCh0ID0+IHQuaXNBY3RpdmUgPSBmYWxzZSk7XHJcblxyXG4gICAgICAvLyBTZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiIHRvIHRoaXMgb25lLlxyXG4gICAgICB0aGlzLmFjdGl2ZVRhYiA9IHRhYjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgdGFiIGhhcyBiZWNvbWUgZGVhY3RpdmF0ZWQsIGJ1dCB3YXMgcHJldmlvdXNseSB0aGUgYWN0aXZlIHRhYjpcclxuICAgIGlmICghdGFiLmlzQWN0aXZlICYmIHRoaXMuYWN0aXZlVGFiID09PSB0YWIpIHtcclxuICAgICAgLy8gQWN0aXZhdGUgdGhlIGNsb3Nlc3QgdGFiIHRvIGl0LlxyXG4gICAgICB0aGlzLmFjdGl2YXRlQ2xvc2VzdFRhYih0YWIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=