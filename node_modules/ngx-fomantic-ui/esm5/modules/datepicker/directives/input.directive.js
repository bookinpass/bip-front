/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Host, HostBinding, HostListener, Input, Renderer2 } from '@angular/core';
import { DateUtil } from '../../../misc/util/internal';
import { FuiLocalizationService } from '../../../behaviors/localization/internal';
import { PopupTrigger } from '../../popup/internal';
import { FuiDatepickerDirective, FuiDatepickerDirectiveValueAccessor } from './datepicker.directive';
import { DateParser, InternalDateParser } from '../classes/date-parser';
var FuiDatepickerInputDirective = /** @class */ (function () {
    function FuiDatepickerInputDirective(datepicker, valueAccessor, _renderer, _element, localizationService) {
        var _this = this;
        this.datepicker = datepicker;
        this.valueAccessor = valueAccessor;
        this._renderer = _renderer;
        this._element = _element;
        this.useNativeOnMobile = true;
        this.fallbackActive = false;
        // Whenever the datepicker value updates, update the input text alongside it.
        this.datepicker.onSelectedDateChange.subscribe((/**
         * @return {?}
         */
        function () {
            return _this.updateValue(_this.selectedDateString);
        }));
        localizationService.onLanguageUpdate.subscribe((/**
         * @return {?}
         */
        function () {
            return _this.updateValue(_this.selectedDateString);
        }));
    }
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "parser", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.fallbackActive) {
                return new InternalDateParser(this.datepicker.mode, this.datepicker.localeValues);
            }
            return new DateParser(this.datepicker.localeValues.formats[this.datepicker.mode], this.datepicker.localeValues);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "selectedDateString", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.datepicker.selectedDate) {
                return this.parser.format(this.datepicker.selectedDate);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.fallbackActive) {
                return this.datepicker.config.fallback;
            }
            return 'text';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "max", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.fallbackActive && this.datepicker.maxDate) {
                // Since HTML doesn't use a date object max is somewhat tricky.
                // Our Datepicker will always choose the 1st date on the provided precision,
                // meaning anything below the maxDate will work, hence endOf.
                /** @type {?} */
                var max = DateUtil.endOf(this.datepicker.config.precision, DateUtil.clone(this.datepicker.maxDate));
                return this.parser.format(max);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "min", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.fallbackActive && this.datepicker.minDate) {
                // Since HTML doesn't use a date object min is somewhat tricky.
                // We use 1 minute before the next date at the configured precision since
                // our Datepicker picks the first available date at that precision.
                /** @type {?} */
                var min = DateUtil.clone(this.datepicker.minDate);
                return this.parser.format(min);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "useNativeOnMobile", {
        get: /**
         * @return {?}
         */
        function () {
            return this._useNativeOnMobile;
        },
        set: /**
         * @param {?} fallback
         * @return {?}
         */
        function (fallback) {
            this._useNativeOnMobile = fallback;
            /** @type {?} */
            var isOnMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(navigator.userAgent);
            this.fallbackActive = this.useNativeOnMobile && isOnMobile;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FuiDatepickerInputDirective.prototype, "fallbackActive", {
        get: /**
         * @return {?}
         */
        function () {
            return this._fallbackActive;
        },
        set: /**
         * @param {?} active
         * @return {?}
         */
        function (active) {
            this._fallbackActive = active;
            // If the fallback is active, then the trigger must be manual so the datepicker never opens.
            this.datepicker.popup.config.trigger = this.fallbackActive ? PopupTrigger.Manual : PopupTrigger.Focus;
            // Update the input value (this will insert the `T` as required).
            this.updateValue(this.selectedDateString);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    FuiDatepickerInputDirective.prototype.typeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._lastUpdateTyped = true;
        this._currentInputValue = value;
        if (!value) {
            // Delete the selected date if no date was entered manually.
            return this.datepicker.writeValue(undefined);
        }
        /** @type {?} */
        var parsed = this.parser.parse(value, this.datepicker.selectedDate);
        if (!isNaN(parsed.getTime()) && value === this.parser.format(parsed)) {
            return this.datepicker.writeValue(parsed);
        }
        return this.datepicker.writeValue(undefined);
    };
    /**
     * @return {?}
     */
    FuiDatepickerInputDirective.prototype.onFocusOut = /**
     * @return {?}
     */
    function () {
        this.valueAccessor.onTouched();
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    FuiDatepickerInputDirective.prototype.updateValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // Only update the current value if it is different to what it's being updated to.
        // This is so that the editing position isn't changed when manually typing the date.
        if (!this._lastUpdateTyped) {
            this._renderer.setProperty(this._element.nativeElement, 'value', value || '');
        }
        this._lastUpdateTyped = false;
    };
    FuiDatepickerInputDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[fuiDatepicker]'
                },] }
    ];
    /** @nocollapse */
    FuiDatepickerInputDirective.ctorParameters = function () { return [
        { type: FuiDatepickerDirective, decorators: [{ type: Host }] },
        { type: FuiDatepickerDirectiveValueAccessor, decorators: [{ type: Host }] },
        { type: Renderer2 },
        { type: ElementRef },
        { type: FuiLocalizationService }
    ]; };
    FuiDatepickerInputDirective.propDecorators = {
        type: [{ type: HostBinding, args: ['attr.type',] }],
        max: [{ type: HostBinding, args: ['attr.max',] }],
        min: [{ type: HostBinding, args: ['attr.min',] }],
        useNativeOnMobile: [{ type: Input, args: ['pickerUseNativeOnMobile',] }],
        typeValue: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
        onFocusOut: [{ type: HostListener, args: ['focusout',] }]
    };
    return FuiDatepickerInputDirective;
}());
export { FuiDatepickerInputDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._currentInputValue;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._lastUpdateTyped;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._useNativeOnMobile;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._fallbackActive;
    /** @type {?} */
    FuiDatepickerInputDirective.prototype.datepicker;
    /** @type {?} */
    FuiDatepickerInputDirective.prototype.valueAccessor;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    FuiDatepickerInputDirective.prototype._element;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWZvbWFudGljLXVpLyIsInNvdXJjZXMiOlsibW9kdWxlcy9kYXRlcGlja2VyL2RpcmVjdGl2ZXMvaW5wdXQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3ZHLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUNyRCxPQUFPLEVBQUMsc0JBQXNCLEVBQUMsTUFBTSwwQ0FBMEMsQ0FBQztBQUNoRixPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDbEQsT0FBTyxFQUFDLHNCQUFzQixFQUFFLG1DQUFtQyxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDbkcsT0FBTyxFQUFDLFVBQVUsRUFBRSxrQkFBa0IsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBRXRFO0lBUUUscUNBQTJCLFVBQWtDLEVBQ2xDLGFBQWtELEVBQ3pELFNBQW9CLEVBQ3BCLFFBQW9CLEVBQzVCLG1CQUEyQztRQUp2RCxpQkFlQztRQWYwQixlQUFVLEdBQVYsVUFBVSxDQUF3QjtRQUNsQyxrQkFBYSxHQUFiLGFBQWEsQ0FBcUM7UUFDekQsY0FBUyxHQUFULFNBQVMsQ0FBVztRQUNwQixhQUFRLEdBQVIsUUFBUSxDQUFZO1FBR3RDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7UUFDOUIsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7UUFFNUIsNkVBQTZFO1FBQzdFLElBQUksQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsU0FBUzs7O1FBQUM7WUFDN0MsT0FBQSxLQUFJLENBQUMsV0FBVyxDQUFDLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQztRQUF6QyxD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LEVBQUUsT0FBTyxFQUFFLEtBQUssSUFBSSxFQUFFLENBQUMsQ0FBQztTQUMvRTtRQUVELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7SUFDaEMsQ0FBQzs7Z0JBN0hGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsc0JBQXNCO2lCQUNqQzs7OztnQkFMTyxzQkFBc0IsdUJBV2YsSUFBSTtnQkFYYSxtQ0FBbUMsdUJBWXBELElBQUk7Z0JBaEJvRCxTQUFTO2dCQUE3RCxVQUFVO2dCQUVyQixzQkFBc0I7Ozt1QkEyQzNCLFdBQVcsU0FBQyxXQUFXO3NCQVF2QixXQUFXLFNBQUMsVUFBVTtzQkFXdEIsV0FBVyxTQUFDLFVBQVU7b0NBYXRCLEtBQUssU0FBQyx5QkFBeUI7NEJBeUIvQixZQUFZLFNBQUMsT0FBTyxFQUFFLENBQUMscUJBQXFCLENBQUM7NkJBaUI3QyxZQUFZLFNBQUMsVUFBVTs7SUFjMUIsa0NBQUM7Q0FBQSxBQTlIRCxJQThIQztTQTNIWSwyQkFBMkI7Ozs7OztJQUV0Qyx5REFBK0M7Ozs7O0lBQy9DLHVEQUFrQzs7Ozs7SUE4RGxDLHlEQUFvQzs7Ozs7SUFhcEMsc0RBQWlDOztJQXpFckIsaURBQWlEOztJQUNqRCxvREFBaUU7Ozs7O0lBQ2pFLGdEQUE0Qjs7Ozs7SUFDNUIsK0NBQTRCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3QsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBSZW5kZXJlcjJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0RhdGVVdGlsfSBmcm9tICcuLi8uLi8uLi9taXNjL3V0aWwvaW50ZXJuYWwnO1xyXG5pbXBvcnQge0Z1aUxvY2FsaXphdGlvblNlcnZpY2V9IGZyb20gJy4uLy4uLy4uL2JlaGF2aW9ycy9sb2NhbGl6YXRpb24vaW50ZXJuYWwnO1xyXG5pbXBvcnQge1BvcHVwVHJpZ2dlcn0gZnJvbSAnLi4vLi4vcG9wdXAvaW50ZXJuYWwnO1xyXG5pbXBvcnQge0Z1aURhdGVwaWNrZXJEaXJlY3RpdmUsIEZ1aURhdGVwaWNrZXJEaXJlY3RpdmVWYWx1ZUFjY2Vzc29yfSBmcm9tICcuL2RhdGVwaWNrZXIuZGlyZWN0aXZlJztcclxuaW1wb3J0IHtEYXRlUGFyc2VyLCBJbnRlcm5hbERhdGVQYXJzZXJ9IGZyb20gJy4uL2NsYXNzZXMvZGF0ZS1wYXJzZXInO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdpbnB1dFtmdWlEYXRlcGlja2VyXSdcclxufSlcclxuZXhwb3J0IGNsYXNzIEZ1aURhdGVwaWNrZXJJbnB1dERpcmVjdGl2ZSB7XHJcblxyXG4gIHByaXZhdGUgX2N1cnJlbnRJbnB1dFZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgcHJpdmF0ZSBfbGFzdFVwZGF0ZVR5cGVkOiBib29sZWFuO1xyXG5cclxuICBjb25zdHJ1Y3RvcihASG9zdCgpIHB1YmxpYyBkYXRlcGlja2VyOiBGdWlEYXRlcGlja2VyRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICAgIEBIb3N0KCkgcHVibGljIHZhbHVlQWNjZXNzb3I6IEZ1aURhdGVwaWNrZXJEaXJlY3RpdmVWYWx1ZUFjY2Vzc29yLFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZixcclxuICAgICAgICAgICAgICBsb2NhbGl6YXRpb25TZXJ2aWNlOiBGdWlMb2NhbGl6YXRpb25TZXJ2aWNlKSB7XHJcblxyXG4gICAgdGhpcy51c2VOYXRpdmVPbk1vYmlsZSA9IHRydWU7XHJcbiAgICB0aGlzLmZhbGxiYWNrQWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgLy8gV2hlbmV2ZXIgdGhlIGRhdGVwaWNrZXIgdmFsdWUgdXBkYXRlcywgdXBkYXRlIHRoZSBpbnB1dCB0ZXh0IGFsb25nc2lkZSBpdC5cclxuICAgIHRoaXMuZGF0ZXBpY2tlci5vblNlbGVjdGVkRGF0ZUNoYW5nZS5zdWJzY3JpYmUoKCkgPT5cclxuICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLnNlbGVjdGVkRGF0ZVN0cmluZykpO1xyXG5cclxuICAgIGxvY2FsaXphdGlvblNlcnZpY2Uub25MYW5ndWFnZVVwZGF0ZS5zdWJzY3JpYmUoKCkgPT5cclxuICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLnNlbGVjdGVkRGF0ZVN0cmluZykpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBwYXJzZXIoKTogRGF0ZVBhcnNlciB7XHJcbiAgICBpZiAodGhpcy5mYWxsYmFja0FjdGl2ZSkge1xyXG4gICAgICByZXR1cm4gbmV3IEludGVybmFsRGF0ZVBhcnNlcih0aGlzLmRhdGVwaWNrZXIubW9kZSwgdGhpcy5kYXRlcGlja2VyLmxvY2FsZVZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IERhdGVQYXJzZXIodGhpcy5kYXRlcGlja2VyLmxvY2FsZVZhbHVlcy5mb3JtYXRzW3RoaXMuZGF0ZXBpY2tlci5tb2RlXSwgdGhpcy5kYXRlcGlja2VyLmxvY2FsZVZhbHVlcyk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHNlbGVjdGVkRGF0ZVN0cmluZygpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgaWYgKHRoaXMuZGF0ZXBpY2tlci5zZWxlY3RlZERhdGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLmZvcm1hdCh0aGlzLmRhdGVwaWNrZXIuc2VsZWN0ZWREYXRlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEBIb3N0QmluZGluZygnYXR0ci50eXBlJylcclxuICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcclxuICAgIGlmICh0aGlzLmZhbGxiYWNrQWN0aXZlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGVwaWNrZXIuY29uZmlnLmZhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICd0ZXh0JztcclxuICB9XHJcblxyXG4gIEBIb3N0QmluZGluZygnYXR0ci5tYXgnKVxyXG4gIHB1YmxpYyBnZXQgbWF4KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgICBpZiAodGhpcy5mYWxsYmFja0FjdGl2ZSAmJiB0aGlzLmRhdGVwaWNrZXIubWF4RGF0ZSkge1xyXG4gICAgICAvLyBTaW5jZSBIVE1MIGRvZXNuJ3QgdXNlIGEgZGF0ZSBvYmplY3QgbWF4IGlzIHNvbWV3aGF0IHRyaWNreS5cclxuICAgICAgLy8gT3VyIERhdGVwaWNrZXIgd2lsbCBhbHdheXMgY2hvb3NlIHRoZSAxc3QgZGF0ZSBvbiB0aGUgcHJvdmlkZWQgcHJlY2lzaW9uLFxyXG4gICAgICAvLyBtZWFuaW5nIGFueXRoaW5nIGJlbG93IHRoZSBtYXhEYXRlIHdpbGwgd29yaywgaGVuY2UgZW5kT2YuXHJcbiAgICAgIGNvbnN0IG1heCA9IERhdGVVdGlsLmVuZE9mKHRoaXMuZGF0ZXBpY2tlci5jb25maWcucHJlY2lzaW9uLCBEYXRlVXRpbC5jbG9uZSh0aGlzLmRhdGVwaWNrZXIubWF4RGF0ZSkpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZXIuZm9ybWF0KG1heCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBASG9zdEJpbmRpbmcoJ2F0dHIubWluJylcclxuICBwdWJsaWMgZ2V0IG1pbigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgaWYgKHRoaXMuZmFsbGJhY2tBY3RpdmUgJiYgdGhpcy5kYXRlcGlja2VyLm1pbkRhdGUpIHtcclxuICAgICAgLy8gU2luY2UgSFRNTCBkb2Vzbid0IHVzZSBhIGRhdGUgb2JqZWN0IG1pbiBpcyBzb21ld2hhdCB0cmlja3kuXHJcbiAgICAgIC8vIFdlIHVzZSAxIG1pbnV0ZSBiZWZvcmUgdGhlIG5leHQgZGF0ZSBhdCB0aGUgY29uZmlndXJlZCBwcmVjaXNpb24gc2luY2VcclxuICAgICAgLy8gb3VyIERhdGVwaWNrZXIgcGlja3MgdGhlIGZpcnN0IGF2YWlsYWJsZSBkYXRlIGF0IHRoYXQgcHJlY2lzaW9uLlxyXG4gICAgICBjb25zdCBtaW4gPSBEYXRlVXRpbC5jbG9uZSh0aGlzLmRhdGVwaWNrZXIubWluRGF0ZSk7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlci5mb3JtYXQobWluKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3VzZU5hdGl2ZU9uTW9iaWxlOiBib29sZWFuO1xyXG5cclxuICBASW5wdXQoJ3BpY2tlclVzZU5hdGl2ZU9uTW9iaWxlJylcclxuICBwdWJsaWMgZ2V0IHVzZU5hdGl2ZU9uTW9iaWxlKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3VzZU5hdGl2ZU9uTW9iaWxlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCB1c2VOYXRpdmVPbk1vYmlsZShmYWxsYmFjazogYm9vbGVhbikge1xyXG4gICAgdGhpcy5fdXNlTmF0aXZlT25Nb2JpbGUgPSBmYWxsYmFjaztcclxuICAgIGNvbnN0IGlzT25Nb2JpbGUgPSAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaXxNb2JpbGV8bW9iaWxlfENyaU9TL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICAgIHRoaXMuZmFsbGJhY2tBY3RpdmUgPSB0aGlzLnVzZU5hdGl2ZU9uTW9iaWxlICYmIGlzT25Nb2JpbGU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9mYWxsYmFja0FjdGl2ZTogYm9vbGVhbjtcclxuXHJcbiAgcHVibGljIGdldCBmYWxsYmFja0FjdGl2ZSgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja0FjdGl2ZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXQgZmFsbGJhY2tBY3RpdmUoYWN0aXZlOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLl9mYWxsYmFja0FjdGl2ZSA9IGFjdGl2ZTtcclxuICAgIC8vIElmIHRoZSBmYWxsYmFjayBpcyBhY3RpdmUsIHRoZW4gdGhlIHRyaWdnZXIgbXVzdCBiZSBtYW51YWwgc28gdGhlIGRhdGVwaWNrZXIgbmV2ZXIgb3BlbnMuXHJcbiAgICB0aGlzLmRhdGVwaWNrZXIucG9wdXAuY29uZmlnLnRyaWdnZXIgPSB0aGlzLmZhbGxiYWNrQWN0aXZlID8gUG9wdXBUcmlnZ2VyLk1hbnVhbCA6IFBvcHVwVHJpZ2dlci5Gb2N1cztcclxuICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUgKHRoaXMgd2lsbCBpbnNlcnQgdGhlIGBUYCBhcyByZXF1aXJlZCkuXHJcbiAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMuc2VsZWN0ZWREYXRlU3RyaW5nKTtcclxuICB9XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQudGFyZ2V0LnZhbHVlJ10pXHJcbiAgcHVibGljIHR5cGVWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogdm9pZCB7XHJcbiAgICB0aGlzLl9sYXN0VXBkYXRlVHlwZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5fY3VycmVudElucHV0VmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgIC8vIERlbGV0ZSB0aGUgc2VsZWN0ZWQgZGF0ZSBpZiBubyBkYXRlIHdhcyBlbnRlcmVkIG1hbnVhbGx5LlxyXG4gICAgICByZXR1cm4gdGhpcy5kYXRlcGlja2VyLndyaXRlVmFsdWUodW5kZWZpbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlci5wYXJzZSh2YWx1ZSwgdGhpcy5kYXRlcGlja2VyLnNlbGVjdGVkRGF0ZSk7XHJcbiAgICBpZiAoIWlzTmFOKHBhcnNlZC5nZXRUaW1lKCkpICYmIHZhbHVlID09PSB0aGlzLnBhcnNlci5mb3JtYXQocGFyc2VkKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRlcGlja2VyLndyaXRlVmFsdWUocGFyc2VkKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmRhdGVwaWNrZXIud3JpdGVWYWx1ZSh1bmRlZmluZWQpO1xyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignZm9jdXNvdXQnKVxyXG4gIHB1YmxpYyBvbkZvY3VzT3V0KCk6IHZvaWQge1xyXG4gICAgdGhpcy52YWx1ZUFjY2Vzc29yLm9uVG91Y2hlZCgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGVWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogdm9pZCB7XHJcbiAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgY3VycmVudCB2YWx1ZSBpZiBpdCBpcyBkaWZmZXJlbnQgdG8gd2hhdCBpdCdzIGJlaW5nIHVwZGF0ZWQgdG8uXHJcbiAgICAvLyBUaGlzIGlzIHNvIHRoYXQgdGhlIGVkaXRpbmcgcG9zaXRpb24gaXNuJ3QgY2hhbmdlZCB3aGVuIG1hbnVhbGx5IHR5cGluZyB0aGUgZGF0ZS5cclxuICAgIGlmICghdGhpcy5fbGFzdFVwZGF0ZVR5cGVkKSB7XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUgfHwgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2xhc3RVcGRhdGVUeXBlZCA9IGZhbHNlO1xyXG4gIH1cclxufVxyXG4iXX0=